[{"categories":null,"contents":"Spiekbriefje met veelgebruikte Processing-instructies.\nHet spiekbriefje is ook als Processing_spiekbriefje.pdf te downloaden.\nAls je eerst nog wat meer uitleg wil over kunst maken met Processing, kun je deze uitleg downloaden: Processing3-Coderdojo-Nm.pdf.\nBasis van een Processing-script void setup() { // één keer doen } void draw() { // steeds opnieuw }  Vormen Rechthoek rect(20, 20, 40, 40);  rechthoek\nEllips ellipse(0, 0, 80, 40);  ronde vorm van 80 pixels breed en 40 hoog\nLijn line(20, 20, 80, 50);  rechte lijn met beginpunt 20,20 en eindpunt 80,50\nVierhoek quad(152, 124, 344, 80, 276, 252, 120, 304);  vierhoek\nAndere vormen  arc(50, 50, 80, 80, PI); halve cirkel curve gebogen lijnen bezier nog meer gebogen lijnen beginShape, vertex en endShape complexe vormen  Kleur  background(255); achtergrondkleur fill(100); inkleuren noFill(); niet inkleuren stroke(30); kleur van randen strokeWeight(5); dikte van randen noStroke(); geen randen  Voorbeelden:\n fill(200); één getal is een grijswaarde tussen zwart (0) en wit (255) fill(255, 20); twee getallen: grijswaarde en doorzichtigheid fill(255, 40, 200); drie getallen: rood, groen en blauw mengen fill(255, 100, 100, 30); rood, groen, blauw en doorzichtigheid  Grootte van het Processing-scherm  size(200, 200); grootte scherm opgeven fullScreen(); scherm beeldvullend maken width breedte van scherm als variabele height hoogte van scherm als variabele  Het midden van het scherm vind je door width en height door tweeën te delen:\n rect(width/2, height/2, 40, 40);  Muis en toetsenbord  mouseX horizontale positie van je muis mouseY verticale positie van je muis  Deze woorden kun je gebruiken in een if-statement of als functie:\n mousePressed ‘true’ als je op muis klikt mouseDragged ‘true’ als je muis over het scherm sleept mouseMoved als de muis beweegt zonder dat de knop is ingedrukt keyPressed ‘true’ als je typt key variabele met de laatst getypte toets  Variabelen In verschillende variabelen kun je verschillende soorten informatie bewaren:\n  int hele getallen, positief of negatief\n  float decimale getallen\n  boolean waar/niet waar, ‘true’ of ‘false’\n  string een tekst\n  char een enkele letter\n  color een kleur\n  int getal = 10;\n  float variabele1 = 3.01;\n  Vragen stellen  if (voorwaarde) { .. } if-statement  // zijn het er meer dan 10? if (aantal \u0026gt; 10) { // zo ja, doe dan hier iets }   \u0026lt; kleiner dan \u0026gt; groter dan == gelijk aan != niet gelijk aan  Iets meerdere keren doen  while (voorwaarde) { .. } while loop: blijf iets doen zolang de voorwaarde waar is for (int i=0; i \u0026lt; 10; i++) { .. } for-loop (in dit voorbeeld): begin bij 0, ga door zolang we nog niet bij 10 zijn, en tel er steeds 1 bij op.  Steeds anders  random() kies een willekeurig getal noise() willekeurig, maar wel steeds dichtbij het getal ervoor frameCount aantal beeldjes in de animatie tot nu toe  Het canvas verschuiven of draaien float r; // variabele  void setup() { rectMode(CENTER); } void draw() { background(51); translate(width/2, height/2); rotate(r); // draaiing  rect(0, 0, 60, 60); // klein beetje verder draaien  r += 0.02; }   rotate(0.1); draai het canvas rond 0,0 translate(300, 300); verplaats het beginpunt van het canvas (dus 0,0) van linksbovenin naar ergens anders (bijvoorbeeld het midden). pushMatrix(); onthou alle rotates en translates die hierna komen popMatrix(); maak alle rotates en translates ongedaan voor alles wat hierna komt.  Nummers passend maken met map() Waarde (bijvoorbeeld de muispositie) ‘vertalen’ naar een ander bereik:\nfloat h = map(mouseX, 0, width, 40, 300);\nAfstand tot een bepaald punt met dist() void draw() { float d = dist(50, 50, mouseX, mouseY); float gray = map(d, 0, 100, 0, 255); fill(gray); rect(0, 0, width, height); }  Tekst invoegen textSize(20); text(\u0026#34;tekst komt\u0026#34;, 6, 20); textSize(50); text(\u0026#34;hier\u0026#34;, 6, 70);  Plaatjes inladen PImage foto; // variabele  void setup() { size(400, 400); // laad een plaatje in die in  // dezelfde map staat als dit script  foto = loadImage(\u0026#34;foto.jpg\u0026#34;); } void draw() { // laat het plaatje zien  image(foto, 0, 0); }  Golfbewegingen met sinus Gebruik sin() en cos() om golvende veranderingen te krijgen: float hoek = 0; // variabele void draw( ) { background(0); // sinus gebruiken als grootte circle(50, 50, sin(hoek)*100); // hoek een klein beetje veranderen hoek += 0.02; } \nMeer informatie en inspiratie Dit zijn nog lang niet alle functies in Processing! Op https://processing.org/reference vind je alle functies mét uitleg.\nMooie voorbeelden van wat er allemaal kan met Processing zie je op\n https://processing.org/examples https://openprocessing.org https://reddit.com/r/processing http://generative-gestaltung.de/2/  Probeer het!   Maak een vierkant dat steeds opnieuw getekend wordt op de plek van je muis. Teken steeds een nieuwe achtergrond in draw() met een kleur die verandert met de muispositie.\n  Teken een puntje op de plek waar de muis is. Zet geen background() in draw(). Probeer het ook met andere vormen en kleuren, ook met half-doorzichtige. Kun je een tweede vorm maken die in omgekeerde richting beweegt?\n  Teken een vorm die van heel klein steeds een beetje groter wordt (met een variabele, niet op basis van de muis). Laat hem opnieuw klein beginnen als je op de muis klikt óf als hij groter wordt dan de breedte van het scherm. Gebruik dezelfde variabele ook om de positie en kleur te veranderen.\n  Teken een stuk of 10 vierkantjes onder elkaar. Laat ze horizontaal mee-veranderen met de muispositie, maar zorg dat elk vierkantje dat nèt iets anders doet. (Tip: je kunt getallen bij mouseX optellen, maar mouseX ook vermenigvuldigen en delen! Vermenigvulden doe je met * en delen met /.)\n  Maak confetti! Teken steeds een nieuwe kleine cirkel op steeds een andere plek met steeds een andere kleur. (Tip: gebruik random() voor de x- en y-positie én voor de kleuren. Probeer ook een donkere achtergrond!)\n  Teken een bijna helemaal doorzichtig rondje met dikke rand op een lichte achtergrond. Teken die achtergrond niet in draw().\n  Maak een bloem met overlappende cirkels!\n  Schrijf een woord steeds ergens anders op het scherm, met steeds een andere kleur.\n  Schrijf smileys met tekst (:-)) met een gele cirkel eromheen, steeds op een andere plek. (Probeer het eerst op de simpelste manier. Als je daarna ook nog translate() en rotate() gebruikt, dan kun je de smileys ook nog om hun as laten draaien!)\n  Teken een vorm die steeds van plek verandert. Als hij bij de randen aankomt, laat hem dan van kleur veranderen en een andere kant op gaan. (Hier heb je variabelen bij nodig om de x- en y-positie van je vorm op te slaan, en een paar if-statements.)\n  Teken twee vormen naast elkaar. De grootte van de ene is afhankelijk van de muispositie, die van de andere van de muispositie min ongeveer de helft van de breedte van het scherm.\n  Teken een cirkel die van kleur verandert als je dichterbij komt.\u2028(Tip: dit is het makkelijkst met dist().)\n  Teken 8 cirkels die in elkaar zitten. (Tip: gebruik een while-loop of for-loop.)\n  Maak een spiraal! Gebruik translate() en rotate() om vormen niet alleen verder weg te laten bewegen, maar ook steeds verder van een middelpunt af te tekenen.\n  Teken een bijna helemaal doorzichtige lijn helemaal van bovenaan het scherm naar onderaan. Gebruik je muis als horizontale positie. Teken geen achtergrond in draw().\n  Verplaats het beginpunt van je canvas naar ergens met translate(), laat het canvas steeds een klein beetje ronddraaien met rotate() en teken een of meer rechthoeken.\n  Teken heel veel kleine rondjes naast elkaar en verander elke keer de kleur een klein beetje. Probeer ze in een cirkel te laten tekenen met rotate()!\n  Teken meerdere vormen waarvan je de positie (of draaiing) met een sinus-functie bepaalt.\n  Maak een soort zon door driehoeken en lijnen rond een middelpunt te tekenen. (Tip: gebruik translate() en rotate().)\n  Verder variëren met\n Vorm Grootte Kleur (en doorzichtigheid) Positie Beweging (snelheid en richting) Rotatie Aantal Blijvend in beeld of niet Input van het toetsenbord  Probeer ook tekst, image, video, webcam en sound! Zie de voorbeeld-scripts in Processing onder het menu Bestand \u0026gt; Voorbeelden.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"December 8, 2021","permalink":"/instructies/processing-spiekbriefje/","title":"Processing - Spiekbriefje"},{"categories":null,"contents":"Kunst maken in de browser.\n\r\rIntroductie Naast kunst met Scratch en Python, kan je ook kunst programmeren met Processing.\nEr is een Processing variant voor in de browser. Deze heet p5.js. We gaan er in deze instructie mee aan de slag. Eerst een voorbeeld van wat je ermee kunt doen:\n\rde code bij dit voorbeeld  Favoriet van Jaap! 😉\nKopie van Sketch 422446.\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  var circle = 200; var rot; var col; var freq = 0.000005; var cont = 0; var r; function setup() { createCanvas(600, 600); } function draw() { background(242); translate(300, 300); rotate(radians(rot)); ellipseMode(RADIUS); for (var i=0; i\u0026lt;500; i ++) { circle= 200 + 50*sin(millis()*freq*i); col=map(circle,150,250,255,60); r=map(circle,150,250,5,2); fill(col,0,74); noStroke(); ellipse(circle*cos(i), circle*sin(i),r,r); rot=rot+0.00005; } }   \r  Editor p5.js is een Javascript bibliotheek. Deze kun je in elke webpagina integreren. Je kunt \u0026ldquo;sketches\u0026rdquo; schrijven in een editor op je PC en het resultaat dan bekijken in een webbrowser. Het is echter makkelijker om een editor in de browser zelf te gebruiken. Ga daarvoor naar deze editor.\nDe volgende instructies en voorbeelden gaan ervan uit dat je deze editor gebruikt.\nDe basis p5.js sketches hebben de volgende basis:\n1 2 3 4 5  function setup() { }  function draw() { }    Er zijn twee functies die worden aangeroepen door de p5.js bibliotheek:\n setup() wordt éénmaal bij de start van het script uitgevoerd draw() wordt oneindig herhaald en iedere schermvernieuwing aangeroepen (normaal 60 keer per seconde)  In de setup() functie zet je éénmalige instellingen, zoals bijvoorbeeld een vaste achtegrondkleur. In de draw() functie dingen die veranderen, zoals bijvoorbeeld een verschuivende kubus.\nHet volgende voorbeeld tekent een draaiend vierkant:\n1 2 3 4 5 6 7 8 9 10  function setup() { createCanvas(150, 150); } function draw() { background(255); translate(width / 2, height / 2); rotate(frameCount/50); rect(-26, -26, 52, 52); }    \rWe zullen stap voor stap door de code heen lopen:\n op regel 2 in de setup functie wordt het tekenblad (canvas) gemaakt. Dit hoeft slechts 1 keer te gebeuren. regels 6 tot en met 9 worden telkens herhaald:  background(255) maakt de achtergrond kleur wit (waarde 255). translate(width / 2, height / 2) zorgt ervoor dat het vierkant midden in het tekenblad komt. rotate(frameCount / 50) draait het vierkant iedere keer dat dit wordt uitgevoerd. frameCount staat voor het aantal schermvernieuwingen per seconde. Daardoor bepaald frameCount / 50 de snelheid waarmee het vierkant draait. tenslotte tekent rect(-26, -26, 52, 52) het vierkant.    Opdracht 1: neem de code over in de editor en kijk of er een draaiend vierkant wordt getekend door op de speel knop te klikken.\nOpdracht 2: vervang waarde 255 op regel 6 eens met een andere waarde tussen 0 en 256. Wat gebeurt er met een lage waarde? En wat met een hoge?\nOpdracht 3: misschien vraag je je af waarom de achtergrond iedere keer opnieuw moet worden getekend? Door // voor de regel te zetten, maak je er commentaar van en wordt het niet meer uitgevoerd. Zet // voor regel 6. Wat gebeurt er?\nOpdracht 4: regel 8 zorgt ervoor dat het vierkant draait. Verander waarde 50 eens door 10. Wat gebeurt er? En bij een waarde van 100?\nOpdracht 5: regel 9 tekent het vierkant. De eerste twee getallen -26 verschuiven het draaipunt van het vierkant horizontaal en vertikaal. De twee laatste bepalen de hoogte en breedte. Vervang de getallen 52 eens door 75. Wat gebeurt er? En als je één van de twee 52 laat en de ander veranderd naar 75?\nNa het uitvoeren van deze eerste opdrachten begrijp je een beetje hoe het werkt. In de volgende hoofdstukken gaan we verder met meer voorbeelden en uitleg.\nCirkels en muis In dit hoofdstuk gaan we kunst maken met je muis. Beweeg je muis maar eens over het grijze vlak hieronder. 😉\n\rStap voor stap gaan we dit nabouwen.\rTekenvlak We beginnen met het vlak waarin we de cirkels gaan tekenen:\n1 2 3 4 5 6 7  function setup() { createCanvas(710, 400); background(102); } function draw() { }    Opdracht 6: neem bovenstaande code over in de editor en voer het programma uit. Je hebt nu een grijs vlak.\nEen cirkel De volgende stap is een cirkel:\n1 2 3 4 5 6 7 8  function setup() { createCanvas(710, 400); background(102); } function draw() { ellipse(300, 200, 60, 60); }    Opdracht 7: neem regel 7 over in je code en voer het programma uit. Er verschijnt nu een witte cirkel in het grijze vlak. Wat gebeurt er als je de getallen 300 en 200 veranderd? En als je de getallen 60 veranderd?\nDe cirkel bewegen met de muis Om de cirkel te bewegen met de muis, moet je er voor zorgen dat de cirkel de positie van de muis volgt:\n1 2 3 4 5 6 7 8  function setup() { createCanvas(710, 400); background(102); } function draw() { ellipse(mouseX, mouseY, 60, 60); }    Opdracht 8: vervang de getallen 300 en 200 in regel 7 met mouseX en mouseY. Deze twee variabelen bevatten de horizontale positie (mouseX) en vertikale positie (mouseY) van de muis. Voor je programma uit. Beweegt de cirkel mee?\nEen kleurtje voor de cirkel Het voorbeeld heeft een gekleurde cirkel. Laten we eens een kleurtje toevoegen:\n1 2 3 4 5 6 7 8 9  function setup() { createCanvas(710, 400); background(102); } function draw() { fill(color(255, 128, 0));  ellipse(mouseX, mouseY, 60, 60); }    Opdracht 9: voeg regel 7 toe aan je code. Welke kleur heeft de cirkel?\nHet commando fill() vult het figuur dat erna wordt getekend met de kleur die wordt bepaald door het commando color(). Het commando color() heeft 3 parameters, een voor rood, een voor groen en een voor blauw. Alle drie de kleuren kunnen met een getal tussen 0 en 255 worden bepaald. 0 is geen kleur en 255 is maximaal kleur. color(0, 0, 0) komt daarmee overeen met zwart en color(255, 0, 0) met helder rood.\nOpdracht 10: speel met de kleur van de cirkel door met de getallen 255, 128 en 0 op regel 7 te variëren.\nDe cirkel grootte afhankelijk van de snelheid Als je de snelheid van de muis berekent, kun je die gebruiken om de grootte van de cirkel ermee aan te passen:\n1 2 3 4 5 6 7 8 9 10  function setup() { createCanvas(710, 400); background(102); } function draw() { let snelheid = abs(mouseX - pmouseX) + abs(mouseY - pmouseY)  fill(color(255, 128, 0)); ellipse(mouseX, mouseY, snelheid, snelheid); }    Opdracht 11: voeg regel 7 toe en pas regel 9 aan. Wordt de cirkel groter en kleiner?\nOp regel 7 wordt de snelheid van de muis berekend. Wil je daar meer over weten, lees dan door in onderstaande grijze vak.\nHoe bereken je de snelheid van de muis? Op het moment dat je je muis beweegt, dan beweegt het horizontaal, vertikaal of in beide richtingen als je je muis schuin beweegt. Als je je muis langzaam beweegt, dan verschuift het een kleiner stukje per seconde dan als je het sneller beweegt.\nDe verschuiving die je doet, kun je berekenen door het verschil te bepalen tussen de vorige positie en de huidige. In p5.js geven pmouseX en pmouseY de vorige horizontale en vertikale positie en mouseX en mouseY de huidige.\nDe horizontale en vertikale verschuiving kun je als volgt tekenen:\nEen schuine beweging, zoals getekend in het plaatje, is het resultaat van een horizontale en vertikale verschuiving. De lengte van de schuine pijl is dan een maat voor de snelheid. Hoe langer de pijl, hoe groter de verschuiving en dus hoe groter de snelheid.\nDe code bevat een berekening voor de maat van de snelheid (niet 100% correct, maar voldoende voor dit doel). Het telt de horizontale verschuiving (abs(mouseX - pmouseX) op bij de vertikale verschuiving (abs(mouseY - pmouseY)).\n De kleur afhankelijk van de snelheid Naast de grootte van de cirkel is ook de kleur in het voorbeeld afhankelijk van de snelheid van de muis. We hebben de snelheid al berekend, nu gaat we die gebruiken bij het inkleuren van de cirkel:\n1 2 3 4 5 6 7 8 9 10 11  function setup() { createCanvas(710, 400); background(102); } function draw() { let snelheid = abs(mouseX - pmouseX) + abs(mouseY - pmouseY) let kleur = color(255 - snelheid, snelheid, 128 + snelheid) fill(kleur)  ellipse(mouseX, mouseY, snelheid, snelheid); }    Met het commando color op regel 8 kunnen we een kleur maken. Het commando heeft 3 parameters. Het eerste bepaald de hoeveelheid rood (R), het tweede de hoeveelheid groen (G) en het derde en laatste de hoeveelheid blauw (B). Deze RGB waarde zorgt samen een mengsel van de drie kleuren. Daarbij zorgt color(255, 255, 255) voor wit (alle kleuren maximaal) en color(0, 0, 0) voor zwart (alle kleuren uit).\nIn het voorbeeld wordt voor rood de snelheid van 255 afgetrokken. Dus, hoe sneller de muis beweegt, hoe minder rood er in de kleur zit. Bij de middelste kleur, groen, is hoeveelheid direct afhankelijk van de snelheid. Hoe sneller, hoe meer groen er in de kleur zit. Tenslotte zit er bij blauw een minimum van 128 in de kleur en neemt de hoeveelheid blauw toe als de snelheid van de muis toeneemt.\nTenslotte wordt de cirkel ingekleurd met het commando fill(kleur).\nOpdracht 12: wissel de berekening per kleur eens met een andere kleur. Dus bijvoorbeeld 255 - snelheid voor groen in plaats van voor rood. Welke kleuren krijg je?\nGames met P5.js We hebben gezien dat we hele mooie kunst kunnen maken. Ook hebben we programma\u0026rsquo;s gemaakt waar we zelf iets kunnen besturen, bijvoorbeeld met de muis. Nu hebben we alle ingrediënten om ook games te gaan bouwen!\nIn de volgende instructies ga je een spel maken waar je op doelwitten moet klikken. De doelwitten verdwijnen langzaam, en als je te langzaam bent verlies je. Het doel is om zoveel mogelijk doelwitten aan te klikken voordat je verliest!\nOnderstaand een demo van de game:\n\rOpdracht 13 We beginnen met het maken van een canvas van 400 bij 400 pixels. 1 2 3 4 5 6 7  function setup() { createCanvas(400, 400); } function draw() { background(255); }   \nOpdracht 14 Om het spel goed te laten verlopen, moeten we verschillende gegevens bijhouden. Zo willen we bijvoorbeeld weten hoeveel levens de speler nog heeft, zodat we later kunnen bepalen of het spel over is. Daarnaast houden we bij hoe snel de doelwitten krimpen en welke doelwitten we allemaal hebben.\n1 2 3 4 5 6 7 8 9 10 11  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1;  function setup() { createCanvas(400, 400); } function draw() { background(255); }    Opdracht 15 Het is handig als de speler weet hoeveel levens hij nog heeft. Laten we dat toevoegen. De tekst wordt 20 pixels van links, en 20 pixels vanaf boven getekend. Probeer de tekst zelf eens te verplaatsen naar een andere hoek. 1 2 3 4 5 6 7 8 9 10 11 12  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); }   \nOpdracht 16 Laten we wat doelwitten te voorschijn toveren. Onze doelwitten worden cirkels. Om cirkels te tekenen, kunnen we de ellipse functie gebruiken.\nWe hebben eerder al een lijst met doelwitten gemaakt: hier zorgt de eerste regel voor. We gaan nu elk doelwit in de lijst met doelwitten af en tekenen ze op het scherm. Dit doen wij met een for-loop:\n1 2 3 4 5 6  for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); }    Je code zal er (ongeveer) uit zien als volgt. Dit is een lastig onderdeel van de opdracht, dus als je hier vragen over hebt, stel deze dan vooral!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); } }    Opdracht 17 Je zult zien dat er nog niks getekend wordt. Dat komt omdat we nog geen doelwitten hebben toegevoegd aan onze lijst. We kunnen de doelwitten op onderstaande manier toevoegen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); //voeg begin doelwitten toe  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); } }    Opdracht 18 Cool! Maar er gebeurt nog steeds niks. We voegen een regel toe zodat de doelwitten langzaam krimpen.\n16 17 18 19 20 21 22 23 24 25 26 27 28 29  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid;  } }    Opdracht 19 Als je het programma nu draait en lang genoeg wacht, dan zullen de cirkels verdwijnen. Maar wacht eens: ze komen daarna weer terug?!\nDit gebeurt omdat de grootte van de cirkels negatief wordt na een tijdje. De computer interpreteert dit echter als een positief getal. Omdat dit niet de bedoeling van het spel is, moeten we een doelwit weggooien als het te klein is om nog verder te kunnen krimpen.\nDan doen we met onderstaande code:\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  }  } }    Opdracht 20 In deze stap programmeren we dat we op doelwitten kunnen klikken, om deze te verwijderen. Dat doen we als volgt. De functie mouseClicked() activeert wanneer je klikt. Plaats deze functie helemaal onderaan in het bestand. Probeer elke regel te begrijpen en vraag om hulp als er iets onduidelijk is!\n16 17 18 19 20 21 22 23 24 25 26 27 28 29  function mouseClicked() { for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Bereken de afstand tussen de muis en het doelwit \tlet afstand = dist(mouseX, mouseY, t.x, t.y); if(afstand \u0026lt; t.d/2) { //Als de afstand kleiner is dan de halve diameter (radius) van het doelwit is het raak  doelwitten.splice(i, 1); //Verwijder het doelwit dat geraakt is  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  return; } } }    Opdracht 21 Wat nu? De speler kan nog niet verliezen. We voegen toe dat de speler een leven verliest als een doelwit verdwijnt waar hij niet op klikt.\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  levens--;  } } }    Opdracht 22 Als laatste: we laten de speler weten wanneer hij verloren heeft, via de volgende code:\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); if(spelerIsDood) { textSize(52); text(\u0026#34;Dood!\u0026#34;, 130, 170, 100, 100); textSize(32); return; }  for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  levens--; } } if(levens \u0026lt;= 0) { spelerIsDood = true; } }    Afronden Als het goed is heb je nu een spel gemaakt. Werkt het niet? Je kan jouw code vergelijken met de uitwerking hieronder.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); //voeg begin doelwitten toe  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); if(spelerIsDood) { textSize(52); text(\u0026#34;Dood!\u0026#34;, 130, 170, 100, 100); textSize(32); return; } for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  levens--; } } if(levens \u0026lt;= 0) { spelerIsDood = true; } } function mouseClicked() { for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Bereken de afstand tussen de muis en het doelwit \tlet afstand = dist(mouseX, mouseY, t.x, t.y); if(afstand \u0026lt; t.d/2) { //Als de afstand kleiner is dan de halve diameter (radius) van het doelwit is het raak  doelwitten.splice(i, 1); //Verwijder het doelwit dat geraakt is  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  return; } } }    Verbeter het spel We hebben zojuist een spel gemaakt. Kan jij het spel verbeteren? Probeer de volgende ideeën toe te voegen:\n Geef de doelwitten mooie kleuren. Kan jij de kleur mee laten veranderen met de grootte van de doelwitten? Voeg tekst toe die de huidige score laat zien. Zo kan je aan andere Ninja\u0026rsquo;s laten zien wat je record is. Vind je het spel te makkelijk of te moeilijk? Pas de hoeveelheid doelwitten of de krimpsnelheid aan!  Tot slot De instructie geeft je slechts een introductie van wat er mogelijk is met de p5.js bibliotheek. Naast tekenen kun je ook met geluid werken, of met foto\u0026rsquo;s en filmpjes.\nZie https://p5js.org/examples/ voor een overzicht van voorbeelden.\nEen aantal voorbeelden die we zelf leuk vinden:\n https://p5js.org/examples/math-parametric-equations.html https://p5js.org/examples/math-graphing-2d-equations.html https://p5js.org/examples/math-distance-2d.html https://p5js.org/examples/sound-playback-rate.html (zet je luidsprekers aan!) https://p5js.org/examples/sound-oscillator-frequency.html (zet je luidsprekers aan!)  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 22, 2021","permalink":"/instructies/p5.js-art/","title":"P5.js - Art"},{"categories":null,"contents":"We gaan kunst maken met Python Turtle.\nIntroductie We gebruiken voor deze instructies Thonny, een eenvoudige editor voor Python scripts.\nJe kunt deze hier downloaden en vervolgens installeren.\nIn Thonny kun je op twee manieren code uitvoeren.\n Door de code die je hebt geschreven - je script - uit te voeren in de editor, dit is het bovenste deel van Thonny. Uitvoeren van je script doe je door op de groene startknop te klikken of de F5-toets in te drukken. De eerste keer dat je dit doet vraagt Thonny je om het script op de computer op te slaan. In de shell, het onderste deel van Thonny. Hier kun je je code regel voor regel uitproberen door na het typen van een regel op Enter te drukken. Tip: regels code die je eerder in de shell hebt getypt kun je opnieuw gebruiken door pijltje omhoog te gebruiken.  Mocht je nog geen ervaring hebben met Thonny en Turtle, kijk dan ook eens naar onze Python Turtle instructies.\nJe kunt ook kunst maken met Scratch. Kijk daarvoor naar de Scratch Art instructies.\nIn deze instructie behandelen we kunst met lijnen, cirkels, polygonen (zoals een driehoek en vierkant) en een lissajous.\nLijnen We beginnen eenvoudig met het tekenen van een enkele lijn:\n1 2 3 4 5  from turtle import * forward(100)  done()   Op regel 1 wordt Turtle geladen. Deze regel is nodig om de Turtle commando\u0026rsquo;s te kunnen gebruiken.\nOp de 3e regel wordt met Turtle commando forward een lijn getrokken met lengte 100.\nTenslotte zorgt done op regel 5 er voor dat het scherm waarop getekend is, open blijft.\nOpdracht 1: Verander de lengte eens en kijk wat er gebeurt.\nOpdracht 2: Maak de lengte eens negatief. Waar gaat de lijn heen?\nPolygonen Een andere naam voor een polygoon is een veelhoek. Voorbeelden van eenvoudige veelhoeken zijn een driehoek, vierkant en vijfhoek.\nEen driehoek tekenen Met drie lijnen kun je een driehoek tekenen. Dit kan er als volgt uitzien:\n1 2 3 4 5 6 7 8 9 10  from turtle import * forward(100) right(120) forward(100) right(120) forward(100) right(120)  done()   Het commando right op regels 4, 6 en 8 zorgt ervoor dat de pen naar rechts draait en wel met 120 graden.\nOpdracht 3: Voer regels 3 tot en met 8 eens stap voor stap uit en zie wat elke stap doet.\nTekenen met herhalingen In het vorige voorbeeld zag je 3 keer een herhaling van een forward en right commando. Dit kun je ook met een herhaling beschrijven in Python:\n1 2 3 4 5 6 7  from turtle import * for i in range(3): forward(100) right(120)  done()   Op regel 3 zorgt commando for i in range(3) ervoor dat regels 4 en 5 driemaal herhaald worden.\nOpdracht 4: Verander de range (het getal 3) eens naar 1, 2, 3 of 4? Wat gebeurt er?\nOpdracht 5: Maak de hoek (het getal 120) eens groter of kleiner en kijk wat er gebeurt.\nTekenen met een functie Je hebt over herhalingen geleerd. Je kunt herhalingen nog makkelijker maken door een functie te gebruiken.\nEen functie is een stukje code met een naam. Door die naam kun je de functie overal in je code gebruiken. Verder kun je getallen meegeven om het gedrag van de functie aan te passen.\nHier een voorbeeld van de code voor de functie vorm:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from turtle import * def vorm(x, y, rib, hoeken, rotatie=0): goto(x, y) right(rotatie) pendown() for _ in range(hoeken): forward(rib) right(180 - ((hoeken - 2) * 180 / hoeken)) penup() right(-rotatie)  vorm(0, 0, 100, 4, 45) vorm(30, 300, 80, 5, 60)  done()   Je hoeft niet te weten hoe een functie precies werkt, maar wel hoe je deze moet gebruiken.\nFunctie vorm heeft de volgende parameters:\n x: de horizontale plek in het plaatje. 0 is in het midden. - getallen zijn naar links en + getallen naar rechts. y: de verticale plek in het plaatje. 0 is in het midden. - getallen zijn naar beneden en + getallen naar boven. rib: een vierkant bestaat uit vier lijnen. Deze lijnen heten ribben. Parameter rib is een getal groter dan 0 dat bepaalt hoe lang elke zijde van de veelhoek is. hoeken: een driehoek heeft 3 hoeken (duh!). Met parameter hoeken kun je aangeven hoeveel hoeken de veelhoek moet hebben. rotatie: meestal wordt een vierkant recht getekend dus de bovenste en onderste rib horizontaal en de linker- en rechterrib verticaal. Met de parameter rotatie kun je het vierkant (of andere veelhoek) kantelen.  Op regels 15 en 16 staan voorbeelden van het gebruik van de functie vorm. De eerste is een vierkant midden in het plaatje. Het tweede een gekantelde vijfhoek boven in het plaatje.\nOpdracht 6: Maak eens een achthoek met een rib van 120.\nOpdracht 7: Herhaal de aanroep van de vorm functie eens een paar keer met iedere keer andere waarden.\nJe kunt de polygonen ook inkleuren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  from turtle import * def vorm(x, y, rib, hoeken, rotatie=0): goto(x, y) right(rotatie) pendown() for _ in range(hoeken): forward(rib) right(180 - ((hoeken - 2) * 180 / hoeken)) penup() right(-rotatie) vorm(0, 0, 120, 8, 45) fillcolor(\u0026#34;red\u0026#34;) begin_fill() vorm(-19, -46, 80, 8, 45) end_fill() goto(-120, -175) color(\u0026#34;white\u0026#34;) write(\u0026#34;STOP\u0026#34;, font=(\u0026#39;Arial\u0026#39;, 36, \u0026#39;bold\u0026#39;)) hideturtle() done()   Voor het inkleuren van de figuur gaat het eigenlijk alleen maar om regels 17, 18 en 20.\nMet fillcolor kies je de kleur. Na begin_fill wordt een volgend figuur dat getekend wordt ingekleurd. Om te voorkomen dat een daarop volgend figuur ook wordt ingekleurd, gebruik je end_fill.\nOpdracht 8: Neem de code over en voer deze uit. Er zit een verrassing in! 😉\nCirkels Naast rechte lijnen, kun je met Turtle ook cirkels tekenen. Daarvoor is het commando circle:\n1 2 3 4 5  from turtle import * circle(100)  done()   Het getal 100 op lijn 3 staat voor de diameter van de cirkel.\nOpdracht 9: Maak de cirkel eens groter.\nAls je cirkels combineert met herhalingen en rotaties, dan kun je mooie figuren als deze maken:\nDe code die hierbij hoort, is:\n1 2 3 4 5 6 7  from turtle import * for i in range(12): circle(100) right(30)  done()   Door met het aantal (getal 12) en de hoek tussen de cirkels (getal 30) te spelen, kun je het figuur er anders uit laten zien.\nOpdracht 10: Als je de hoek kleiner maakt, bijvoorbeeld 20, heb je dan genoeg cirkels om het figuur helemaal rond te maken? Welk getal moet je aanpassen om het figuur weer compleet te krijgen? Moet dit groter of kleiner worden?\nDoor met kleuren te spelen, wordt de figuur nog mooier:\n1 2 3 4 5 6 7 8 9 10 11  from turtle import * kleuren = [\u0026#34;red\u0026#34;, \u0026#34;cyan\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;blue\u0026#34;] bgcolor(\u0026#34;black\u0026#34;)  for i in range(12): color(kleuren[i % 7])  circle(100) right(30) done()   Op regel 3 worden de kleuren die we willen gebruiken in een lijstje gezet. Je kunt niet zomaar elke kleur gebruiken en Python snapt geen Nederlands. Voor een overzicht van de kleuren die mogelijk zijn, kun je even kijken naar onze Python Turtle instructies.\nOp regel 4 maken we de achtergrond zwart. Hierdoor komen de kleuren in het lijstje beter uit.\nOp regel 7 wordt een kleur gekozen uit het lijstje en geactiveerd.\nOpdracht 11: Neem de code over en kies eens wat andere kleuren. Je kunt ook het lijstje korter of langer maken, maar dan moet het getal 7 op regel 7 aangepast worden, zodat het gelijk is aan het aantal kleuren in de lijst.\nLissajous Met lijnen, polygonen en cirkels kun je al mooie plaatjes maken. Met een Lissajous wordt het nóg interessanter.\nMet een wiskundige formule worden twee golven gecombineerd:\nSinus Allereerst tekenen we een sinus-golf:\nDat doe je met deze code:\n1 2 3 4 5 6 7 8 9 10  from turtle import * from math import sin  penup() goto(-400, 0) pendown() for i in range(-400, 400): goto(i, 100 * sin((i + 400) / 50))  done()   Let op: zorg dat je regel 2 overneemt, anders wordt het sinus commando niet herkend.\nHet commando sin zorgt hier voor de golfvorm. Afhankelijk van het getal dat je als parameter mee geeft, gaat de golf sneller of langzamer.\nOpdracht 12: Vervang getal 50 op regel 8 eens door een groter of kleiner getal. Wat gebeurt er?\nOpdracht 13: Vervang getal 100 op regel 8 eens door een groter of kleiner getal. Wat gebeurt er?\nLissajous Als we twee sinussen in één formule combineren, dan kun je een Lissajous tekenen. Kijk eens naar de volgende code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from turtle import * from math import sin a = 4 b = 3 x = 0 y = 0 s = 300  for i in range(1000): goto(s * sin(x/150), s * sin(y/150)) x += a y += b  done()   Op regel 11 zie je de combinatie van twee sinussen in het goto commando. Met dit commando verschuif je de pen over het plaatje. Met de eerste parameter horizontaal en met de tweede verticaal. Door voor beiden een sinus te gebruiken, schuift de pen zowel horizontaal en verticaal.\nOpdracht 14: Neem de code over en voer het uit. Zie je hetzelfde plaatje als hierboven?\nOpdracht 15: Maak de waarde voor s (regel 8) eens kleiner? Wat gebeurt er? En als je het groter maakt?\nOpdracht 16: Variabelen a en b bepalen de vorm van de Lissajous. Probeer eens andere waarden, zoals bijvoorbeeld a = 18 en b = 19. Hoe ziet dat er uit? En als a en b 4 zijn? Of 1 en 2?\nTot slot Zoals je ziet kun je met Python Turtle leuke kunststukjes maken. Gebruik je fantasie, maar vooral: durf te proberen met allerlei getallen en kleuren. Wie weet wat je kunt maken?\nTer voorbereiding van deze instructie hebben we zelf ook wat kunst gemaakt. Probeer ze eens uit:\n art-1.py gekleurde lijnen\n art-2.py gekleurde lijnen\n art-3.py gekleurde lijnen\n art-4.py gekleurde cirkels\n art-5.py gekleurde veelhoeken\n art-6.py gekleurde en gedraaide vierkanten\n art-7.py lissajous\n art-8.py willekeurige gekleurde vijf- en zevenhoeken\n art-9.py willekeurig gekleurde gedraaide negenhoeken\n  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 18, 2021","permalink":"/instructies/python-art/","title":"Python - Art"},{"categories":null,"contents":"We gaan kunst maken met Scratch.\nIntroductie Naast een leuke achtergrond en het bewegen van de kat van Scratch kun je nog veel meer doen. Je kunt Scratch ook laten tekenen.\nHier zie je een paar voorbeelden van wat je met Scratch kunt:\n                  Deze instructie leert je stap-voor-stap vergelijkbare tekeningen te maken.\nBenodigdheden Om de instructie te volgen, heb je naast je computer niets nodig.\nGa naar https://scratch.mit.edu/projects/editor/ om aan de stappen te beginnen.\nDeze instructies gaan er vanuit dat je de pen uitbreiding gebruikt. Deze moet je eerst activeren:\n Open het overzicht met uitbreidingen:  Kies uit het overzicht de pen uitbreiding  Er zijn nu groene pen blokken beschikbaar die verder in de instructies worden gebruikt   Stappen Polygonen Een polygoon is een ander woord voor een veelhoek. Een veelhoek is een vorm in een plat vlak met een aantal hoeken. Een veelhoek met 3 hoeken is een driehoek. Maar ook een achthoek is een veelhoek. In dit hoofdstuk gaan we veelhoeken tekenen.\nDriehoek Een driehoek is een eenvoudige veelhoek. Het bestaat uit 3 hoeken en 3 lijnen. Je kunt deze makkelijk teken met Scratch:\nVoor elke hoek doe je twee dingen:\n neem 100 stappen om een lijn te tekenen draai de pen 120°  En dat herhaal je dan 3 keer.\nOpdracht 1: Maak het voorbeeld eens na en experimenteer eens met het aantal stappen of de hoeken.\nVierhoek De vierhoek is nog een eenvoudige veelhoek. Het bestaat uit 4 hoeken en 4 lijnen. Ook deze kun je makkelijk teken met Scratch:\nVoor elke hoek doe je twee dingen:\n neem 100 stappen om een lijn te tekenen draai de pen 90°  En dat herhaal je dan 4 keer.\nOpdracht 2: Neem je code van de driehoek en pas het aan zodat het een vierkant kan maken.\nOpdracht 3: Neem je code van de vierhoek en probeer er eens een vijfhoek van te maken. Wat moet er veranderen?\nMisschien valt het je op, dat de stappen voor de driehoek, vierhoek en vijfhoek erg vergelijkbaar zijn. Het aantal herhalingen is gelijk aan het aantal hoeken en de hoek van de te maken draai wordt wordt steeds groter.\nPolygoon functie Bij de vierhoek en vijfhoek zagen we al dat het tekenen ervan vooral bestaat uit herhaling van stappen. Ook is er eigenlijk maar één getalletje dat veranderd; het aantal hoeken.\nOm verschillende polygonen te tekenen, is het dus handig om één blokje te hebben waarbij je het aantal hoeken kunt opgeven.\nLet op: bij deze stap ga je zelf het blok \u0026ldquo;polygoon\u0026rdquo; samenstellen; deze bestaat nog niet. Om dit te doen ga je naar Mijn blokken \u0026gt; maak een blok. Hierdoor beland je op het volgende scherm:\nVerander hier de naam van het blok van bloknaam naar polygoon.\nSelecteer vervolgens Voeg een invoer toe: getal of tekst.\nNoem deze invoer vervolgens aantal hoeken en klik op OK.\nVanaf nu staat \u0026ldquo;polygoon\u0026rdquo; onder Mijn blokken vermeld.\nDaarnaast kan je de variabele \u0026ldquo;aantal hoeken\u0026rdquo; verkrijgen door deze uit het definieer polygoon blok te slepen.\nLinks staat het nieuwe blok dat polygonen tekent. Rechts staat hoe je het nieuwe blok kunt gebruiken.\nOpdracht 4: Maak het voorbeeld na. Wat wordt er getekend?\nOpdracht 5: Experimenteer eens wat met het aantal hoeken, wat gebeurt er als je een groot aantal hoeken (20?) kiest?\nOpdracht 6: Kun je het volgende figuur maken?\nLissajous Een lissajous is een vorm gemaakt met een wiskundige formule. Het is een combinatie van twee golven.\nDe combinatie van twee golven\nSinusgolf Voordat we de Lissajous maken, beginnen we met een enkele sinusgolf:\nHieronder de code die hiervoor gebruikt is. Het belangrijkste blokje is het groene, met daarin variabelen amplitude, frequentie en x. Dit blokje zorgt voor de golfvorm.\nOpdracht 7: Maak het voorbeeld na. Ziet het er hetzelfde uit als in het plaatje?\nOpdracht 8: Probeer eens wat te varieren met de waarden van variabele amplitude en een frequentie. Wat gebeurd er?\nLissajous functie Hieronder staan een paar voorbeelden van een Lissajous. Met twee getallen (a en b) kan je aanpassen hoe een Lissajous eruit ziet.\na = 1, b = 2\na = 3, b = 4\na = 5, b = 4\nDe code om er een te maken ziet er als volgt uit:\n Eerst wordt de pen gereset. Dan wordt de Lissajous functie aangeroepen met drie waardes: maat, a en b. Daarna wordt er elke keer de X- en Y-positie berekend. Hiermee wordt de vorm getekend.  Het groene blokje dat zorgt voor de golfvorm, wordt nu twee keer wordt gebruikt in het blauwe \u0026lsquo;ga naar\u0026rsquo; blok.\nOpdracht 9: Maak het voorbeeld na. Kun je de waarden a en b van de drie voorbeelden gebruiken? Zijn de getekende plaatjes dan hetzelfde als de drie voorbeelden?\nOpdracht 10: Probeer eens rare getallen uit voor maar, a en b en kijk wat er gebeurd.\nOpdracht 11: Maak de lissajous kleurrijk, zoals als opdracht 6.\nConclusie Je hebt nu een indruk gekregen van hoe je met Scratch kunt tekenen. Eerst door veelhoeken of polygonen te tekenen en te herhalen en vervolgens door een Lissajous te maken.\nVervolg Heb je de smaak te pakken gekregen van het maken van kunst met Scratch? Kijk dan ook naar deze links:\n Scratch art voorbeelden: https://scratch.mit.edu/search/projects?q=art Scratch kunst voorbeelden: https://scratch.mit.edu/search/projects?q=kunst  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 13, 2021","permalink":"/instructies/scratch-art/","title":"Scratch - Art"},{"categories":null,"contents":"Alles wat je moet weten om gave dingen te maken\nWat is de Arduino? De Arduino is een microcontroller, wat betekent dat het een heel simpele computer is. Je kunt er sensoren op aansluiten om van alles waar te nemen in de omgeving, en er ook allerlei soorten ‘outputs’ mee aansturen zoals motoren en lampen.\nEr bestaan verschillende soorten Arduino’s en veel vergelijkbare microcontrollers, maar de Arduino Uno die je hierboven ziet is het bekendst. Op de Arduino zie je nummers en markeringen staan die aangeven wat je erop kunt aansluiten. ‘3.3V’ en ‘5V’ zijn de pinnen waar je stroom met die voltages uit kunt halen. Je zou ze kunnen zien als de plus van een batterij. De min van het Arduinobordje vind je bij ‘GND’.\nVerder zie je 14 digitale pins en 6 analoge pins, die we allemaal kunnen gebruiken als inputs én als outputs.\nDe software installeren We hebben de Arduino-software nodig om het Arduino-bordje te kunnen programmeren. Om de software te downloaden ga je naar arduino.cc/download.\nKies je besturingssysteem (Windows, Linux of Mac) in het dondergroene vlak met de titel ‘Download options’. (Heb je Windows? Kies dan de bovenste optie.) In het volgende scherm kun je klikken op ‘Just download’. Als het bestand gedownload is, kun je het Arduino-programma installeren en openen.\nJe eerste Arduino-programma De stukjes software die we maken voor de Arduino noemen we schetsen (in het Engels ‘sketches’) of gewoon programma’s. Schetsen zijn tekstbestandjes waar instructies voor het Arduino-bordje in staan. Programmeurs noemen zulke instructies ook wel ‘code’. Je gaat nu je eerste Arduino-programma maken door een bestaand voorbeeld te openen en aan te passen.\nOpen het menu Bestand, dan Voorbeelden, Basics en klik dan op Blink. De schets dat zich nu opent in een nieuw venster gaan we uploaden naar de Arduino.\nSluit het Arduino-bordje aan op je computer met een USB-kabel.\nKlik op het tweede icoontje van links:\nHet Arduino-programma zal de schets nu op de chip van de Arduino gaan zetten.\nMogelijk krijg je de eerste keer een venster te zien waarin je moet aangeven waar de computer de Arduino kan vinden. Kies daar voor een adres met ‘usb’, ‘serial’ of ‘COM’ erin, en niet voor ‘bluetooth’.\nAls je linksonder in het scherm ‘Uploaden voltooid’ ziet, dan is het gelukt en is er nu op de Arduino een LED-lampje aan het knipperen!\nAls je een foutmelding krijgt, bekijk dan de pagina ‘Problemen oplossen’ achteraan deze handleiding.\nOefening  Kun je het LED-lampje sneller laten knipperen?\nLet op: als je iets in de schets verandert, moet je hem opnieuw uploaden. Kun je de LED in verschillende patronen laten knipperen?\nKun je bijvoorbeeld SOS knipperen?  Hoe zit een Arduino-programma in elkaar? Belangrijk om door te hebben: bijna alle Arduino-schetsen hebben drie onderdelen.\nIn het eerste deel, helemaal bovenaan in de schets, worden vaak wat variabelen klaargezet. (Hoe variabelen werken kun je verderop in deze handleiding lezen.)\nIn het geval van Blink staat daar alleen wat commentaar. Alle regels met twee schuine strepen ervoor zijn toelichting. Zulke regels staan er om aan jou uit te leggen hoe het programma werkt. Alle regels tussen /* en */ zijn ook commentaar. (Je herkent commentaar ook aan de grijze kleur van de tekst.)\nHet tweede deel is een functie die ‘setup’ heet. Alles wat daarin staat, wordt één keer uitgevoerd.\nvoid setup() { // alles wat tussen de accolades (de gekrulde haakjes) staat, hoort bij  // setup en wordt in één keer uitgevoerd.  // In Blink wordt bijvoorbeeld het ingebouwde LED-lampje op  // het Arduino-bord aangemeld als output:  pinMode(LED_BUILTIN, OUTPUT); } Het derde deel van de schets is de functie die ‘loop’ heet. Dit deel van het programma wordt steeds weer opnieuw gedaan, voor altijd.\nvoid loop() { digitalWrite(LED_BUILTIN, HIGH); // zet de LED aan (HIGH is het voltage niveau)  delay(1000); // wacht een seconde  digitalWrite(LED_BUILTIN, LOW); // zet de LED uit (bij LOW is de spanning uit)  delay(1000); // wacht een seconde } De ingebouwde LED is op de Arduino Uno aangesloten op pin 13. ‘LED_BUILTIN’ is een woord dat 2 Arduino herkent, maar je zou in plaats daarvan ook ‘13’ kunnen schrijven.  In Blink bijvoorbeeld wordt in loop() het ingebouwde LED-lampje aangezet 2 (‘HIGH’), dan wordt er een seconde gewacht (duizend milliseconden), dan wordt de LED weer uitgezet (‘LOW’), dan wordt er weer een seconde gewacht, en dan begint loop() weer opnieuw.\nHoe een breadboard werkt Om sensors en andere componenten te verbinden met de Arduino (of met elkaar), is het vaak handig om een breadboard te gebruiken.\nDe gaatjes op het breadboard zijn binnenin het plastic bordje met metalen strips met elkaar verbonden. De gaatjes in het midden zijn verbonden in kolommen van vijf (zoals die in het groene kader hiernaast).\nDe letters en cijfers op het breadboard gebruiken we meestal niet. Die vijf gaatjes zijn alleen met elkaar verbonden, dus niet met gaatjes ernaast of met gaatjes aan de overkant van de kloof in het midden.\nDe horizontale rijen bovenaan en onderaan, met de rode en blauwe lijnen ernaast, gebruiken we om meerdere onderdelen van stroom te voorzien. Rood is plus en blauw (of zwart) is min, net zoals batterijen een plus en een min hebben. Die gaatjes zijn alleen verbonden met de andere gaatjes in dezelfde horizontale rij, dus niet niet met de gaatjes erboven of eronder.\nHet is daarom verstandig om je altijd aan de juiste kleuren te houden: de rode rij op het breadboard voor plus en de blauwe rij voor min. Gebruik ook zoveel mogelijk rode draadjes om componenten met de positieve kant te verbinden, en zwarte of blauwe draadjes voor de verbinding met de negatieve kant.\nDigitale sensors: een knop Een Arduino programmeren om lampjes te laten knipperen is leuk, maar eigenlijk willen we dat hij ook kan reageren op zijn omgeving. Laten we dat nu proberen.\nVerbind eerst een drukknop met de Arduino zoals op de tekening:\n Zet de knop op het breadboard met twee pootjes aan elke kant van de gleuf in het midden (als het zo dadelijk niet werkt, moet je de knop misschien een kwartslag draaien). Verbind één kant van de knop met één van de gaatjes van de Arduino waar GND naast staat. De andere kant van de knop verbind je met het gaatje waar ‘2’ bij staat (niet ‘A2’).  Open nu de schets die bij deze schakeling hoort, via het menu Bestand \u0026gt; Voorbeelden \u0026gt; Digital \u0026gt; DigitalInputPullup.\nUpload de schets naar de Arduino.\nProbeer de knop maar. Als het goed is, heb je nu je eerste werkende digitale sensor! Als je op de knop drukt, gaat de LED aan. Dit is dus al meteen een combinatie van input en output.\nHoe werkt het? In het programma zie je dat in de functie setup() pin nummer 2 als een ingang wordt ‘opengezet’:\npinMode(2, INPUT_PULLUP); Op die pin heb je de knop aangesloten, en dankzij deze regel in de schets weet de Arduino dat ook.\nVervolgens wordt pin nummer 13 als een uitgang gedefiniëerd:\npinMode(13, OUTPUT); De ingebouwde LED op de Arduino is verbonden met pin 13, en dankzij deze regel weet de Arduino dat we die willen gaan gebruiken.\nNu gaan we in de gaten houden of de knop wordt ingedrukt. Dat doen we met de functie digitalRead():\nint sensorVal = digitalRead(2); Als je op de knopt drukt die is verbonden met pin 2 van de Arduino, levert digitalRead hier een 0 op. Als je de knop loslaat, wordt dat een 1. Die waarde wordt vervolgens bewaard in een variabele die ‘sensorVal’ heet (meer uitleg over variabelen lees je verderop).\nDaarom is een knop een voorbeeld van een digitale sensor: er zijn maar twee mogelijkheden. Andere voorbeelden van digitale sensoren zijn bewegingsensors (zoals PIR-sensors die automatisch het licht aandoen in WC’s) en ‘oogjes’ zoals bovenaan roltrappen. Dit alles staat in de functie loop(), wat betekent dat digitalRead() steeds opnieuw wordt uitgevoerd en de knop dus continu in de gaten wordt gehouden. ‘sensorVal’ bevat steeds de huidige stand van de knop, 1 of 0, aan of uit.\nOm iets te doen met de informatie die de sensor doorgeeft, staat in de schets vervolgens een if-statement. Hoe dat werkt, lees je hierna\nIf-statements Om de Arduino iets te laten doen als er iets verandert, moeten we hem leren om vragen te stellen. Een vraag in Arduino ziet er zo uit:\nif (sensorWaarde \u0026gt; 30) { // doe hier iets } Dit heet een if-statement. Je laat Arduino vragen: is de knop ingedrukt? Of, zoals in het voorbeeld hierboven: is het getal dat de sensor teruggeeft groter dan 30? Als het antwoord op zo’n vraag ‘ja’ is, dan voert Arduino de code uit die tussen de gekrulde haken staat.\nIn de DigitalInputPullup-schets van zojuist ziet dat er zo uit:\nif (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } Door hoe we de knop hebben aangesloten, betekent ‘HIGH’ in dit geval dat de knop niet wordt ingedrukt. Hier wordt eerst gevraagd: wordt de knop ingedrukt? Als dat niet zo is, dan zetten we het LEDje uit, en anders zetten we het aan. Dit is dus een uitbreiding op het if-statement: met ‘else’ kunnen we instructies toevoegen voor het geval het antwoord op de vraag ‘nee’ is.\nInterpunctie Merk op dat elke haakje openen een haakje sluiten nodig heeft, dus ‘(’ en ‘)’, en ‘{’ en ‘}’. Elk commando zoals digitalWrite() moet eindigen op een puntkomma. Programmeertalen zijn heel gevoelig op dit soort dingen en zullen niet meewerken als je dit soort dingen verkeerd doet. Als je toch foutmeldingen krijgt, kijk dan naar de paragraaf ‘Problemen met de code’ aan het eind van deze handleiding.\nOefening Nu gaat de LED aan als je de knop indrukt. Kun je de code zo aanpassen dat de LED juist uitgaat als je de knop indrukt?\nZien wat er gebeurt: de seriële monitor Stel je voor dat er iets misgaat, bijvoorbeeld dat er níet een LEDje gaat branden als je op de knop drukt. Dan zou het handig zijn als de Arduino zelf kon vertellen of hij ten minste ziet dat de knop wordt ingedrukt, want dat zou ons helpen te ontdekken wat het probleem is. Gelukkig kan de Arduino dat.\nWe kunnen een communicatieverbinding opzetten tussen de computer en het Arduino-bordje. Dat doen we door deze regel in setup() te zetten (in de DigitalInputPullup-schets staat dit er al):\nSerial.begin(9600); In loop() zetten we direct onder de regel waar we de sensor uitlezen deze regels:\nSerial.print(\u0026#34;sensor = \u0026#34;); Serial.println(sensorValue); Open vervolgens de seriële monitor door te klikken op het vergrootglasicoontje rechtsbovenaan in het venster.\nAls de schets van de knop (DigitalInputPullup) nog steeds op de chip van de Arduino staat, dan zou je nu in de seriële monitor moeten kunnen zien of de knop wordt ingedrukt. Als je niks ziet veranderen, dan weet je dus dat de knop het niet doet of niet goed is verbonden met pin 2.\nDe seriële verbinding is vaak enorm handig om te kijken of Arduino doet wat wij in gedachte hadden, en zo niet, waar het probleem dan zit.\nWe kunnen de verbinding ook gebruiken om sensordata uit de Arduino te gebruiken in andere software op de computer, bijvoorbeeld om interactieve animaties of muziek te maken.\nDie 9600 is de baud rate, de snelheid waarmee de computer en de Arduino met elkaar praten. Sommige schetsen gebruiken andere waardes zoals 115200. De baud rate in de seriële monitor moet overeen komen met die in de schets, anders zie je rare tekens of gewoon niets.  Analoge sensors De knop die we tot nu toe gebruikt hebben, is een soort digitale sensor. Zulke sensoren kennen alleen 1 en 0, oftewel aan en uit, LOW en HIGH.\nEr zijn ook een heleboel analoge sensoren, die tussenwaardes kunnen geven. Een voorbeeld daarvan is een lichtsensor, die kan laten weten of het donker is of juist heel erg licht, maar die ook alle gradaties ertussenin kan meten.\nEen ander voorbeeld van een analoge sensor is de potmeter of potentiometer. Dat is een draaiknop die je het beste kent als volumeknop op versterkers. In Arduino kun je heel precies de positie zien van de draaiknop.\nSluit de potmeter aan zoals op de afbeelding: de middelste pin op de analoge poort A0, en de buitenste pinnen op 5V en GND.\nOpen vervolgens dit programma: Bestand \u0026gt; Voorbeelden \u0026gt; 03. Analog \u0026gt; AnalogInput.\nUpload de schets naar de Arduino. Als het goed is kun je nu de LED sneller en langzamer laten knipperen door aan de knop te draaien!\nOok leuk: probeer de waardes die van de potmeter komen te bekijken met de seriële plotter. Hoe dat moet, wordt onthuld op de volgende pagina.\nOefening Sluit een kleine speaker of ‘buzzer’ aan op GND en pin 13 (via het breadboard). Dat is dus op dezelfde pin als de interne LED van de Arduino. Hoor je een verschil als je aan de knop draait?\nSeriële plotter Om analoge waarden goed te kunnen laten zien, heeft de Arduino-software een geweldige feature in huis.\nOpen het menu Hulpmiddelen en klik op Seriële plotter (sluit eerst de seriële monitor als dat venster nog openstaat). De sneltoets-combinatie voor de seriële plotter is shift+command+L.\nOpen de schets AnalogReadSerial via het menu Bestand \u0026gt; Voorbeelden \u0026gt; 01. Basics \u0026gt; AnalogReadSerial, en upload het naar de Arduino.\nJe zou in het venster van de seriële plotter nu een grafiek moeten zien van de veranderingen in de positie van de potmeter! (Of de resultaten van een andere analoge sensor, zoals bijvoorbeeld de lichtsensor.)\nMeerdere sensoren Als je de resultaten van meerdere sensoren in de seriële plotter wil zien, dan moet je zorgen dat die waardes gescheiden door tabs worden doorgestuurd:\nSerial.print(sensor1); // waarde van de eerste sensor Serial.print(\u0026#34;,\\t\u0026#34;); // waardes gescheiden door komma en tab Serial.print(sensor2); // waarde van de tweede sensor Serial.println(); // witregel Het helpt om verder geen print()’s in je programma te hebben die tekst schrijven naar de seriele verbinding (zoals je soms wel doet om feedback van je schets te zien in de seriële monitor). Als je zulke print()’s met tekst wel hebt in je schets, misschien moet je ze dan even tijdelijk uitschakelen door er met // commentaar van te maken.\nUltrasone afstandssensor Als je wil weten hoe ver iets of iemand is (bij je robot of kunstwerk vandaan bijvoorbeeld), dan is een ultrasone afstandssensor geweldig. Er zitten twee ronde dingen op, een speaker en een microfoon. De sensor werkt door met de speaker een ultrasoon geluid te maken, en vervolgens met de microfoon te meten hoe lang het duurt voordat de echo van dat geluid terugkomt. Door die tijd te delen door snelheid van het geluid, kan de Arduino uitrekenen hoe ver weg iets is.\n343 meter per seconde; de gevonden tijd wordt ook nog door 2 gedeeld, omdat het geluid twee keer de 6 afstand heeft afgelegd als de echo wordt opgevangen.\nJe sluit de sensor zo aan op de Arduino, eventueel via een breadboard:\n de pin op de sensor waar VCC bij staat naar 5V op de Arduino, GND op de sensor naar GND op de Arduino, Trigger naar digitale pin 12 van de Arduino, Echo naar pin 11 van de Arduino.  Je kunt code voor dit type sensor overal online vinden, maar de NewPing-library is erg makkelijk te gebruiken. Die moet je dan wel even installeren—als je nog niet weet hoe dat moet, kijk dan even op de pagina ‘Libraries installeren’ verderop.\nIn het voorbeeldprogramma NewPingExample (zie Bestand \u0026gt; Voorbeelden \u0026gt; NewPing) kun je zelf de maximale afstand instellen die je wil meten. Een meter of vier à vijf is wel het maximaal haalbare met deze sensor.\nMeer informatie over de NewPing-library vind je hier: https://bitbucket.org/teckel12/arduino-new-ping\nUpload de code naar de Arduino, en open de seriële monitor om de afstand te zien die de sensor meet.\nUltrasone afstandssensors meten de afstand tot objecten in een smalle strook van 15 graden. Als je een breder gebied wil scannen, dan zou je meerdere ultrasone sensors naast elkaar kunnen zetten, of een enkele sensor op een motortje kunnen zetten om een draaiende radar te maken. Een meer complete oplossing is beeldherkenning, maar dat is ook een stuk ingewikkelder. Als je alleen maar wil weten óf iemand in de buurt is (en niet per se hoe ver weg ze zijn), gebruik dan een PIR-sensor.  Variabelen Variabelen zijn woorden of letters waarmee we Arduino iets kunnen laten onthouden. Dat is belangrijk als we Arduino bijvoorbeeld willen laten bijhouden hoe vaak iets is gebeurd.\nEen variabele definiëren ziet er zo uit:\nint aantal = 100; Door ‘int’ ervoor te zetten zeggen we: de variabele is een heel getal, dus geen decimaal. Dan geven we de variabele zijn naam. In dit geval is dat ‘aantal’, maar het zou net zo goed ‘x’ mogen zijn, of ‘sensorWaarde’. Meestal kiezen we een naam die goed duidelijk maakt wat voor informatie we willen opslaan in die variabele. Vervolgens vertellen we de variabele wat zijn beginwaarde wordt—in dit geval 100. Tot slot wordt de regel afgesloten met een puntkomma, net als alle commando\u0026rsquo;s in Arduino.\nAndere typen variabelen zijn bijvoorbeeld float (dat is wel een decimaal getal) en bool (alleen ‘true’ of 8 ‘false’). Je vindt alle typen op https://www.arduino.cc/reference/en/ onder ‘Data Types’.\nAls je een variabele eenmaal op die manier gedefiniëerd hebt, dan kun je met die variabele gaan rekenen. Als we dit doen…\naantal = aantal + 100; … dan heeft ‘aantal’ nu een waarde van 200.\nOefening Met variabelen kun je bijvoorbeeld ook bijhouden hoe vaak een knop is ingedrukt. Je kunt daarvoor de schets DigitalInputPullup gebruiken (zie eventueel de pagina over digitale sensors). Probeer het eerst zelf, en lees eventueel daarna de oplossing.\n mogelijke oplossing Voeg een variabele toe bovenaan in de schets (dus nog boven setup()). Tel vervolgens steeds 1 bij op, op 9 de plek waar de schets iets doet op het moment dat de knop wordt ingedrukt. Verplaats de Serial.println naar diezelfde plek om in plaats van ‘sensorVal’ de waarde van jouw variabele naar de seriële monitor te schrijven. Als je onder die regel ook nog ‘delay(500);’ toevoegt, dan wacht de Arduino een halve seconde voordat hij verdergaat. Op die manier telt hij steeds maar één druk op de knip in plaats van dat hij doortelt zolang als de knop is ingedrukt :-)  Inputs en outputs combineren Vaak willen we met de Arduino meerdere inputs en outputs tegelijk gebruiken én ze laten samenwerken. Je kunt bijvoorbeeld een potentiometer gebruiken om de snelheid van een motor te veranderen, of een lichtsensor gebruiken om de toonhoogte van een buzzer te verhogen of te verlagen. Hier lees je hoe dat moet.\nStap 1 Als je twee componenten met elkaar wil laten samenwerken, laat ze dan altijd eerst apart werken. Als er dan later iets niet werkt, weet je dat het in ieder geval niet ligt aan de individuele componenten en dat maakt het zoeken naar een oplossing veel makkelijker. Dus bijvoorbeeld:\n Sluit de potmeter aan op de Arduino Upload het programma voor de potmeter naar de Arduino, en zorg dat je de waarden van de potmeter te zien krijgt in de seriële monitor. Sluit vervolgens de buzzer aan (laat de potmeter aangesloten!). Zet de software voor de buzzer op de Arduino (laat het venster met de code met de potmeter openstaan), en ga pas verder als je de buzzer hoort.  Stap 2 Nu heb je dus twee werkende programma’s, en die kun je gaan combineren tot één programma. Zet ze naast elkaar, zodat je beide vensters op je beeldscherm hebt.\nDigitalInputPullup void setup() { Serial.begin(9600); pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); } void loop() { int sensorVal = digitalRead(2); if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } } Sweep #include \u0026lt;Servo.h\u0026gt;Servo myservo; void setup() { myservo.attach(9); } void loop() { myservo.write(10); delay(1000); myservo.write(160); delay(1000); } In Arduino-schetsen mogen setup() en loop() maar één keer voorkomen. We kunnen de schetsen dus niet combineren door ze simpelweg de ene onder de andere te plakken.\nKopiëer daarom de inhoud van de ene setup() naar de andere. Let op dat je geen accolades (gekrulde haken) meekopiëert. Let ook goed op dat je geen code boven of onder de accolades van setup() plaatst—de code hoort tussen { en } want anders werkt het niet.\nDoe hetzelfde voor loop() en eventuele regels die nog bóven setup staan.\nVoor de afgebeelde schetsen ziet dat er zo uit:\nGecombineerd #include \u0026lt;Servo.h\u0026gt;Servo myservo; void setup() { Serial.begin(9600); pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); myservo.attach(9); } void loop() { int sensorVal = digitalRead(2); if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } myservo.write(10); delay(1000); myservo.write(160); delay(1000); } Stap 3 Laat je nieuwe schets controleren door Arduino. Gebruik daarvoor het eerste icoontje, links bovenaan. Als je linksonderin ziet ‘Compileren voltooid’ dan heb je het samenvoegen goed gedaan! Als je een foutmelding krijgt, los het probleem dan op. Gebruik eventueel de checklist aan het eind van deze handleiding. Sla je gecombineerde schets op op je computer, via Bestand \u0026gt; ‘Opslaan als…’.\nSoms wil je twee schetsen combineren die allebei dezelfde pin in gebruik hebben. Als je die schetsen samenvoegt, zul je dus voor één van die twee inputs of outputs een andere pin moeten gebruiken en dat onderdeel dan dus ook op die andere pin op de Arduino moeten aansluiten.  Stap 4 Nu heb je een schets die met twee componenten werkt. Als je hem uploadt naar de Arduino, dan zouden dus beide onderdelen het moeten doen.\nMaar je wil natuurlijk dat beide componenten sámenwerken! Het makkelijkste is een if-statement gebruiken (zie de pagina daarover). Een andere mogelijkheid is de sensor-data direct gebruiken voor een output; je zou bijvoorbeeld waardes uit een lichtsensor direct kunnen gebruiken als de graden voor een servo-motor.\nIn Arduino-schetsen wordt vaak gebruik gemaakt van de functie delay(). Dat levert echter nogal eens problemen op als je de Arduino twee of meer dingen tegelijk willen laten doen. De oplossing daarvoor is een timer zetten; hoe dat moet, lees je op de pagina’s verderop over timers en millis().  Bestaande code gebruiken Wat je óók kunt doen, is code van anderen gebruiken. Stel dat je een kleurensensor wil gebruiken samen met een paar LED-lampjes, dan kun je bij Google iets intypen als ‘Arduino kleurensensor LEDs’. Je vindt ongetwijfeld een heleboel handleidingen die laten zien welke onderdelen ze gebruikten en hoe, inclusief de nodige code.\nAls je zulke code overneemt, lees die code dan in ieder geval goed door en probeer te begrijpen wat elk stukje doet. Als de code niet werkt, gebruik dan de checklist aan het eind van deze handleiding om het probleem op te lossen.\nDingen laten bewegen met servo-motors De simpelste manier om met de Arduino iets te laten bewegen (robotjes, plotters, bloempotten die naar het licht draaien) is een servo. Er zijn twee soorten: servo’s die draaien tussen 0 en 180 graden, en servo’s die door kunnen blijven draaien.\nZulke ‘continuous’ servo’s vertalen de richting die je ze opgeeft in een draairichting en snelheid. ‘0’ is 10 bijvoorbeeld volle snelheid naar links, ‘90’ is stilstaan en ‘110’ betekent ‘draai langzaam naar rechts’. Als je bij zo’n servo toch wil weten hoe ver hij is gedraaid, heb je een ‘rotary encoder’ of ‘encoder wheel’ nodig.\nDe meeste kleine servo-motors hebben drie draadjes:\n bruin is ground, dus min rood is voltage, dus plus geel is de pin waarop de Arduino de servo aanstuurt.  Sluit de servo aan, met de gele draad op pin 9. Als je deze schets uploadt, gaat het motortje heen en weer draaien: Bestand \u0026gt; Voorbeelden \u0026gt; Servo \u0026gt; Sweep\nZoals je ziet in de code, wordt de servo naar een bepaalde plek gestuurd met de functie myservo.write(). In de schets gebeurt dat in een for-loop om hem stapsgewijs heen en weer te laten draaien, maar je kunt de servo bijvoorbeeld ook naar de middenpositie sturen met het commando\nGrotere servo’s De servo zoals op de foto is klein en niet erg sterk. Er zijn ook (veel) sterkere servo’s. Die kun je ook met de Arduino aansturen, maar om ze van stroom te voorzien is een externe batterij nodig:\nOefening Stuur de servo een paar keer naar verschillende standen, en laat hem tussendoor een seconde wachten. Hint: de for-loops heb je hiervoor niet nodig, want aan een paar myservo.write’s en delay()’s heb je genoeg.\nTot slot Je kunt met de Arduino ontelbaar veel combinaties maken met verschillende inputs en outputs. Je kunt bijvoorbeeld een MP3-speler geluiden laten horen als een bewegingssensor beweging detecteert, of LED-strips van kleur laten veranderen op basis van een hartslag die je meet met een hartslagsensor.\nWat je kunt maken met elektronica wordt praktisch nergens meer door beperkt. Onderdelen zijn ontzettend goedkoop geworden, en de informatie over hoe je ze moet aansluiten en kunt gebruiken is altijd online te vinden. Zoek bijvoorbeeld op Google naar ‘Arduino planten vochtsensor’ en je vindt duizenden handleidingen die niet alleen laten zien hoe je zo’n sensor aansluit op je Arduino, maar die ook de nodige code delen.\nEen paar sites zijn met name aan te raden voor inspiratie en praktische informatie:\n Instructables: https://www.instructables.com/circuits/arduino/projects/ Arduino: https://blog.arduino.cc/ en https://www.arduino.cc/reference/en/ Hackster.io: https://www.hackster.io/arduino  Het belangrijkste is dat je ziet dat iedereen kan programmeren en toffe dingen kan maken met elektronica. Niemand kan of weet alles meteen, maar met oefening en gewoon blijven proberen kom je heel ver. Er is ontzettend veel mogelijk, en jij hoort bij de mensen die gave dingen kunnen maken.\nExtra Problemen oplossen Problemen met verbinding Dit is een lijst van mogelijke oplossingen als je er niet in slaagt om code te uploaden naar de Arduino. Als de eerste oplossing niet helpt, probeer dan de volgende oplossingen, in de volgorde waarop ze genoemd worden.\n Selecteer de juiste poort. Als je een foutmelding krijgt bij het uploaden, dan is het meestal omdat de computer niet weet op welke USB-poort de Arduino te vinden is:\nJe kunt dat oplossen door de juiste poort te selecteren in het menu Hulpmiddelen onder ‘Poort’. Soms staat er al bij waar de Arduino is verbonden, maar de kans bestaat dat je zelf moet raden. Het zou een adres moeten zijn met ‘usb’ erin, ‘serial’ of ‘COM’. Zorg dat onder ‘Board’ de juiste Arduino is geselecteerd (meestal Arduino Uno). Zit de USB-kabel er aan beide kanten goed in? Probeer eens een andere USB-poort (en dan weer stap 1). Herstart de Arduino-software. Probeer het uploaden zonder dat er iets met de Arduino verbonden is. (Als dit helpt dan is er ergens kortsluiting óf is er iets verbonden met de verkeerde pin.) Herstart de computer (en zie dan weer stap 1). Als je computer de Arduino niet kan vinden onder ‘Poort’, dan kan het nodig zijn om een driver installeren. Voer de instructies uit op https://www.arduino.cc/en/ Guide/DriverInstallation (en doe dan weer stap 1). Probeer een andere Arduino  Problemen met de code De foutmeldingen die Arduino geeft onderin beeld zijn vaak behoorlijk helder. Probeer ze te begrijpen zodat je sneller een probleem kunt opsporen en oplossen.\n Waar zit de fout? Vind de regel die rood is gemaakt. De fout kan ook direct boven die regel zitten. De meest voorkomende fout is dat een functie of commando niet goed afgesloten wordt. Staat er een ‘}’ te veel of te weinig? Zorg dat er voor elke ‘(’ een ‘)’ is en voor elke ‘{’ ook een afsluitende ‘}’ en dat elk commando wordt afgesloten met een puntkomma. Staat alle code wel echt ín setup() of loop()? Dus binnen de gekrulde haken van een van beide functies? Als je schets een library aanroept die niet gevonden kan worden, dan krijg je de foutmelding ‘No such file or directory’. Installeer in dat geval alsnog de bijbehorende library; zie daarvoor de pagina ‘Libraries installeren’ in deze handleiding. Zoek online naar oplossingen voor de foutmelding die je krijgt. Zoek naar ‘Arduino “exacte foutmelding tussen aanhalingstekens”’. Gebruik een heel andere schets. Probeer een van de voorbeeldschetsen in Arduino en pas die aan, of probeer online code te vinden die doet wat jij wil.  Geen foutmelding, maar toch niet de werking die je verwacht?  Check of de componenten echt met de juiste pinnen zijn verbonden en dat dat ook de pinnen zijn die genoemd worden in de code. Bij gebruik van een breadboard: zitten de componenten écht op het goede rijtje? Gebruik Serial.println()’s om te weten wat de Arduino aan het doen is (zie de uitleg daarover op de pagina over de seriële plotter). Probeer een ander exemplaar van het onderdeel dat je probeert aan te sluiten, om te zien of dat misschien het probeem is. Probeer eventueel ook andere draadjes of zelfs een ander breadboard.  Libraries installeren Je hoeft lang niet alles helemaal zelf te programmeren. Er is al heel veel software geschreven door mensen die hun werk graag met je delen (dat heet open-source software en het is geweldig!).\nAls zulke software uitgebreider is dan een enkele schets, dan heet zo’n software-pakketje een bibliotheek, of library. Het Arduino-programma heeft een aantal libraries al voor-geïnstalleerd, maar soms zul je dat zelf moeten doen.\nStel dat je een infrarood-sensor wil uitproberen om met een afstandsbediening je Arduino-project te kunnen bedienen. Dat wordt je makkelijk gemaakt door een library die IRremote heet.\nGa naar het menu Hulpmiddelen \u0026gt; Bibliotheken beheren. Zoek op ‘IRremote’ in het zoekvenster, en dan staat hij waarschijnlijk als tweede in de lijst resultaten.\nKlik op ‘Installeren’ en dan ‘sluiten’.\nAls je een library geïnstalleerd hebt, kun je via Bestand \u0026gt; Voorbeelden de voorbeeldschetsen openen die bij de library horen. Met die schetsen kun je snel leren hoe je de library kunt gebruiken in je eigen project.\nIn het geval van IRremote: Bestand \u0026gt; Voorbeelden \u0026gt; IRremote \u0026gt; IR receiveDemo. Meer uitleg over 12 afstandsbedieningen en hoe je de library gebruikt vind je hier: https://www.circuitbasics.com/arduino-ir-remote-receiver-tutorial/\nNiet álle bibliotheken kun je op deze manier installeren. Soms moet je een map met bestanden downloaden en die dan handmatig toevoegen aan de map waar Arduino de bibliotheken bewaart. De locatie van die map vind je via het menu Arduino \u0026gt; Preferences.  Een timer voor Arduino-programma’s: millis() Als je Arduino twee dingen tegelijk wil laten doen, zoals een lampje laten knipperen en ondertussen in de gaten houden of een knop wordt ingedrukt, dan is het belangrijk om géén delay() te gebruiken. De functie delay() zorgt ervoor dat de de Arduino een tijdje wacht, en ondertussen staat alles stil. Als hij bijvoorbeeld wacht tot de LED weer aan of uitgezet kan worden, kan hij dus niet tegelijk in de gaten houden of de knop wordt ingedrukt.\nOm zoiets wel tegelijk te kunnen doen, laten we Arduino een soort stopwatch gebruiken. Die stopwatch heet millis(). Met die functie kunnen we in de gaten houden hoe lang onze schets al loopt, en op gezette tijden iets doen.\nHieronder zie je bijvoorbeeld een schets die elke drie seconden een LED aan- of uitzet, zónder in de tussentijd alles te blokkeren met delay().\nIn het Engels heet deze oplossing ook ‘non-blocking code’, code die niet blokkeert. Er is een handige library voor, die arduino-timer heet. Daarmee kun je meerdere ‘stopwatches’ in één schets hebben. Als je hem installeert (zie ‘Libraries installeren’), zie je de mogelijkheden in de bijbehorende voorbeeldschetsen.\n// Begintijd is het aantal milliseconden sinds het script begon. int begintijd = millis(); void setup() { pinMode(LED_BUILTIN, OUTPUT); // Het ingebouwde LEDje op de Arduino activeren } void loop() { if ((millis() - begintijd) \u0026gt; 3000) { // Zijn er al 3 seconden verstreken?  // Zo ja, doe dan dit:  // verander de LED naar aan of uit  // (het uitroepteken betekent \u0026#39;maak er van wat hij nu NIET is\u0026#39;)  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN) ); // reset de stopwatch: verander begintijd naar het aantal milliseconden NU  begintijd = millis(); } // Nu kunnen we hier andere dingen doen, zoals motortjes laten draaien, of in  // de gaten houden of knoppen worden ingedrukt, zónder te wachten op delays. } Wat je kunt meten en doen met Arduino    Inputs Outputs     Afstandssensor Licht: lampen, lasers, LEDs, EL wire, glasvezel   Accelerometer Geluid: speakers, transducers, versterkers, MP3-spelers\nEr zijn er verschillende, maar deze is goedkoop en gemakkelijk aan te sluiten: https://wiki.dfrobot.com/DFPlayer_Mini_SKU_DFR0299   Gyroscoop Motoren: servo’s, heel precieze stappenmotoren, hele snelle DCmotoren, heel sterke gear motors, trilmotors, lineaire actuatoren, ventilatoren.   Kompas Solenoids   Temperatuur Elektromagneten, ferrofluids   Relatieve luchtvochtigheid Video (animaties, video’s, VR/AR)   Vochtsensor (planten water geven!) LCD-display (zoals in snoepautomaten)   Barometer Pomp (bijv. om het te laten regenen of een beeld te laten huilen)   Lichtsensor Metaal dat van vorm verandert   Kleurensensor Warmte- en koel-elementen   Draaiknoppen en lineaire potmeters (zoals de schuiven op mengpanelen) Rookmachine   Microfoons (of andere audio-signalen) Website of sociale media (automatisch informatie posten op basis van sensorgegevens)   Aanraking    Schakelaars    Keyboard en muis    Vingerafdruk    Camera’s    Bewegingssensor    Infrarood-ontvanger (je project besturen met afstandsbediening!)    Hartslag\nSommige hartslagsensors werken amper. Deze is wat duurder, maar geeft wel redelijk goede meetresultaten: https://www.kiwi-electronics.nl/pim-438    Rook    Gas    Straling    Vlammendetector    Magneetvelden    Trilling    Buigsensor    Stroming    Hersenactiviteit     Dit is zeker geen complete lijst, maar je ziet vast zo al dat de mogelijkheden eindeloos zijn. Welke combinaties van inputs en outputs lijken jou interessant?\nLicentie Deze handleiding is geschreven door Jaap Meijers (instructeur/beheerder van het Hacklab van de Koninklijke Academie van Beeldende Kunsten in Den Haag en mentor van CoderDojo Nijmegen) en gepubliceerd in mei 2021 onder de Creative Commons Attribution 4.0 Internationallicentie. Dat betekent dat je deze handleiding vrij mag verspreiden en aanpassen, mits je de bron vermeldt en verwijst naar de licentie.\nDe broncode voor deze instructie vind je hier https://github.com/coderdojonijmegen/arduino-snelle-introductie.\nVerantwoording foto’s  Arduino met relais en lamp: Adilson Thomsen/FilipeFlop/Wikimedia Breadboard: Victoria.nunez2/Wikimedia LDR: Arnau 944/Wikimedia Potmeter: Iainf/Wikimedia Piezo buzzer: Adafruit/Flickr Ultrasone afstandssensor: Nowforever/Wikimedia Microservo: eigen foto Arduino met bloemen: madshobye/Instructables.com Diagram IR-remote bij ‘Libraries installeren’: Benne de Bakker/makerguides.com Stopwatch: Matthew/Flickr Losse onderdelen: Robin Glauser/Unsplash Diagrammen met potmeter, ultrasone afstandssensor en servo: Fritzing.org Alle screenshots van Arduino IDE, diagram bij ‘Digitale sensors’ en de foto van Arduino-bord bij ‘Wat is de Arduino’: Arduino.cc ","date":"June 27, 2021","permalink":"/instructies/arduino-snelle-introductie/","title":"Arduino - een snelle introductie"},{"categories":null,"contents":"We gaan een chat programma maken!\nBenodigdheden Voordat we aan de slag kunnen, moeten we eerst een paar dingen regelen. We hebben een checklist gemaakt van alles wat je nodig hebt, daaronder volgt per stap de uitleg.\nChecklist  De skeleton app Een tekst editor Een web browser Een web server De chat server URL De developers tools  De skeleton app Klik hier om de skeleton app te downloaden. Pak dit bestand uit naar een map, bijvoorbeeld op je bureaublad.\nDit zijn de bestanden die je nodig hebt om te beginnen: een html file, een css file en een javascript file. Elk bestand heeft z\u0026rsquo;n eigen hoofdstuk, waarin je dat bestand gaat bewerken en je eigen dingen toe voegt.\nAls je ergens een foutje maakt, kun je de bestanden altijd opnieuw uitpakken.\nEen tekst editor Als je nog geen tekst editor hebt, adviseren wij Visual Studio Code.\nDownload, installeer en open VS Code. In VS Code klik je op \u0026ldquo;Open Folder\u0026rdquo;, selecteer dan de map waar je de skeleton app hebt uitgepakt.\nAndere tekst editors zijn ook prima, als je aan iets anders gewend bent. Bijvoorbeeld: Notepad++ of Sublime Text.\nEen web browser In alle voorbeelden gebruiken wij Google Chrome. Andere browsers, zoals Firefox of Edge, zijn ook prima, mogelijk zien de app en developers tools er dan wel anders uit dan in Chrome.\nControleer ook of je de nieuwste versie hebt van de browser, om zeker te weten dat de app goed werkt.\nEen web server Om je app te zien, moet je een web server hebben die naar je map verwijst. Daarnaast zijn er een paar instellingen belangrijk.\nWij adviseren Web Server for Chrome. Installeer de web server en open de app. Je zie dan een instellingen pagina. Selecteer hier de uitgepakte map en stel de server in zoals op deze afbeelding:\nLet op: De CORS headers zijn heel belangrijk om de chat werkend te krijgen.\nDe chat server URL Als het goed is, hebben de mentoren je een link gegeven van de chat server. Dit is belangrijk om te kunnen praten met de andere ninja\u0026rsquo;s in de groep.\nZoek de volgende regel in je index.html bestand, en plak de chat server url tussen de haakjes:\n\u0026lt;script\u0026gt; var serverIpAdresEnPoort = \u0026#34;https://chat.coderdojo-nijmegen.nl\u0026#34;; \u0026lt;/script\u0026gt;  De developers tools Als het goed is, heb je nu alles om je app te bouwen. Open de link van je web server in Chrome, als het goed is zie je dan drie gekleurde balken.\nKlik met je rechter muisknop op èèn van die balken en klik op \u0026ldquo;Inspect Element\u0026rdquo;. Hiermee open je de developers tools van Chrome, waar je kan sleutelen aan alle onderdelen van de app.\nVoor de chat app is het fijn om de developers tools rechts van je scherm te zetten met deze knop, rechts van je tools. Sleep de rand van de tools dan zo, dat het ongeveer de helft van je scherm in beslag neemt.\nStructuur (HTML) Deze instructies bestaan uit drie hoofdstukken:\n Structuur (HTML) - hier gaan we de app onderdelen in elkaar zetten. Stijl (CSS) - hier gaan we veranderen hoe de onderdelen eruit zien. Scripts (Javascript) - hier gaan we veranderen hoe de app werkt.  Bij elk hoofdstuk hoort een bestand. Voor dit hoofdstuk werken we in de index.html.\nHTML: blokjes en tekst In het begin zul je nog niet alles snappen wat in de bestanden staat. Dat is okè! Laten we eerst rond kijken en dan gaan we onze eigen onderdelen toevoegen:\n Open de app en de developers tools (zie Benodigdheden). Klik op de Inspect Element knop (zie afbeelding), zodat deze blauw wordt.\n Beweeg de muis over de groene, gele en grijze balken in de app.  Je ziet de \u0026lsquo;div\u0026rsquo; elementen in de Developers Tools oplichten. Dat zijn de \u0026lsquo;blokjes\u0026rsquo; waarmee je begint. Een paar dingen moet je weten over die blokjes:\n Een blok begint met \u0026lt;div\u0026gt; en eindigt met \u0026lt;/div\u0026gt;. Met class=\u0026rdquo;\u0026quot; krijgt het blokje een class naam. De class wordt in de CSS (hoofdstuk 2) gebruikt om te bepalen hoe het eruit ziet. De class wordt ook in de Javascript (hoofdstuk 3) gebruikt om te bepalen hoe het werkt. Blokjes kunnen in elkaar en blokjes kunnen naast elkaar.  HTML tekst In de HTML kun je tekst typen. Afhankelijk van waar je die tekst typt, komt het ergens anders op het scherm (of misschien zelfs helemaal niet).\n Zoek de div blokjes op in de index.html, het zijn er vier. De \u0026lsquo;container\u0026rsquo; class zorgt ervoor dat de blokjes die er in zitten onder elkaar komen. In de container zie je drie andere divs. Kun je raden waar die voor zijn? Schrijf wat tekst, bijvoorbeeld \u0026ldquo;Hallo wereld!\u0026rdquo;, in het blokje met de class \u0026lsquo;midden\u0026rsquo;. Ververs je pagina. Staat je tekst in het middelste blokje? Zo niet, dan is er misschien iets mis gegaan. Probeer ook tekst te typen in de boven en onder blokjes. Verschijnt die tekst ook op de juiste plek in je scherm? Wat gebeurt er als je tekst typt in de container, maar buiten de boven/midden/onder blokjes? Wat gebeurt er als je tekst typt buiten de container (maar wel in de \u0026lt;body\u0026gt;)?  Chat berichten Nu dat je snapt hoe de HTML blokjes werken, kun je je eigen blokjes toe voegen.\nVoeg deze code in, in het blokje \u0026ldquo;midden\u0026rdquo;:\n\u0026lt;div class=\u0026#34;berichten\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Ververs de pagina. Als het goed is, verschijnen nu de chat berichten op je scherm! Zo makkelijk kan het zijn om onderdelen toe te voegen.\nBerichten typen We willen natuurlijk ook berichten kunnen sturen.\nVoeg deze code in, in het blokje \u0026ldquo;onder\u0026rdquo;:\n\u0026lt;div class=\u0026#34;berichtInput\u0026#34;\u0026gt;Type hier...\u0026lt;/div\u0026gt; Als het goed is, zie je \u0026ldquo;Type hier\u0026hellip;\u0026quot; op je scherm, maar als je daar klikt, kun je nog niet typen. Dat komt, omdat div daar niet voor is gemaakt. Verander het woord div in textarea, en ineens ziet het er heel anders uit:\n\u0026lt;textarea class=\u0026#34;berichtInput\u0026#34; placeholder=\u0026#34;Type hier...\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; Je kunt nu tekst typen. Als je op enter drukt, wordt je bericht verstuurd!\nMeer onderdelen Laten we nog wat meer onderdelen toevoegen. Kopieer deze blokjes en plak ze in de boven/midden/onder blokjes. Je mag zelf bepalen waar deze blokjes in je app komen en in welke volgorde. Je kan ook ons voorbeeld onderin deze pagina na maken.\nTips:\n Probeer niet alles tegelijk te doen. Plak een blokje in de index.html, sla op en ververs de pagina in chrome. Staat een blokje niet op de plek die je had verwacht? Gebruik de Inspect Element knop om te ontdekken wat er mis is gegaan! De boven/midden/onder classes heb elk hun eigen manier van blokjes plaatsen. Hier gaan we in het volgende hoofdstuk verder op in. Verander teksten en de type blokjes, je kan er vanalles van maken. Zolang de \u0026lsquo;class\u0026rsquo; klopt, zou het moeten blijven werken.  De blokjes \u0026lt;h1\u0026gt;Ninja chat\u0026lt;/h1\u0026gt; Met h1 plaats je een titel, de letters zijn dan groter en dikker. Het heeft verder geen speciale effecten, dus h1 is net als een div. Probeer ook h2 en h3 voor verschillende grooottes.\n\u0026lt;div\u0026gt;Naam: \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;naamInput\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Een input is een speciaal soort blokje, waar je iets kan typen of aanklikken. Een input hoeft niet afgesloten te worden, want er kan nooit html in een input staan. Met type=\u0026quot;text\u0026rdquo; wordt gezegd dat je tekst kan typen. De class \u0026lsquo;naamInput\u0026rsquo; is voor het invoeren van je naam. We hebben de input in een div blokje geplaatst, zodat de tekst \u0026ldquo;Naam\u0026rdquo; er mooi bij komt te staan. Verander de standaard naam in je eigen naam, omdat bij de berichten terug te zien.\n\u0026lt;div\u0026gt;Kanaal: \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;kanaalInput\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Ook dit is een input, nu met type \u0026lsquo;number\u0026rsquo;, zodat je alleen een getal kan invullen. Elk bericht hoort bij een kanaal en je kanaal is standaard \u0026lsquo;1\u0026rsquo;.\n\u0026lt;button class=\u0026#34;stuurBericht\u0026#34;\u0026gt;Stuur bericht\u0026lt;/button\u0026gt; Button is Engels voor het woord \u0026lsquo;knop\u0026rsquo;. Tot nu toe stuurde je berichten door op \u0026lsquo;enter\u0026rsquo; te drukken, nu kan het ook door op deze knop te klikken.\n\u0026lt;div class=\u0026#34;deelnemers\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Deze div is nog leeg, het doet niets totdat er op de deelnemers knop wordt gedrukt. Maar die knop heb je nog niet, dus die volgt nu:\n\u0026lt;button class=\u0026#34;bekijkDeelnemers\u0026#34;\u0026gt;Bekijk deelnemers\u0026lt;/button\u0026gt; Je krijgt dus een knop waarmee je deelnemers kan bekijken, zodra daar op wordt geklikt wordt de \u0026lsquo;deelnemers\u0026rsquo; div gevuld met de namen van de andere ninja\u0026rsquo;s en mentoren. Deze knop mag ook in de \u0026lsquo;deelnemers\u0026rsquo; div staan, zodat de namen en de knop mooi bij elkaar staan.\nHTML in berichten Wat de ninja-chat zo bijzonder maakt, is dat je HTML in je berichten kan gebruiken. Type maar eens als bericht in de chat:\n\u0026lt;h1\u0026gt;Hallo wereld!\u0026lt;h1\u0026gt; Zoals eerder gezegd, is h1 een blokje zoals de div. Maar niet elke HTML code is een eigen blokje. Je kan ook HTML gebruiken om een woord of meerdere woorden op te maken. Type dit als bericht in de chat:\nHier is woord \u0026lt;strong\u0026gt;dikgedrukt\u0026lt;/strong\u0026gt; en twee woorden \u0026lt;em\u0026gt;schuin gedrukt\u0026lt;/em\u0026gt;!\nProbeer ook andere HTML code die je hebt geleerd in je berichten. Alles mag!\nAfbeeldingen Het mooiste HTML blokje hebben we bewaard voor het laatst: je kan plaatjes zien in je app!\n\u0026lt;img src=\u0026#34;coderdojo.png\u0026#34;\u0026gt; Het plaatje is erg groot, eigenlijk te groot om mooi in de app te passen. Dit is makkelijk op te lossen door een width (= breedte) en een height (= hoogte) bij te voegen:\n\u0026lt;img src=\u0026#34;coderdojo.png\u0026#34; width=\u0026#34;32\u0026#34; height=\u0026#34;32\u0026#34;\u0026gt; Net als een input blokje, hoeft de img niet afgesloten te worden. De link voor het plaatje schrijf je in src=\u0026rdquo;\u0026quot;. We gebruiken nu de bijgesloten coderdojo.png als voorbeeld, maar het kan elk plaatje zijn wat je maar wilt.\nZo kies je je eigen plaatjes:\n Zoek op internet een plaatje dat je in de app wilt hebben. Klik met rechtermuisknop op het plaatje en selecteer \u0026ldquo;afbeeldingsadres kopiëren\u0026rdquo;. Type een nieuw img blok in je index.html en ze je cursor in de aanhalingstekens van de src. Gebruik rechtermuisknop en klik op plakken, of type CTRL-V om te plakken. Sla op en bekijk je plaatje in de app.  Tip: Op deze manier kun je ook plaatjes in je chat berichten plaatsen.\nStijl (CSS) Je weet nu hoe je HTML blokjes kan plaatsen en je weet hoe je die een class naam kan geven. Die class namen gaan we nu gebruiken om ze te stylen: je kan helemaal veranderen hoe ze eruit zien!\nVoor dit hoofdstuk werk je voornamelijk in het bestand basic-chat.css.\nKleuren en lettertypes Laten we eerst kleuren aanpassen:\n Zoek het div blokje \u0026lsquo;midden\u0026rsquo; in de Developers Tools, gebruik eventueel Inspect Element op de gele achtergrond. Rechts zie je een tabblad \u0026ldquo;Styles\u0026rdquo;, hier staan alle CSS regels voor dit blokje. Schrik niet, het zijn er veel! Zoek de regel background-color: lightyellow (TODO: screenshot met een pijl ofzo). Klik op het woord lightyellow en druk op backspace. De browser toont al een lijst van kleuren, klik of type cadetblue. Zie hoe de kleur van het midden blok is veranderd! Verander van andere blokjes ook de background-color. Probeer verschillende kleuren uit.  De kleuren die je nu in stelt worden nog niet opgeslagen. De volgende keer dat je refresht is alles weer terug naar hoe het was.\nStyling opslaan Dit is hoe je je kleuren kan opslaan:\n Noteer of kopieer de naam van de kleur die je wilt opslaan. Je kunt ook een kleur kiezen op deze website: csscolornames.com Open de basic-chat.css. Zoek de regel .midden {, hier staan de stijl regels voor het midden blok. Verander de background-color in een kleur naar keuze en sla het bestand op. Refresh je browser en zie de kleur die je hebt gekozen in het midden blok.  Op deze manier kun je alle achtergrond kleuren instellen die je wilt. Zoek de andere onderdelen van je app op in het CSS bestand en geef ze een kleur die je leuk vindt.\nTekst Je kunt ook teksten er anders uit laten zien. Voeg deze regels eens toe, bijvoorbeeld bij .bericht:\ncolor: yellow; font-family: \u0026#39;Indie Flower\u0026#39;, cursive; color verandert de kleur van de tekst. Je kunt dezelfde kleuren gebruiken als voor background-color.\nfont-family verandert het lettertype. Kun je ontdekken welk lettertype nog meer wordt gebruikt in de app?\nProbeer deze kleuren eens na te maken. Tip: Geef de titel een nieuwe class naam en gebruik die class naam om in de CSS het lettertype in te stellen.\nVormen en randen Alles op het scherm kunnen we groter of kleiner maken. Probeer dit eens uit:\n Klik op één van de berichten, met Inspect Element. Bij de styles zie je onder andere padding, border en margin. Verander de getallen één voor één en kijk wat er gebeurt: maak ze 40px, of 1px, of 0. Je ziet ook border-radius, verander daarvan ook het getal. Verander de kleur van \u0026lsquo;border\u0026rsquo; (border is Engels voor \u0026lsquo;rand\u0026rsquo;). Verander bij de border het woord \u0026lsquo;solid\u0026rsquo; in \u0026lsquo;dotted\u0026rsquo; en kijk wat er gebeurt.  Het is makkelijker om te zien wat het doet, dan om het uit te leggen. In het kort:\n 10px betekent 10 pixels. Een pixels is een punt op je scherm. border is de rand van een blokje. Het is een lijn of stippels, heeft een kleur en een dikte. padding is hoeveel ruimte er IN het blokje is, voordat de tekst begint. margin is hoeveel ruimte er OM het blokje heen is. border-radius is om te rand rond te maken.  Tip: Probeer eens een blokje helemaal rond te maken met border-radius.\nMeer CSS Met CSS kun je van elk blokje zeggen hoe het eruit moet zien. Als je het leuk vindt, kun je in de basic-chat.css nog andere blokjes aanpassen met de border en padding enzo. Je kunt ook kijken welke CSS opdrachten er nog meer in staan. We hebben zoveel mogelijk in het bestand beschreven wat we doen, als je twijfelt kun je altijd nog op internet zoeken. Succes!\nStyling in berichten Je kunt ook CSS in je berichten gebruiken! Schrijf bijvoorbeeld eens:\nHier is een stukje tekst \u0026lt;span style=\u0026#34;color:blue;\u0026#34;\u0026gt;blauw\u0026lt;/span\u0026gt; Met style=\u0026rdquo;\u0026quot; kun je CSS in een HTML blokje stoppen. Dat werkt dan alleen voor dat ene blokje, maar dat is perfect voor in berichten. Probeer ook eens de andere CSS commando\u0026rsquo;s die je hebt geleerd, zoals border en font-family.\nTip: als je meerdere CSS commando\u0026rsquo;s in één blokje wilt, zet je er een ; tussen. Bijvoorbeeld:\n\u0026lt;span style=\u0026#34;color:white;background-color:black\u0026#34;\u0026gt;Dit bericht is zwart/wit.\u0026lt;/span\u0026gt; Scripts (JavaScript) Nu dat je een complete app hebt en zelf heb bepaald hoe het eruit ziet, gaan we een kijkje onder de motorkap nemen: hoe worden de berichten verstuurd en ontvangen?\nVoor dit hoofdstuk werk je in het bestand basic-chat.js.\nJavascript: de basis Javascript is de programmeertaal van het web. Alle HTML blokjes die je nu in je app hebt, kun je met Javascript aan sturen. Je kunt ook berichten sturen naar de server en ontvangen van de server. Daar gaan we mee aan de slag.\n Klik bovenin de Developers Tools op het tabblad \u0026ldquo;Console\u0026rdquo;. Je ziet een groot vlak en misschien een paar berichten. Onder de berichten, zie je een blauwe \u0026gt;, klik daar naast zodat je kan typen. Type de onderstaande berichten. Druk na elk bericht op enter en zie wat er gebeurt:  console.log(\u0026#34;Hallo console!\u0026#34;) socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo websocket!\u0026#34;)  Je hebt nu een berichtje in de console én je hebt een berichtje via de chat verstuurd! Allebei kunnen ze heel handig zijn! Laten we zien wat we nog meer kunnen met Javascript.\nAls je iets wilt weten van je app, kun je een commando geven dat iets terug geeft om te onthouden. Type eens:\n$(\u0026#34;.naamInput\u0026#34;).val()  Je ziet je naam nu terug in de console! Deze commando ziet er misschien gek uit, dit is wat er gebeurt:\n $(\u0026quot;.naamInput\u0026rdquo;) zoekt de blokjes op met de class \u0026lsquo;naamInput\u0026rsquo;. .val() vraagt om de tekst die staat ingevuld bij het eerst gevonden blokje.  Kun je op die manier ook het kanaal op vragen? Of een bericht in de chat?\nVariabelen Met variabelen (var) kan de browser dingen onthouden:\nvar naam = $(\u0026#34;.naamInput\u0026#34;).val() socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo, mijn naam is \u0026#34; + naam)  Je hebt nu een bericht verstuurd met je naam er in! Kun je hetzelfde doen met je kanaal?\nBerekeningen Computers zijn ook heel goed in rekenen. Het woord computer is zelfs Engels voor \u0026ldquo;berekenaar\u0026rdquo;! Type het volgende maar eens om uit te proberen:\nvar kanaal = $(\u0026#34;.kanaalInput\u0026#34;).val() kanaal + 2  Dit gaat nog niet goed: het getal 2 is achter het kanaal nummer geplaatst. Dat komt omdat javascript niet gelijk snapt dat het een getal is:\nparseInt(kanaal) + 2  Nu zie je je kanaal, met twee erbij opgeteld. Om de oefening af te maken, laten we de server vertellen dat we een nieuw kanaal willen:\nsocket.emit(\u0026#34;zetKanaal\u0026#34;, parseInt(kanaal) + 2)  Functies en parameters Je hebt al verschillende commando\u0026rsquo;s aangeroepen, zoals socket.emit en parseInt, maar je kan ook je eigen commando\u0026rsquo;s maken. Dat noemen we functions. Type dit eens in je console:\nfunction hallo(naam) { socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo \u0026#34; + naam + \u0026#34;!\u0026#34;) }  Er gebeurt nog niets. Dat komt omdat je de function eerst moet aanroepen, voordat er iets gebeurt:\nhallo(\u0026#34;ninjas\u0026#34;) hallo(\u0026#34;ikzelf\u0026#34;) hallo(\u0026#34;javascript\u0026#34;)  Je kan de functie zo vaak aanroepen als je maar wilt.\nJe eigen bot Je weet nu al veel over hoe je commando\u0026rsquo;s geeft en maakt in Javascript. Met functions kun je ook reageren op dingen die gebeuren. Zo kun je een function schrijven die reageert op berichten in de chat:\nfunction hoiDoei(bericht) { if (bericht.tekst == \u0026#34;hoi\u0026#34;) { socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;doei\u0026#34;) } }  Het woord if is Engels voor \u0026lsquo;als\u0026rsquo;. Er staat dus: als het bericht \u0026ldquo;hoi\u0026rdquo; is, zeg dan \u0026ldquo;doei\u0026rdquo;. Maar hoe ontvangen we berichten?\nsocket.on(\u0026#34;krijgBericht\u0026#34;, hoiDoei)  Elke keer als er een bericht binnen komt, wordt de commando hoiDoei aangeroepen. Type maar eens het woord \u0026ldquo;hoi\u0026rdquo; in de chat!\nNog veel meer Met HTML, CSS en Javascript kun je hele programma\u0026rsquo;s bouwen, zoals je ziet. Er valt nog ontzettend veel te leren! De eerst volgende stap is om de basic-chat.js te lezen en je kan dat bestand ook aanpassen, om andere dingen te doen: automatisch van kanaal wisselen bij een bericht, je naam veranderen via een bericht, enzovoorts. Je kunt ook altijd op internet zoeken naar wat je nog meer kan met HTML, CSS en Javascript, de website https://www.w3schools.com/ is een leuke plek om te beginnen. Heel veel plezier en heel veel succes!\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"May 24, 2021","permalink":"/instructies/javascript-ninja-chat/","title":"Javascript - Ninja-Chat"},{"categories":null,"contents":"We gaan programmeren met PHP.\nIntroductie De meestgebruikte programmeertaal voor websites is PHP. Het is een heel handige taal waarmee je een eigen slimme website kunt bouwen.\nJe gaat nu leren hoe PHP werkt, en dat doe je door een online vriendenboek te maken. Je leert informatie op te slaan, hoe je uitrekend hoeveel dagen oud je vrienden zijn, en hoe je een plaatje maakt met hun lievelingskleur.\nBenodigdheden Als je websites wil bouwen met PHP, heb je een plek nodig waar je software kunt schrijven. We gebruiken nu CodeAnywhere. Daar kun je oefenen met PHP, en zie je ook meteen hoe het resultaat eruitziet.\nAls je je niet eerder hebt aangemeld, ga dan naar https://codeanywhere.com/signup. Vul je mailadres in, een wachtwoord, kruis het hokje aan, en klik op \u0026lsquo;register\u0026rsquo;. Open het mailtje dat CodeAnywhere je gestuurd heeft om op de link te klikken. Ga door naar de editor: https://codeanywhere.com/editor.\nIn het scherm dat je daar ziet, vul je eerst je naam in. Bij \u0026lsquo;Search stack\u0026rsquo; vul je PHP7 in, en dan klik je op PHP 7 in de lijst daaronder. Klik onderaan op \u0026lsquo;create\u0026rsquo; en wacht af.\nStappen Je eerste webpagina Als het goed is, zie je nu een omgeving waarin je kunt beginnen aan het maken van je eigen website.\nMaak de eerste pagina aan door in het menu bovenaan te klikken op File, en dan \u0026lsquo;New File\u0026rsquo;. Nu kun je in het grote zwarte vlak in het midden beginnen met je eerste webpagina.\nEen webpagina ziet er in het begin altijd zo uit als hieronder. Kopiëer en plak dit voorbeeld in het zwarte vlak:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welkom\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In het blokje \u0026lsquo;head\u0026rsquo; staat informatie over je site, zoals de titel. In het blok daaronder, de body, staat alles dat te zien is op de pagina, zoals de kop, tekst en plaatjes.\nDeze indeling met \u0026lt;\u0026gt;-tekens noemen we HTML. Dat is de taal waarmee je opgeeft wat waar op de pagina komt te staan en hoe het eruit ziet.\n\u0026lt;h1\u0026gt; is bijvoorbeeld een HTML-code waarmee je opgeeft dat het een dikgedrukte kop bovenaan de tekst is.\nBewaar je pagina door in het File-menu op \u0026lsquo;Save\u0026rsquo; te klikken. Klik in het venster dat je dan ziet op \u0026lsquo;file name\u0026rsquo; en vul daar in: index.php Klik daaronder op je naam en dan onderaan het venster op \u0026lsquo;Save\u0026rsquo;.\nNu kun je je webpagina bekijken. Klik op de \u0026lsquo;play\u0026rsquo;-knop bovenaan:\nPHP mee laten doen Je website is nu nog heel eenvoudig - en niet zo slim. Hij laat alleen zien wat jij hebt ingetypt.\nJe kunt je webpagina er ook steeds anders uit laten zien, door PHP te gebruiken. De programmacodes van PHP kun je gewoon tussen de HTML-code zetten.\nVoeg deze regel toe aan je webpagina, direct onder de regel met :\n\u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hallo wereld\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;  Zo dus:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welkom\u0026lt;/h1\u0026gt; \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hallo wereld\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Je laat weten waar de PHP-code begint met .  is HTML en geeft aan waar een nieuwe alinea begint. Zoals de meeste codes in HTML sluit je die ook weer af, met . En klik weer op \u0026lsquo;play\u0026rsquo;.\nHet enige dat je PHP nu laat doen, is iets laten zien in de browser (het programma waarmee je de website bekijkt). Gelukkig kun je met PHP nog veel slimmere dingen maken, en dat gaan we nu doen.\nWebsites slimmer maken Eén van de manieren waarop je een webpagina wat slimmer kunt maken, is door PHP een beetje te laten meedenken.\nJe kunt bijvoorbeeld steeds iets anders laten zien op basis van het adres (de url) dat een bezoeker intypt om bij jouw webpagina te komen.\nVerander de PHP-regel uit het vorige voorbeeld zodat dit er komt te staan:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;?php echo \u0026#39;Hallo \u0026#39; . $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#39;!\u0026#39;; ?\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Let erop dat je ook de -codes uit het vorige voorbeeld weghaalt. Let ook op dat de H1-kop pas afsluit ná de PHP-code. De PHP code moet dus tussen  en  staan.\nPHP zegt nu met het commando echo \u0026lsquo;Hallo\u0026rsquo; tegen een naam die in het webadres van je pagina wordt genoemd. We laten dat zo zien.\nSla je pagina op (via File en Save) en druk weer op \u0026lsquo;play\u0026rsquo;.\nJe ziet nu dat de kop van de pagina is veranderd in \u0026lsquo;Hallo !\u0026rsquo;. Meer niet, want we hebben nog geen naam genoemd in het webadres.\nTik in de adresbalk achter het adres van je site ?naam= en dan je naam. Het zou er ongeveer zo uit moeten zien:\nhttp://jaap-jaap433627.codeanyapp.com/?naam=Steven\nof zo:\nhttp://jaap-jaap433627.codeanyapp.com/index.php?naam=Steven\nDruk op enter om de pagina opnieuw te laden. Probeer het daarna nog een paar keer met een andere naam in het adres.\nFormulieren Wat je nu zou kunnen doen, is een persoonlijke pagina maken voor elk van je vrienden en familieleden. Door een formulier op die pagina te zetten, kunnen zij meer informatie over zichzelf invullen. Zo maak je je eigen online vriendenboek.\nMaak dit formulier:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;?php echo \u0026#39;Hallo \u0026#39; . $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#39;!\u0026#39;; ?\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;resultaten.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt; Je voornaam: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;naam\u0026#34; value=\u0026#34;\u0026lt;?php echo $_REQUEST[\u0026#34;naam\u0026#34;]; ?\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Hoe oud ben je? \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;leeftijd\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Opsturen\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Vul hier je eigen naam in. [bij de titel]\n[als we de naam al weten, dan vult PHP die hier alvast in]\nVoeg zelf nog twee vragen toe voor het vriendenboek: hoe lang ze zijn (in centimeters) en nog iets, zoals bijvoorbeeld wat hun favoriete film is. Let erop dat je elk input-veld een unieke \u0026lsquo;name\u0026rsquo; geeft, dus bijvoorbeeld \u0026lsquo;name=\u0026quot;lengte\u0026rdquo;\u0026rsquo;.\nResultaten van het formulier In de code kun je zien dat het formulier de ingevulde informatie doorgeeft aan een andere pagina die resultaten.php heet. Die pagina gaan we nu aanmaken.\nGa bij CodeAnywhere naar File en klik op \u0026lsquo;New file\u0026rsquo;.\nMaak een pagina die ongeveer lijkt op die hieronder. Denk eraan dat je het antwoord op je zelfbedachte vraag ook nog moet opvangen.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Resultaten\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Hoi \u0026lt;?=$_REQUEST[\u0026#34;naam\u0026#34;]?\u0026gt;, je bent dus \u0026lt;?=$_REQUEST[\u0026#34;leeftijd\u0026#34;]?\u0026gt; jaar oud en \u0026lt;?=$_REQUEST[\u0026#34;lengte\u0026#34;]?\u0026gt; centimeter lang.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [dit is een iets andere manier om PHP even snel iets in te laten vullen]\nSla je nieuwe pagina op (File, en dan Save) en vul bij \u0026lsquo;file name\u0026rsquo; in resultaten.php Klik daaronder op je naam en klik onderaan op Save. Klik weer op \u0026lsquo;play\u0026rsquo;. Rekenen met PHP De informatie die iemand invult, wordt door PHP opgeslagen in variabelen. Variabel betekent dat iets steeds anders kan zijn. In dit geval kan de variabele \u0026lsquo;leeftijd\u0026rsquo; 4 zijn of 12, maar ook 125 of zelfs een woord zoals \u0026lsquo;slagroomtaart\u0026rsquo;.\nJe kunt ook rekenen met die variabelen.\nDus stel dat iemand heeft ingevuld dat ze 12 is, dan kunnen we uitrekenen wat haar geboortejaar is.\nVoeg deze regels toe aan resultaten.php:\n\u0026lt;?php $leeftijd = $_REQUEST[\u0026#34;leeftijd\u0026#34;]; $jaar = 2018; echo \u0026#34;\u0026lt;p\u0026gt;Dat betekent dat je geboren bent in \u0026#34;; echo $jaar - $leeftijd; echo \u0026#34;.\u0026lt;/p\u0026gt;\u0026#34;; ?\u0026gt;  En bekijken het resultaat door deze pagina op te slaan en je eerste pagina weer te starten.\nVoeg nu zelf de code toe om met PHP te laten zien hoeveel centimeter deze vriend of vriendin langer of korter is dan jij bent. Informatie bewaren: cookies Informatie verzamelen met formuleren en die gegevens opslaan in variabelen is leuk, maar het probleem is dat die informatie weg is als je de browser sluit of naar een andere website gaat. Je bezoeker zal dus elke keer dat hij of zij terugkomt opnieuw het formulier moeten invullen.\nWe kunnen dat voorkomen door de informatie op te slaan in cookies (het Engelse woord voor koekjes).\nZet deze code bovenaan in resultaten.php:\n\u0026lt;?php $_COOKIE[\u0026#39;bezoek\u0026#39;]++; setcookie(\u0026#39;bezoek\u0026#39;, $_COOKIE[\u0026#39;bezoek\u0026#39;]); ?\u0026gt;  Het werkt alleen als je deze code vóór  zet, dus dat er niks voor de code naar de browser wordt gestuurd om te laten zien. Zet nu deze regel onderaan de pagina, net boven : \u0026lt;small\u0026gt; Je hebt deze pagina nu \u0026lt;?=$_COOKIE[\u0026#39;bezoek\u0026#39;]?\u0026gt; keer bekeken. \u0026lt;/small\u0026gt; \n[de -code maakt de tekst iets kleiner dan de rest]\nVernieuw de pagina een paar keer en je zult zien dat de informatie uit de cookie steeds opnieuw wordt bijgewerkt en onthouden.\nZoals het er nu staat, wordt de cookie ook weer weggegooid als de bezoeker de browser afsluit. Als je wil dat hij of zij de informatie nog wat langer zal kunnen zien, dan moet je de cookie zo opslaan: setcookie(\u0026#39;bezoek\u0026#39;, $_COOKIE[\u0026#39;bezoek\u0026#39;], time() + 600000); \nOp die manier blijft de informatie bewaard tot 600.000 seconden na nu, oftewel een week.\nInformatie bewaren: tekstbestandjes Als we echt een vriendenboek willen maken, dan moet de site informatie kunnen opslaan, zodat jij de informatie van je vrienden ook kunt lezen.\nProgrammeurs die websites bouwen, gebruiken meestal een database om informatie te bewaren, maar je kunt daar ook een simpel tekstbestandje voor gebruiken.\nDat werkt als volgt. In resultaten.php, onder de regel met setcookie, zetten we de antwoorden uit het formulier achter elkaar en zetten we die in een tekstbestandje:\n$tekstbestandje = \u0026#39;/tmp/vrienden.txt\u0026#39;; $antwoorden = $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#34;;\u0026#34; . $_REQUEST[\u0026#34;leeftijd\u0026#34;] . \u0026#34;;\u0026#34; . $_REQUEST[\u0026#34;lengte\u0026#34;] . \u0026#34;\\n\u0026#34;; file_put_contents($tekstbestandje, $antwoorden, FILE_APPEND);  [Met de punt (.) plakken we in PHP variabelen en tekst aan elkaar. De \\n op het eind zorgt ervoor dat er na deze rij een nieuwe regel komt.]\n[FILE_APPEND zorgt ervoor dat we steeds een nieuwe regel toevoegen aan het tekstbestandje, in plaats van dat de antwoorden het enige zijn dat erin komt te staan]\nVoeg je eigen variabelen toe aan $antwoorden (die van de extra vragen die je in het formulier hebt gezet). Zorg er wel voor dat er steeds weer een puntkomma tussen komt te staan, want zo houden we de variabelen uit elkaar.\nTekstbestand lezen Nu gaan we een pagina maken waar je ziet wie jouw vragenlijst hebben ingevuld.\nGa bij CodeAnywhere naar File en klik op \u0026lsquo;New file\u0026rsquo;. Zet deze code erin om het tekstbestand te lezen en te laten zien wat erin staat:\n\u0026lt;html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Vrienden\u0026lt;/h1\u0026gt; \u0026lt;?php $tekstbestand = fopen(\u0026#34;/tmp/vrienden.txt\u0026#34;, \u0026#34;r\u0026#34;); while( ! feof($tekstbestand) ) { $vriend = explode(\u0026#34;;\u0026#34;, fgets($tekstbestand)); echo $vriend[0] . \u0026#34; is \u0026#34; . $vriend[1] . \u0026#34; jaar en $vriend[2] cm lang.\u0026lt;br\u0026gt;\u0026#34;; } fclose($tekstbestand); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  [Het uitroepteken betekent \u0026lsquo;niet\u0026rsquo;, feof betekent \u0026lsquo;het eind van het bestand\u0026rsquo; en fgets betekent \u0026lsquo;haal een nieuwe regel van het bestand op\u0026rsquo;. Hier staat dus: laat een nieuwe regel zien zolang we nog niet onderaan het tekstbestand zijn.]\n[Met \u0026lsquo;explode\u0026rsquo; hakken we de regel in stukjes. Waar een puntkomma staat begint een nieuwe variabele. $vriend wordt zo een lijst en dat noemen we in PHP een array. De lijst is genummerd en begint bij 0, en daarom vinden we de naam met $vriend[0]. ]\nSla je nieuwe pagina op (File, en dan Save) en vul bij \u0026lsquo;file name\u0026rsquo; in vrienden.php Klik daaronder op je naam en klik onderaan op Save. Klik weer op \u0026lsquo;play\u0026rsquo;.\nGa naar je nieuwste pagina door achter het webadres /vrienden.php te zetten en op enter te drukken.\nHet adres zou er ongeveer zo uit moeten zien:\nhttp://jaap-jaap433627.codeanyapp.com/vrienden.php\nAls je ziet wat je zelf daarstraks hebt ingevuld in het formulier, dan werkt het! Ga terug naar de eerste pagina om het formulier nog een paar keer in te vullen, om alles te testen.\nJaren en dagen Dit deel is nog niet af :(\n[Aantal dagen uitrekenen tot je verjaardag, hoeveel dagen je al leeft, hoeveel Saturnus-jaren je al bent, hoeveel dagen je ouder of jonger bent dan je vriend. \u0026gt; formulier aanpassen zodat we ook de dag van de maand en de maand hebben voor de geboortedatum \u0026gt; Datetime-object maken \u0026gt; link naar info over rekenen met data (zodat we ook leren hoe je documentatie over functies kunt vinden op PHP.org) ]  Hyperlinks Dit deel is nog niet af :(\n[unordered list maken met voor elke vriend een aparte link naar een nieuw bestand, waar we alle info laten zien over die vriend op basis van de meegegeven naam-parameter. Op die pagina moeten we dus met while en if bekijken welke regel van het bestand we moeten gebruiken.]  Plaatjes maken met PHP Dit deel is nog niet af :(\n[plaatje met lievelingskleur genereren \u0026gt; formulier aanpassen zodat we ook de lievelingskleur weten \u0026gt;  To do:  een mail sturen sturen met iemands eigen url (zou je ook kunnen doen als iemand jarig is of een nieuwe entry wordt gedaan) mensen in laten loggen met een wachtwoord tekst aanpassen aan of het ochtend of middag is  Vervolg Meer informatie:\n https://stackoverflow.com/questions/441087/php-exercises https://www.phphulp.nl/php/tutorial/overig/php-beginners-handleiding/575/variabelen/1482/ https://www.phphulp.nl/php/tutorials/php-functies/6/ https://www.w3resource.com/php-exercises/php-basic-exercises.php  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"November 18, 2020","permalink":"/instructies/web-development-php/","title":"Web - Development - Php"},{"categories":null,"contents":"Er zijn een paar verschillende talen die samen voor een belangrijk deel bepalen wat er op websites staat (HTML), hoe ze eruit zien (CSS) en hoe ze werken (JavaScript).\nIntroductie Deze instructies leggen eerst de basisonderdelen van HTML uit, en gaan daarna in op CSS en JavaScript. Afhankelijk je ervaring met deze talen kun je het best bij het begin starten, of ervoor kiezen dit over te slaan. De instructies bestaan uit een deel uitleg met tussendoor opdrachten om te oefenen met alle onderdelen.\nBenodigdheden Voor deze instructies gebruiken we Visual Studio Code (VS Code) om de code te schrijven, en om het resultaat te bekijken. Download en installeer eerst VS Code: Download Visual Studio Code\n Ga nu naar het Extensions menu. Zoek naar de extensie HTML Preview. Installeer de extensie en herstart VS Code.  Om een html-pagina te laten zien in VS Code moet je op het preview icoon klikken, dit bevindt zich rechtsboven in het scherm (let op: het is alleen zichtbaar als je een bestand van het soort .html open hebt, niet bij bijvoorbeeld een .txt bestand):\nJe bent nu klaar om te beginnen met de instructies!\nOnderdelen van een HTML-pagina (basis) Structuur van een pagina Websites worden geschreven in de taal van het internet: HTML. Er zijn veel verschillende \u0026ldquo;woorden\u0026rdquo;, of \u0026ldquo;bouwblokken\u0026rdquo;, in HTML. Een aantal van de meest gebruikte leer je hier kennen.\nEen HTML-pagina heeft een paar standaard onderdelen:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Dit is een kop\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Dit is een alinea.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  HTML onderdelen worden aangegeven met tags: de naam van het onderdeel tussen \u0026lt;\u0026gt; haakjes. De meeste onderdelen hebben een start en een eind tag. De eind tag heeft een forward slash dus / voor de naam, bijvoorbeeld \u0026lt;/html\u0026gt;. Tags worden altijd geschreven met kleine letters.  Opdracht Kopieer en plak de basisonderdelen in een nieuw bestand en sla dit op als html-bestand (bijvoorbeeld ninja.html). Let op: pas nadat je het bestand hebt opgeslagen krijgt de tekst ook verschillende kleuren. Als je deze kleuren niet ziet kan het zijn dat je het bestand als tekst, dus eindigend op .txt hebt opgeslagen. Zet nu ook de preview aan. Het resultaat zou er ongeveer zo uit moeten zien:\nDit is een kop Dit is een alinea.\n De standaard onderdelen  \u0026lt;html\u0026gt;: dit is het hoofdonderdeel van een pagina. Alle andere onderdelen komen binnen de \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;head\u0026gt;: binnen dit onderdeel wordt informatie over de pagina gezet, bijvoorbeeld de titel. \u0026lt;body\u0026gt;: binnen dit onderdeel staat alle tekst die zichtbaar is op de pagina, in het voorbeeld een kop \u0026lt;h1\u0026gt; en een alinea \u0026lt;p\u0026gt;.  Opdracht Voeg eens een alinea met als tekst je naam in de \u0026lt;body\u0026gt; van de pagina toe. Zie je je naam verschijnen?\nKoppen Om verschillende niveau\u0026rsquo;s aan te geven op een pagina kun je koppen gebruiken. Hiervoor zijn de \u0026lt;h1\u0026gt;, \u0026lt;h2\u0026gt;, \u0026lt;h3\u0026gt; (enzovoort) tags. Met deze tags kun je je pagina een duidelijke indeling geven, zoals je kunt zien in het voorbeeld hierboven.\nOpdracht Tot hoe ver gaan de niveau\u0026rsquo;s eigenlijk? Bestaat \u0026lt;h20\u0026gt;?\nOpdracht Maak een pagina die er zo uitziet:\nHeelal Melkwegstelsel Zonnestelsel Aarde  De stijl van tekst Je kunt op een aantal manieren tekst extra benadrukken: door woorden dik te maken, of schuin. Hiervoor kun je bijvoorbeeld de tags \u0026lt;b\u0026gt; (voor dik) en \u0026lt;i\u0026gt; (voor schuin) gebruiken. Een aantal andere tags om extra effect aan je tekst te geven zijn \u0026lt;mark\u0026gt; en \u0026lt;del\u0026gt;. De HTML-code\nDit is \u0026lt;b\u0026gt;dik\u0026lt;/b\u0026gt; wordt dus\nDit is dik  Opdracht Gebruik de onderdelen die hierboven genoemd zijn eens uit en maak deze zin na (zet deze bijvoorbeeld onder de kop Aarde):\nDe dikke gele bij vloog schuin over mijn kop hoofd.  Links Een superbelangrijk onderdeel van webpagina\u0026rsquo;s zijn natuurlijk links die verwijzen naar andere pagina\u0026rsquo;s, op dezelfde site of op een andere. Denk maar eens aan zoekmachines! Voor het maken van een link gebruik je de \u0026lt;a\u0026gt; tag. Het adres van de link, dus waar deze naar verwijst, voeg je toe door het attribuut href in de tag te zetten met als waarde het adres, op deze manier:\n\u0026lt;a href=\u0026#34;https://scratch.mit.edu\u0026#34;\u0026gt; Opdracht Probeer op deze manier maar eens een link naar je favoriete website te maken. Let op: vergeet niet de aanhalingstekens om het adres van de website.\nZie je de link niet? Dat komt omdat je nog niets hebt toegevoegd om op te klikken! Dit komt tussen de start- en eindtag en mag tekst zijn, maar ook bijvoorbeeld een afbeelding.\nOpdracht Maak op de pagina een link naar je favoriete website met de tekst \u0026ldquo;Mijn favoriete website!\u0026rdquo; (let op: de tekst is dik gedrukt, hoe moest dat ook weer?). Werkt de link? Tip: zet in de link https:// voor de naam van de website.\nPlaatjes Met alleen maar tekst zouden veel websites er maar saai uit zien. Plaatjes kun je toevoegen aan je pagina met de \u0026lt;img\u0026gt; tag. Ook hier heb je weer een attribuut nodig, dat heet src (van source, Engels voor bron):\n\u0026lt;img src=\u0026#34;naam-van-het-plaatje.png\u0026#34;\u0026gt; Opdracht: Pas de link van de vorige opdracht zo aan dat je het CoderDojo logo hieronder gebruikt in plaats van de tekst die er staat. Download Hiervoor het plaatje en sla het op in de map waar ook je html-pagina staat. Werkt de link nu ook weer? Let op: je moet de hele naam van het plaatje gebruiken, in dit geval is het een png-bestand.\nStijl toevoegen met CSS (basis) Zonder stijl heeft tekst op een webpagina een standaardkleur (zwarte letters op een witte achtergrond), standaardgrootte en standaardlettertype. Je kunt eindeloos variëren met stijl, en er zijn verschillende manieren om stijl toe te voegen aan je HTML.\nDe opdrachten in deze instructie beginnen met deze HTML-code:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; Dit is de best gestijlde regel HTML ooit! \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Hoewel, misschien is deze nog wel mooier... \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dit zou er in de preview zo uit moeten zien:\n Dit is de best gestijlde regel HTML ooit!  Hoewel, misschien is deze nog wel mooier...  Stijl toevoegen De makkelijkste manier om stijl toe te voegen aan je HTML is door een style attribuut toe te voegen aan een HTML-element, bijvoorbeeld:\n\u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;Wat zou de kleur van deze tekst zijn?\u0026lt;/p\u0026gt; In dit voorbeeld is color de eigenschap die je wilt instellen, namelijk de kleur van de tekst. De waarde die je de tekst geeft is hier red, dus rood.\nSpelen met kleur De kleur van tekst bepaal je met de eigenschap color: \u0026lt;p style=\u0026quot;color:green\u0026quot;\u0026gt;. Kleuren instellen kan op verschillende manieren, bekijk hiervoor het onderdeel :ref:html-kleuren.\nOpdracht Maak de tekst van de eerste alinea groen, en die van de tweede paars:\nDit is de best gestijlde regel HTML ooit!\nHoewel, misschien is deze nog wel mooier...\n Je kunt niet alleen de kleur van de tekst zelf, maar ook de achtergrond veranderen, dit doe je met de eigenschap background-color: \u0026lt;p style=\u0026quot;background-color:....\u0026quot;\u0026gt;.\nOpdracht Maak de tekst van de eerste alinea rood met een zwarte achtergrond, en die van de wit met een oranje achtergrond:\nDit is de best gestijlde regel HTML ooit!\nHoewel, misschien is deze nog wel mooier...\n Tekstgrootte aanpassen Eén manier om letters van verschillende grootte te maken is door :ref:koppen te gebruiken. Dat is niet altijd handig (waarom is nu niet belangrijk) en het kan ook met de eigenschap font-size. Een voorbeeld:\n\u0026lt;p style=\u0026#34;font-size:25px\u0026#34;\u0026gt;Groot!\u0026lt;/p\u0026gt; geeft dit resultaat\nGroot!\n In dit voorbeeld is px gebruikt om aan te geven hoe groot de tekst moet zijn, dit is de grootte in pixels op het scherm. Je kunt ook procenten gebruiken, waarbij 100% de \u0026ldquo;standaard\u0026rdquo; grootte is: \u0026lt;p style=\u0026quot;font-size:100%\u0026quot;\u0026gt;.\nOpdracht Maak de eerste zin van je pagina zo groot dat ie nog net op één regel past, en de tweede zo klein dat je \u0026rsquo;m nog nét kunt lezen.\nVerschillende soorten letters gebruiken Naast de kleur en de grootte kun je ook nog het soort letters veranderen. Dit doe je met de eigenschap font-family: \u0026lt;style=\u0026quot;font-family:naam,backup-naam\u0026quot;\u0026gt;\nJe ziet dat er naam en backup-naam als waarde staat ingevuld. De soort letter backup-naam is niet verplicht, maar wordt gebruikt als de computer de soort letter naam niet kent. Een voorbeeld:\n\u0026lt;p style=\u0026#34;font-family:broadway,serif\u0026#34;\u0026gt;Broadway is niet zo goed te lezen.\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-family:verdana,sans-serif\u0026#34;\u0026gt;Verdana een stuk beter.\u0026lt;/p\u0026gt; geeft dit resultaat\nBroadway is niet zo goed te lezen.\nVerdana een stuk beter.\n Stijlen combineren Je kun meer dan één eigenschap tegelijk instellen door ze met een punt-komma achter elkaar te zetten, bijvoorbeeld: \u0026lt;p style=\u0026quot;color:red;font-size:20px\u0026quot;\u0026gt;\nOpdracht Combineer nu in de twee zinnen verschillende kleuren, lettergroottes en soorten letters. Leef je uit!\nToegankelijkheid Je hebt nu gezien dat je tekst op je webpagina er op heel veel verschillende manieren kunt laten uitzien. Dat het kán betekent natuurlijk nog niet dat het ook móét! Om te zorgen dat websites ook voor mensen die bijvoorbeeld minder goed zien te gebruiken zijn is het belangrijk (en voor sommige websites verplicht!) om bijvoorbeeld\n de letters groot genoeg te maken de kleur van de letters en die van de achtergrond verschillend genoeg te maken genoeg ruimte tussen regels tekst te laten.  Actie toevoegen met JavaScript (basis) De HTML die je net hebt geleerd is statisch. Om hier acties aan toe te voegen, zoals het klikken van een knop gebruiken we JavaScript (JS). Net zoals HTML kent ook JS veel verschillende \u0026ldquo;woorden\u0026rdquo;. Hier behandelen we er een aantal.\nToevoegen aan een HTML bestand JS wordt voor HTML bestanden geschreven in een speciaal blok:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; JavaScript code hier! \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dit ziet er als volgt uit met code (De code wordt verder toegelicht):\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; const telOp = function(getal1, getal2) { return getal1+getal2; } const resultaat = telOp(1,2); console.log(resultaat); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Functies Een functie in JS ziet er als volgt uit:\nconst telOp = function(getal1, getal2) { return getal1+getal2; }  Hierbij zie je dat function aangeeft dat het een \u0026lsquo;functie\u0026rsquo; is. Vervolgens geven we de parameters op. Bij ons zijn dat getal1 en getal2. Als laatst gebruiken we deze twee variabelen om een optelling te doen. We geven dit getal terug door return te gebruiken.\nAls we dit stukje code als volgt aanroepen:\nconst resultaat = telOp(1,2); console.log(resultaat)  Dan zien we dat er 3 wordt geprint! We slaan hierbij het resultaat op in resultaat en printen die vervolgens met console.log(). Om nu de output te zien van de console.log() functie moeten we de console openen. Je kunt dit doen op verschillende manieren:\nWindows:\n F12 Rechtermuisknop + inspecteer Control+Shift+J  MacOs:\n Command+Option+J  Variabelen Variabelen in JS gebruiken net als andere talen een speciale syntax. In JS kennen we var, const en let. Een goede tip om problemen tegen te gaan is om alleen const en let te gebruiken.\nconst gebruiken we als een variabelen niet meer veranderd, en let als we de variabelen later nog aan willen passen.\nEen variabele resultaat maken doen we als volgt:\nlet resultaat = 6; //Zo  const resultaatConst = 6; //Of zo  In variabelen kunnen we data opslaan, dat is heel handig!\nVoorbeeld 1: Knop Bij een knop gaan we HTML en JS combineren!\nOpdracht Zorg allereest dat je een HTML pagina hebt met een knop.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Wat gebeurt er nu als je op de knop klikt?\nOpdracht Om nu interactie toe te voegen aan de knop gaan we JS en html combineren.\n Op de knop kunnen we de volgende HTML toevoegen: onclick=\u0026rdquo;\u0026quot;. Nu werkt het echter nog niet..! Nu moeten we een JS functie schrijven die de knop aan gaat roepen, weet jij nog waar dit moet staan in het HTML bestand?:  const buttonClicked = function() { alert(\u0026#34;Je hebt op de knop geklikt!\u0026#34;); }   Als laatste gaan we deze twee elementen aan elkaar koppelen door de onclick=\u0026rdquo;\u0026quot; aan te passen (Hier moet je wel de JS nog toevoegen!):  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;buttonClicked()\u0026#34;\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Voorbeeld 2: Een element toevoegen op de pagina We kunnen in JS nog veel meer doen dan interactie toevoegen, bijvoorbeeld aan knoppen. Ook kunnen we HTML toevoegen aan de HTML pagina!\nWe hebben hier een aantal functies voor in JS.\nconst element = document.getElementById(\u0026#34;\u0026lt;id\u0026gt;\u0026#34;); element.insertAdjacentHTML(\u0026#34;afterend\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;My text\u0026lt;/p\u0026gt;\u0026#34;);  Er zijn nog veel meer mogelijkheden, maar dit is een van de simpelste.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; const voegElementToe = function() { const element = document.getElementById(\u0026#34;mijnDivId\u0026#34;); element.insertAdjacentHTML(\u0026#34;afterend\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;My text\u0026lt;/p\u0026gt;\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;voegElementToe()\u0026#34;\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;mijnDivId\u0026#34;\u0026gt; Dit is een div\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Opdracht Kun jij nu met jouw kennis van JS en HTML een element toevoegen als je op een knop klikt?\nVoorbeeld 3: Reageren op berichten van een gebruiker Met de volgende HTML code hebben we een invoer veld waar de gebruiker iets in kan typen:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; #inputId { width: 300px; height: 40px; font-size: xx-large; } .container { display: flex; height: 100vh; justify-content: center; align-items: center; background-color: blue; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; //JavaScript code hier!  \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span\u0026gt; Wat is je naam? \u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;inputId\u0026#34;\u0026gt; \u0026lt;/input\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Als de gebruiker nu iets typt, zie je alleen de tekst staan. Er gebeurt verder nog niet zo veel. Kun jij ervoor zorgen dat de computer terugpraat?\n Voeg een knop toe aan de HTML pagina Als je op de knop klikt, log dan de text die in het input veld staat met console.log. Om de tekst uit het invoer veld te halen kun je gebruik maken van: const input = document.getElementById(\u0026quot;inputId\u0026quot;).value; Kun jij nu de computer Hallo \u0026lt;naam\u0026gt; laten zeggen? Je kan dit doen met de functie alert(), hier moet je nog wel text aan meegeven. Dit is een voorbeeld: alert(\u0026quot;Hoi Kevin!\u0026quot;)  Stijl toevoegen met CSS (vervolg) Maak voor de opdrachten in deze instructie een HTML-bestand met deze inhoud:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; /* hier komt je styling! */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Deze pagina gaan we stylen!\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Dit is een h2 kop\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Dit is ook een h2 kop!\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Wat zullen we met \u0026lt;span\u0026gt;deze\u0026lt;/span\u0026gt; alinea gaan doen?\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Deze alinea wordt nog mooier dan de vorige.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;De vorige alinea\u0026#39;s zijn \u0026lt;span\u0026gt;jaloers\u0026lt;/span\u0026gt; op mij.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Jaloers op mij zul je bedoelen!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tot nu toe heb je stijl toegevoegd door style=\u0026quot;...\u0026quot; te gebruiken in de HTML-onderdelen. Dat heeft voordelen en nadelen. Het is handig dat je meteen kunt zien hoe de inhoud van je webpagina eruit komt te zien. Minder handig is dat je aan ieder stukje HTML op deze manier een stijl moet toevoegen. Dat is én veel werk, én wordt al snel onoverzichtelijk als je veel stijlen hebt.\nHet is daarom gebruikelijk bij webpagina\u0026rsquo;s om de inhoud en stijl op verschillende plekken neer te zetten. Een manier om dit te doen is binnen het \u0026lt;style\u0026gt; onderdeel. De code binnen het \u0026lt;style\u0026gt; onderdeel ziet er wat anders uit dan je tot nu toe gezien hebt. Om tekst rood te maken gebruikte je\n\u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;Dit stukje tekst is rood\u0026lt;/p\u0026gt; Binnen \u0026lt;style\u0026gt; moet je deze code schrijven, een soort regel voor hoe de HTML zich moet gedragen:\np { color: red; } Opdracht Wat denk je dat er gebeurt als je dit stukje code in het \u0026lt;style\u0026gt; onderdeel zet? Probeer het eens. Had je gelijk?\nStijl toevoegen aan sommige, maar niet alle elementen Als je de opdracht van net hebt uitgevoerd, heb je gezien dat alle \u0026lt;p\u0026gt; onderdelen, dus alle alinea\u0026rsquo;s, rode tekst hebben. Dit is dus wat deze code doet:\n de eigenschap kleur krijgt de waarde rood voor alle \u0026lt;p\u0026gt; onderdelen  Maar stel nou dat je alleen bepaalde alinea\u0026rsquo;s rood wilt maken?\nClass Dat kan bijvoorbeeld door het HTML-onderdeel lid te maken van een zogenaamde class:\n\u0026lt;p class=\u0026#34;naamvandeclass\u0026#34;\u0026gt;Welke kleur is dit?\u0026lt;/p\u0026gt; In de CSS maak je een class door een punt aan het begin te gebruiken:\n.naamvandeclass { color: red; }  Opdracht Gebruik een class met de naam \u0026ldquo;rodealinea\u0026rdquo; om de 1e en 4e alinea rood te maken, dus zo:\n  .rodealinea { color: red; }    Deze pagina gaan we stylen! Dit is een h2 kop  Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\n  De vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\n    ID Een andere manier is om een HTML-onderdeel een uniek id te geven:\n\u0026lt;p id=\u0026#34;ikbenuniek\u0026#34;\u0026gt;Welke kleur is dit?\u0026lt;/p\u0026gt; In de CSS verwijs je naar een id door een hashtag aan het begin te gebruiken:\n#ikbenuniek { color: red; } Opdracht Maak de tekst van de eerste h1 kop blauw, en de 1e h2 kop groen (tip: je hebt hiervoor twee id\u0026rsquo;s nodig, \u0026ldquo;ikbenblauw\u0026rdquo; en \u0026ldquo;ikbengroen\u0026rdquo;):\n  .rodealinea { color: red; } #ikbenblauw { color: blue; } #ikbengroen { color: green; }    Deze pagina gaan we stylen! Dit is een h2 kop  Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\n  De vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\n    Samengevat heb je nu gezien dat je stijl kunt geven aan\n alle onderdelen van een bepaalde soort bepaalde onderdelen door ze lid te maken van een class losse onderdelen door ze een (uniek) id te geven  Combineren van stijlen Een grote kracht van CSS is dat je stijlen ook kunt combineren. Zo kun je meerdere eigenschappen tegelijk instellen in een CSS regel:\np { color: red; font-weight: bold; } Opdracht Voeg een tweede eigenschap toe aan de \u0026ldquo;rodealinea\u0026rdquo;, bijvoorbeeld background-color of font-family.\nJe kunt een onderdeel ook lid maken van meer dan één class (in dit voorbeeld heten die \u0026ldquo;rodealinea\u0026rdquo; en \u0026ldquo;box\u0026rdquo;):\n\u0026lt;p class=\u0026#34;rodealinea box\u0026#34; Opdracht Maak een class \u0026ldquo;box\u0026rdquo; die de eigenschap border instelt op 1px solid black, en voeg deze toe aan een van de rode alinea\u0026rsquo;s:\n  .rodealinea { color: red; } #ikbenblauw { color: blue; } #ikbengroen { color: green; } .box { border: 1px solid black; }    Deze pagina gaan we stylen! Dit is een h2 kop  Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\n  De vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\n    Actie toevoegen met JavaScript (vervolg) Nu je de basis van JS hebt gezien, gaan we wat verder met moeilijker onderdelen.\nEen klok maken We gaan een klok maken op een HTML pagina. Je kan de volgende HTML gebruiken:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; body { background: linear-gradient(45deg, #1870ed 0, #f18f88 100%); font-family: \u0026#39;Montserrat\u0026#39;, \u0026#39;sans-serif\u0026#39;; min-height: 100vh; display: flex; align-items: center; justify-content: center; } .clock-container { margin-top: 30px; margin-bottom: 30px; background-color: #080808; border-radius: 5px; padding: 60px 20px; box-shadow: 1px 1px 5px rgba(255, 255, 255, .15), 0 15px 90px 30px rgba(0, 0, 0, .25); display: flex; } .clock-col { text-align: center; margin-right: 40px; margin-left: 40px; min-width: 90px; position: relative; } .clock-col:not(:last-child):before, .clock-col:not(:last-child):after { content: \u0026#34;\u0026#34;; background-color: rgba(201, 166, 166, 0.3); height: 5px; width: 5px; border-radius: 50%; display: block; position: absolute; right: -42px; } .clock-col:not(:last-child):before { top: 35%; } .clock-col:not(:last-child):after { top: 50%; } .clock-timer { color: #fff; font-size: 4.2rem; text-transform: uppercase; } .clock-label { color: rgba(255, 255, 255, .35); text-transform: uppercase; font-size: 0.7rem; margin-top: 10px; } @media (max-width: 825px) { .clock-container { flex-direction: column; padding-top: 40px; padding-bottom: 40px; } .clock-col+.clock-col { margin-top: 20px; } .clock-col:before, .clock-col:after { display: none !important; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;clock-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-hours clock-timer\u0026#34; id=\u0026#34;clock-day\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Dag \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-hours clock-timer\u0026#34; id=\u0026#34;clock-hour\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Uren \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-minutes clock-timer\u0026#34; id=\u0026#34;clock-minute\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Minuten \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-seconds clock-timer\u0026#34; id=\u0026#34;clock-second\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Seconden \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //Hier moet jij je code gaan schrijven voor de clock!  let dagElement = document.getElementById(\u0026#34;clock-day\u0026#34;); let urenElement = document.getElementById(\u0026#34;clock-hour\u0026#34;); let minutenElement = document.getElementById(\u0026#34;clock-minute\u0026#34;); let secondenElement = document.getElementById(\u0026#34;clock-second\u0026#34;); const dagenInText = [\u0026#34;Zo\u0026#34;, \u0026#34;Ma\u0026#34;, \u0026#34;Di\u0026#34;, \u0026#34;Wo\u0026#34;, \u0026#34;Do\u0026#34;, \u0026#34;Vr\u0026#34;, \u0026#34;Za\u0026#34;]; function updateTime() { var today = new Date(); //Dit geeft je een datum terug,  //hier kun je de uren, minuten en seconden van halen.  //Met getHours() krijg je de uren  //Met getMinutes() krijg je de minuten  //Met getSeconds() krijg je de seconden  //De dag hebben wij voor je gedaan!  dagElement.innerText = dagenInText[today.getDay()]; urenElement.innerText = \u0026#34;1\u0026#34;; minutenElement.innerText = \u0026#34;1\u0026#34;; secondenElement.innerText = \u0026#34;1\u0026#34;; } //Dit voert de functie iedere seconde opnieuw uit,  //De tijd gaat natuurlijk met 1 seconde per keer vooruit!  setInterval(updateTime, 1000); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; De klok werkt nu nog niet.. Kan jij dit oplossen? In het \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; blok moet jij de code gaan aanpassen, daarmee kun je de klok weer aanslingeren ;) !\nHet instellen van kleuren op je webpagina Er zijn een een heel aantal manieren om een kleur in te stellen voor onderdelen van je pagina, bijvoorbeeld\n met namen_ \u0026lt;p style=\u0026quot;color:red\u0026quot;\u0026gt; met RGB-waarden_ \u0026lt;p style=\u0026quot;color:rgb(255, 0, 0)\u0026quot;\u0026gt; met HEX-waarden_ \u0026lt;p style=\u0026quot;color:#FF0000\u0026quot;\u0026gt;  Namen Er zijn 140 kleuren die een eigen naam hebben:\nRGB-waarden RGB staat voor Rood Groen Blauw. Dit is ook de volgorde waarmee je ze instelt in de code. De waarde gaat van 0 (helemaal niks van deze kleur) tot 255 (alles van deze kleur). Een paar voorbeelden:\n   RGB code Rood Groen Blauw Kleur     (0, 255, 0) 0 255 0 groen   (255, 0, 255) 255 0 255 magenta   (173, 216, 230) 173 216 230 lichtblauw    HEX-waarden  HEX is een afkorting voor hexadecimaal, wat een manier van tellen is die vaak wordt gebruikt bij computers. In plaats van de 10 cijfers (0 t/m 9) waar we meestal mee tellen tel je hier met 16 \u0026ldquo;cijfers\u0026rdquo;, namelijk 0 t/m 9 en A t/m F. De HEX code voor een kleur is zes cijfers lang: de linker twee bepalen hoeveel rood er in de kleur zit, de middelste twee hoeveel groen en de rechter twee hoeveel blauw. 00 is de laagste waarde (omgerekend 0), FF is de hoogste waarde (omgerekend 255). De zescijferige code staat in de HTML-code na een #.  De kleuren van de RGB-voorbeelden zijn in HEX code\n   HEX code Kleur     00FF00 groen   FF00FF magenta   ADD8E6 lichtblauw    Bronvermelding afbeeldingen  HTML logo by W3C CSS logo by Rudloff JS logo by Omed Habib SVG_Recognized_color_keyword_names by Monaneko  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 22, 2020","permalink":"/instructies/web-development/","title":"Web - Development"},{"categories":null,"contents":"Je gaat met Scratch een \u0026ldquo;space shooter\u0026rdquo; bouwen.\nBenodigdheden Deze opdrachten maak je met Scratch. Als je nog geen account had, maak dit dan eerst aan.\nZet in Scratch eerst de taal op Nederlands via de wereldbol linksboven.\nInleiding In deze opdracht ga je een \u0026ldquo;space shooter\u0026rdquo; spel bouwen, waarbij je een ruimteschip bestuurt dat meteorieten kapot moet schieten of ontwijken. Het spel is gebaseerd op dit project.\nDit zijn de stappen die je gaat programmeren:\n Laat een ruimteschip bewegen met de pijltjestoetsen Maak een bewegende achtergrond waardoor het lijkt alsof je door de ruimte vliegt Laat meteorieten verschijnen en naar het ruimteschip vliegen Zorg dat het ruimteschip op de meteorieten kan schieten  Als je hierna nog zin (en tijd) hebt dan zijn er nog allerlei uitbreidingen mogelijk, denk bijvoorbeeld aan het spel steeds iets moeilijker maken of geluid en andere special effects toevoegen.\nLaat een ruimteschip bewegen met de pijltjestoetsen Eerst moet je een sprite hebben voor je ruimteschip. Je kunt dit natuurlijk zelf ontwerpen, maar ook een bestaande sprite kiezen (bijvoorbeeld het Rocketship). Noem deze sprite ruimteschip.\nZorg er eerst voor dat de sprite niet te groot is ten opzichte van het speelveld. Je kunt dit doen door het blok maak grootte te gebruiken dat je vindt in het menu Uiterlijken. Speel een beetje met het percentage om de goede grootte te vinden. Zorg ook dat het ruimteschip in het midden onderaan begint door het op x = 0 te plaatsen (x loopt van links naar rechts) en y zo in te stellen dat het nog net in beeld is. Je programma zou er nu ongeveer zo uit moeten zien:\nwanneer groene vlag wordt aangeklikt maak grootte (25) % ga naar x: (0) y: (-150)  De beweging van het ruimteschip kun je op verschillende manieren programmeren. Je kunt bijvoorbeeld iedere keer bij het indrukken van pijltje links de sprite een stukje laten opschuiven. Bij dit spel gaat het iets anders: als je op een pijltjestoets drukt dan geef je het ruimteschip een bepaalde snelheid, die vervolgens weer naar 0 (dus stilstaan) gaat. Op deze manier zal het ruimteschip een mooie vloeiende beweging maken. Neem de volgende stappen:\n Maak een variabele x-snelheid aan (in het menu Variabelen). Zet deze snelheid aan het begin van het spel op 0. Verander de snelheid naar een getal groter dan 0 als pijltje rechts wordt ingedrukt, en kleiner dan 0 voor pijltje links. Verander vervolgens de (x-)positie van het ruimteschip met de waarde van de variabele x-snelheid. Laat de snelheid steeds iets verder afnemen tot deze uiteindelijk weer 0 is.  Tip 1: de laatste drie stappen in de lijst hierboven moet je in een herhaal blok zetten.\nTip 2: je kunt de snelheid bijvoorbeeld laten afnemen door er een getal van af te trekken. Een andere manier is om de waarde te vermenigvuldigen met een getal kleiner dan 1.\nKlik om te laten zien hoe je programma er nu ongeveer uit zou moeten zien.  wanneer groene vlag wordt aangeklikt maak grootte (25) % ga naar x: (0) y: (-150) maak [snelheid_x] (0) herhaal als \u0026lt;toets [pijltje links v] ingedrukt?\u0026gt; dan maak [snelheid_x] (5) end als \u0026lt;toets [pijltje rechts v] ingedrukt?\u0026gt; dan maak [snelheid_x] (-5) end verander x met: (snelheid_x) maak [snelheid_x] ((snelheid_x) * (0.9)) end    Maak een bewegende achtergrond Sla dit plaatje voor de achtergrond van het spel op je computer op:\nMaak door de volgende stappen te volgen een sprite van dit plaatje:\n Klik op het icoon voor een nieuwe sprite (rechtsonder, plaatje van de kat) en kies voor Upload sprite. Upload het ruimte-plaatje. Ga naar het tabblad Uiterlijken (linksboven, rechts naast het Code tabblad). Maak in de editor het plaatje net zo groot als het hele speelveld door het op te rekken.  Plaats de ruimte-achtergrond aan het begin van het spel in het midden van het speelveld. Vraag: wat zijn x en y dan?\nKlik om de code te bekijken  wanneer groene vlag wordt aangeklikt ga naar x: (0) y: (0)    Nu ga je de achtergrond laten bewegen zodat het net is of je schip door de ruimte vliegt. Vraag: als je wil dat je schip vooruit vliegt, welke kant moet de achtergrond dan op gaan?\nNet als bij de snelheid van je ruimteschip moet je hier een variabele maken, nu voor de \u0026ldquo;scroll\u0026rdquo; snelheid van de ruimte. Vervolgens verander je steeds de positie van de achtergrond met de snelheid die je hebt ingesteld. Vraag: moet je nu de x of de y veranderen? En moet x of y steeds groter worden? Of juist kleiner?\nKlik om de code te bekijken  wanneer groene vlag wordt aangeklikt ga naar x: (0) y: (0) maak [snelheid_scrollen] (4) herhaal verander y met ((snelheid_scrollen) * (-1)) end    Als je nu het programma start, dan zie je dat er twee dingen fout gaan:\n je achtergrond verdwijnt uit beeld en komt niet meer terug er verschijnt een steeds groter wit vlak!  Een manier om deze twee problemen op te lossen staat beschreven in deze afbeelding:\nWat je ziet is dat je voor deze manier twee achtergronden gebruikt: de sprite, en een kloon van de sprite. De blauwe pijl (1) geeft aan dat de sprite en kloon allebei naar beneden schuiven. De rode pijl (2) laat zien dat zodra een achtergrond beneden uit beeld is verdwenen, je deze moet verplaatsen naar boven het speelveld. Op deze manier zorg je ervoor dat je geen wit vlak meer zult zien! Je moet nu dus een stuk code schrijven dat als de sprite uit beeld is, deze weer naar boven verplaatst. En je moet deze code niet alleen voor de sprite zelf, maar ook voor de kloon van de sprite schrijven.\nTip 1: dit is best een lastig stuk code, probeer het daarom eerst eens alleen voor de sprite, en daarna ook voor de kloon.\nTip 2: denk even goed na over de waarde die y heeft als de achtergrond boven en onder het speelveld is.\nUiteindelijk is dit de code die zorgt voor een bewegende achtergrond.  wanneer groene vlag wordt aangeklikt ga naar x: (0) y: (0) maak een kloon van [mijzelf v] maak [snelheid_scrollen] (4) herhaal als \u0026lt;(y-positie)  (-340)\u0026gt; dan verander y met ((snelheid_scrollen) * (-1)) anders ga naar x: (0) y: (345) end end wanneer ik als kloon start ga naar x: (0) y: (345) maak [snelheid_scrollen] (4) herhaal als \u0026lt;(y-positie)  (-340)\u0026gt; dan verander y met ((snelheid_scrollen) * (-1)) anders ga naar x: (0) y: (345) end end    Laat meteorieten verschijnen en naar het ruimteschip vliegen Je hebt nu een ruimteschip dat door de ruimte vliegt en naar links en rechts kan bewegen. De hoogste tijd om de meteorieten te laten verschijnen! Dit ga je doen door steeds een nieuwe kloon van de \u0026ldquo;echte\u0026rdquo; sprite te maken.\nMaak eerst een nieuwe sprite door een plaatje van een meteoriet in Scratch te laden, er zelf een te tekenen of een bestaande sprite te gebruiken (bijvoorbeeld een bal). Noem de sprite meteoriet.\nHet belangrijkste wat deze sprite doet is het elke paar seconden (of zo snel als je wilt) maken van een kloon van zichzelf.\nKlik om de code te bekijken  wanneer groene vlag wordt aangeklikt herhaal wacht (4) sec. maak een kloon van (mijzelf v) end    Als je de sprite zelf niet ziet, dan komt dat omdat deze achter de bewegende achtergrond zit. Dat geeft niets want alleen de klonen moeten zichtbaar zijn, maar het is wat onhandig als je wil zien wat je code doet. Je kunt hiervoor het blok ga naar laag voorgrond toevoegen.\nOok als je de sprite en klonen wel ziet, gebeurt er nog vrij weinig. Dat komt omdat ze allemaal bovenop elkaar verschijnen. De volgende stap is dan ook om de klonen op allerlei plaatsen te laten verschijnen.\nTip 1: er is een speciaal wanneer ik als kloon start blok waar je deze code onder kunt zetten.\nTip 2: laat de meteorieten ergens bovenin verschijnen (dus zet y bijvoorbeeld op 180).\nTip 3: gebruik voor de x het blok willekeurig getal tussen \u0026hellip;.\nDe code voor een kloon zou er ongeveer zo uit moeten zien  wanneer ik als kloon start ga naar laag [voorgrond v] ga naar x: (willekeurig getal tussen (-200) en (200)) y: (180) verschijn    Je bent er bijna! De een-na-laatste stap is om de klonen naar beneden te laten bewegen. Je kunt hiervoor weer een variabele voor de beweegsnelheid maken, een herhaal blok waarin je elke keer de plek van de sprite een beetje verandert werkt ook goed.\nEn waarom ben je nu nog niet helemaal klaar? Omdat het slim is je klonen ook weer te laten verdwijnen als ze onderaan het veld zijn aangekomen. Op deze manier blijft het spel soepel lopen.\nDe code voor een kloon ziet er dan zo uit  wanneer ik als kloon start ga naar laag [voorgrond v] ga naar x: (willekeurig getal tussen (-200) en (200)) y: (180) verschijn herhaal tot \u0026lt; (y-positie)   Schieten op de meteorieten Het is tijd om de meteorieten uit de weg te ruimen. Kies of maak een sprite die de kogel wordt, en noem deze ook kogel. Laat vervolgens een kogel \u0026ldquo;uit\u0026rdquo; het ruimteschip komen (bijvoorbeeld als je op de spatiebalk drukt) en naar het ruimteschip vliegen.\nTip 1: de code voor deze sprite lijkt wat op die voor de meteoriet; ook hier moet je klonen maken en die naar de meteorieten laten bewegen.\nTip 2: het blok ga naar is handig om de startplek van de kogel te bepalen.\nTip 3: als de kogel niets raakt is het wel slim de kloon te verwijderen als deze uit beeld verdwijnt.\nCode om kogels af te schieten  wanneer groene vlag wordt aangeklikt verdwijn herhaal als \u0026lt;toets [spatiebalk v] ingedrukt?\u0026gt; dan maak een kloon van (mijzelf v) end end wanneer ik als kloon start verschijn ga naar laag [voorgrond v] ga naar (ruimteschip v) herhaal tot \u0026lt;raak ik (rand v)?\u0026gt; verander y met (10) end verwijder deze kloon    Winnen en verliezen Natuurlijk wil je ook punten verdienen wanneer je een meteoriet raakt met je kogels, en bijvoorbeeld weer verliezen wanneer het ruimteschip door een meteoriet geraakt wordt. Maak voor de puntentelling een variabele score aan en zet die op 0 aan het begin van het spel (doe dit bij de code voor het ruimteschip).\nNu moeten we nog een paar stukken code toevoegen, namelijk:\n om op te merken wanneer een een meteoriet door een kogel geraakt wordt om hierna de meteoriet en de kogel te laten verdwijnen om op te merken wanneer een meteoriet het ruimteschip raakt  Tip: de meeste code hoort bij klonen van de meteoriet sprite.\nCode voor het raken van een meteoriet met een kogel  wanneer ik als kloon start herhaal als \u0026lt; raak ik (kogel v)?\u0026gt; dan verander [score v] met (1) verwijder deze kloon end    Code voor het laten verdwijnen van de kogel (deze hoort bij de kogel sprite!)  wanneer ik als kloon start wacht tot \u0026lt; raak ik (meteoriet v)?\u0026gt; wacht (0.1) sec. verwijder deze kloon    Code voor het raken van het ruimteschip met een meteoriet  wanneer ik als kloon start herhaal als \u0026lt; raak ik (ruimteschip v)?\u0026gt; dan maak [score v] (0) verwijder deze kloon end    Dit was het, veel speelplezier!\nUitbreidingen Je kunt het spel natuurlijk nog veel mooier, spannender en moeilijker maken. Hier heb je alvast een lijstje met ideeën als je nog verder wil programmeren:\n zorg dat je minder vaak kogels kunt afschieten laat de meteorieten niet alleen naar beneden komen maar ook echt op je ruimteschip af laat de meteorieten sneller bewegen als je meer punten hebt gehaald voeg geluiden en andere effecten toe  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 6, 2020","permalink":"/instructies/scratch-space-shooter/","title":"Scratch - Space shooter"},{"categories":null,"contents":"Introductie Sluit de Arduino pas aan op de computer met de USB kabel nadat je een circuit hebt gebouwd. Haal de kabel er weer uit voor je iets verandert aan het circuit.\nDe onderdelen De Arduino Uno heeft een aantal verschillende aansluitingen: de voeding (plus en aarde), digitale in- en uitgangen, en analoge in-en uitgangen.  Met de voeding kun je het circuit dat je hebt gebouwd van stroom voorzien. Met de digitale in- en uitgangen kun je aan en uit opdrachten geven, bijvoorbeeld of een LED aan of uit moet staan. Dit zijn aansluitingen 2 t/m 13 Met de analoge ingangen kun je de waarden van bijvoorbeeld licht- of temperatuursensoren meten (die zijn niet beperkt tot 0 (uit) of 1 (aan). Dit zijn aansluitingen A0 t/m A5. Met de analoge uitgangen (dit zijn de digitale aansluitingen die gemerkt zijn met een ~) kun je bijvoorbeeld een LED harder of zachter laten branden.  Je kunt een circuit bouwen op een zogenaamd breadboard. Deze zijn er in allerlei soorten en maten. Op dit schema kun je zien welke gaatjes (elektrisch) met elkaar verbonden zijn. Opdrachten Code uploaden naar de Arduino Als je een stuk code hebt gemaakt in mBlock, klik je met de rechtermuisknop op het Arduino programma. De code die naar de Arduino geupload moet worden komt tevoorschijn. Klik nu op Upload naar Arduino. Voorbeeldopdracht 1: knipperende LED  Maak het volgende circuit (met behulp van een breadboard).  Schakel nu de LED in door de juiste output op HOOG te zetten. mBlock code     Nu wil je dat de LED daarna ook weer uit gaat. mBlock code     Er zit geen tijd tussen het aan- en uitgaan! mBlock code     Nu wil je dit blijven herhalen. mBlock code      Voorbeeldopdracht 2: metronoom (Grove kit)  Sluit het LCD scherm, de variabele weerstand en de buzzer aan op de juiste poorten. Laat de buzzer elke seconde (of zoiets) een geluidje maken. mBlock code     Lees de waarde van de variabele weerstand af om deze vervolgens te kunnen vertalen naar een snelheid voor de metronoom. mBlock code     Combineer nu de buzzer en variabele weerstand! mBlock code      Uitdagingen  Stoplicht met schakelaar Lichtkrant (Grove, met LCD schermpje) Licht- of donkerwijzer (met servo motor) Thermometer (met temperatuursensor)  Bronnen  https://www.arduino.cc/en/Tutorial/BlinkWithoutDelay Project: http://www.makeuseof.com/tag/arduino-traffic-light-controller/ Schakelaar: http://oscarromero-arduino.weebly.com/pull-down-weerstand.html https://github.com/josejuansanchez/37-in-1-arduino-sensor-kit/tree/master/001 https://github.com/Seeed-Studio/Sketchbook_Starter_Kit_for_Arduino http://wiki.seeed.cc/Grove_Starter_kit_for_Arduino_101/ Breadboard Elementen  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.   ","date":"August 29, 2020","permalink":"/instructies/mblock/arduino/","title":"mBlock - Arduino"},{"categories":null,"contents":"Introductie Voor je de mBot aanzet: de mBot eerst op de grond zetten of op de kop leggen!\nHou rekening met de beperkte ruimte: laat het vermogen van de wielen eerst gewoon op 50% staan.\nOok handig om te weten:\n Je kunt de taal instellen via de wereldbol. De volgende instructies gaan uit van Nederlandse blokken. Je vindt de mBot bij Apparaten; bij Sprites staan de afbeeldingen die je op het scherm ziet (in het voorbeeld dus de panda). Net als bij Scratch staan de blokken per soort bij elkaar. Neem even de tijd om te kijken wat voor blokken er in de verschillende menu\u0026rsquo;s staan. Waar vind je bijvoorbeeld de als\u0026hellip; dan\u0026hellip; blokken? Je kunt de mBot live programmeren terwijl deze met de computer verbonden is, of programma\u0026rsquo;s uploaden\u0026gt; naar het geheugen van de mBot. De live manier is makkelijk als je aan het uitproberen bent hoe dingen werken, na uploaden kun je de mBot loskoppelen van de computer.  De mBot met de computer verbinden  Start mBlock. Sluit de mBot aan met de USB-kabel en zet de robot aan. Verwijder bij het tabblad Apparaten eventuele andere robots, klik op toevoegen en kies dan de mBot. Klik nu op verbinden, begin met de Live stand. Test of de verbinding gelukt is, bijvoorbeeld door op dit element te (dubbel)klikken:  Je bent nu klaar om een programma te gaan schrijven!  De input en output van de mBot Voelen (met de sensoren) De mBot heeft een aantal sensoren om z\u0026rsquo;n omgeving te voelen.\n Ultrasoon: dit zijn de twee \u0026lsquo;ogen\u0026rsquo; voorop de mBot. De mBot gebruikt net als een vleermuis echo\u0026rsquo;s om voorwerpen te \u0026lsquo;zien\u0026rsquo;. Het ene oog stuurt een geluidje en het andere oog vangt de echo op. Lijnvolg: voor het voorwiel zitten twee sensoren die het verschil tussen licht en donker kunnen meten. Als de mBot over een lijn rijdt kan hij op deze manier zien of er een bocht aankomt. Lichtsterkte: bovenop (onder het plastic kapje) zit een sensor die meet hoe licht het in de ruimte is.  Doen (met de actuatoren)  Motoren: ieder wiel wordt met een aparte motor bestuurd. LEDs: bovenop (onder het plastic kapje) zitten twee LEDs die je elke kleur kunt maken die je wilt. Buzzer: ook onder het kapje zit een buzzer waarmee je de mBot verschillende hoogte tonen kunt laten maken.  Opdrachten Voorbeeldopdracht 1: een vierkant rijden Aangezien de mBot bij dit programma moet rijden is het verstandig je programma naar de mBot te uploaden en het programma te starten als deze op de grond staat. Je kunt het programma laten starten bij het aanzetten van de mBot; in dit voorbeeld start het programma als de knop bovenop wordt ingedrukt.\n De eerste stap is om de mBot een stuk vooruit te laten rijden. 50% van het vermogen is prima om mee te beginnen. Start het programma door op het zwarte knopje bovenop de mBot te drukken. mBlock code     Nu rijdt de mBot eindeloos door! Zorg dus dat deze na een paar seconden weer stopt met rijden. mBlock code     Laat nu de mBot een bocht maken. Probeer de tijd zo in te stellen dat ie rechtsaf (of linksaf) slaat. mBlock code     Dit stuk code wil je nu een aantal keer herhalen. mBlock code      Voorbeeldopdracht 2: sensorwaarden laten zien Om opdrachten te kunnen programmeren is het vaak handig om te weten wat de sensoren van de mBot meten. Om dit te kunnen zien moet je de gemeten waarde bewaren in een variabele. Kijk bijvoorbeeld wat de lichtsensor meet als je je hand bovenop de mBot houdt, of de ultrasoonsensor als je je hand heen en weer beweegt voor de mBot.\n Maak eerst een variabele aan voor lichtsterkte en/of afstand. Je kunt zelf kiezen of andere sprites deze variabele ook mogen zien en gebruiken. mBlock code     Wijs nu de waarde gemeten door de sensor toe aan deze variabele. Als je nu het programma uitvoert zie je dat linksboven in het scherm de gemeten waarde(n) getoond worden. \u0026ldquo;mBot:\u0026rdquo; voor lichtsterkte geeft aan dat deze variabele alleen voor de mBot beschikbaar is. mBlock code     De LEDs op de mBot kunnen beïnvloeden wat de lichtsensors meten, zet daarom eerst de LEDs uit. mBlock code     Waarschijnlijk wil je de waarde(n) van de sensor(s) meer dan één keer bepalen. Herhaal daarom deze stap. Vaak is het ook verstandig een kleine pauze na iedere herhaling in te bouwen. mBlock code      Voorbeeldopdracht 3: help, een muur! In deze opdracht is het de bedoeling om te voorkomen dat de mBot tegen de muur botst (nadat je \u0026rsquo;m er wel naar toe laat rijden natuurlijk).\n Begin weer met de mBot te laten rijden na het indrukken van de knop. mBlock code     Maak nu een voorwaarde waarbij de mBot bij een afstand van minder dan 20 centimeter stopt met rijden. mBlock code     Gebeurt er nu wat je wil? Zo niet, denk dan eens na waarom niet? Heb je een stukje code vergeten? mBlock code     Sla maar eens flink alarm met licht en geluid om duidelijk te maken dat de mBot bijna gebotst was! Natuurlijk kan dit op veel manieren, de voorbeeldcode is er daar één van. mBlock code      Uitdagingen Hier nog een paar uitdagingen waar je aan kunt werken. Ze beginnen makkelijk en worden steeds moeilijker.\nGa zelf aan de gang! Natuurlijk kun je zelf iets verzinnen voor de mBot, hier zijn wat ideeën voor als je inspiratie nodig hebt:\n Rijd een achtje (of extra moeilijk: een spiraal) Lichten aan in de tunnel Aan de slag als politieauto of ambulance Volg de lijn Ontwijk de voorwerpen Volg een voorwerp  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.   ","date":"August 29, 2020","permalink":"/instructies/mblock/mbot/","title":"mBlock - mBot"},{"categories":null,"contents":"In deze opdracht ga je een figuur uit Scratch laten bewegen met de micro:bit.\nLet op: dit kan op dit moment alleen als je een computer hebt met Windows 10 of Mac OS 10+ en met Bluetooth 4.0.\nVoorbereiding Wat heb je nodig:   een micro:bit\n  een USB kabel om de micro:bit aan te sluiten aan de computer\n  een batterij om de micro:bit los van de computer te kunnen gebruiken\n  Scratch 3 en de micro:bit met elkaar verbinden Om de micro:bit met Scratch te verbinden moet je twee dingen doen: een programmaatje installeren op je computer en een bestandje naar de micro:bit kopiëren. Volg de aanwijzingen op de Scratch Link pagina. Misschien handig: helemaal onderaan de pagina kun je de taal op Nederlands zetten.\nHet programma Stap 1: Scratch 3 Beta Ga naar de Scratch 3 Beta pagina, klik linksonder op het Scratch Extensions icoon en kies hier de micro:bit extensie. De micro:bit blokken worden nu onderaan toegevoegd en er wordt verbinding gezocht met de micro:bit, dit ziet er zo uit:\nStap 2: De Scratch kat besturen met de micro:bit Je bent nu klaar om een spelletje te maken met de micro:bit als controller. Je kunt bijvoorbeeld de Scratch kat (of een ander figuur natuurlijk) laten reageren wanneer je op een knopje drukt, of bijvoorbeeld de micro:bit naar een kant kantelt. Probeer deze blokken maar eens en kijk wat er gebeurt:\nDit is natuurlijk nog niet heel spannend, maar je ziet dat er eigenlijk niet echt verschil is of je nou toetsen op je toetsenbord of de micro:bit gebruikt.\nStap 3: De besturing wat \u0026ldquo;slimmer\u0026rdquo; maken Bij de blokken in de vorige stap zag je dat de Scratch kat nadat je de \u0026ldquo;A\u0026rdquo; knop had ingedrukt de hele tijd \u0026ldquo;Hallo!\u0026rdquo; bleef zeggen, en dat je de micro:bit steeds opnieuw naar links moest kantelen om de kat een stukje te laten bewegen. Dat kan handiger, en werkt op dezelfde manier als wanneer je gewoon de knoppen van je toetsenbord gebruikt. Door een herhaal te gebruiken samen met een als \u0026hellip; dan \u0026hellip; blok te gebruiken kun je steeds controleren of een knop is ingedrukt, de micro:bit wordt gekanteld, enzovoorts. Dan ziet je programma er bijvoorbeeld zo uit:\nJe kunt de verschillende als \u0026hellip; dan \u0026hellip; blokken natuurlijk ook in hetzelfde herhaal blok zetten.\nAls je de beweging van je figuur vloeiender wilt maken kun je bijvoorbeeld kijken naar deze instructies, waarbij je dan de toetsenbordknoppen moet vervangen door knoppen en bewegingen van de micro:bit. Je kunt ook spelen met kantelen naar voren en achteren, of schudden met de micro:bit.\nStap 4: Een spelletje bouwen Nu je de Scratch kat kunt laten bewegen met de micro:bit kun je hier een spelletje omheen bedenken. Heb je zelf geen ideeën? Vraag de mentoren of kijk eens hier:\n Onze andere Micro:Bit opdrachten Scratch projecten en zoek bijvoorbeeld op \u0026lsquo;platform\u0026rsquo; of \u0026lsquo;vliegen\u0026rsquo; (waarschijnlijk werkt dit alleen in Google Chrome) Google Drive van CoderDojo Zoetermeer met opdrachten op verschillende niveau\u0026rsquo;s.  Let op: deze opdrachten zijn wel voor Scratch 2 geschreven, als je daardoor dingen niet kunt vinden of niet snapt in Scratch 3 laat het de mentoren weten!\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/microbit-controller/","title":"Micro:Bit - Als controller in Scratch"},{"categories":null,"contents":"We gaan de Maqueen laten voelen en laten doen.\nIntroductie Voor je de Maqueen aanzet: de Maqueen eerst op de grond zetten! Hou rekening met de beperkte ruimte: laat het vermogen van de wielen eerst gewoon op 50% staan.\nOok handig om te weten (zie de cijfers in de afbeelding hierboven):\n Bij de instellingen kun je de taal aanpassen. Deze instructies gaan uit van Nederlandse blokken. Net als bij Scratch staan de blokken per soort bij elkaar. Neem even de tijd om te kijken wat voor blokken er in de verschillende menu\u0026rsquo;s staan. Waar vind je bijvoorbeeld de als\u0026hellip; dan\u0026hellip; blokken? Met de knop Downloaden zet je je programma op de micro:bit. Als je een fout hebt gemaakt en die wil herstellen dan klik je op het pijltje terug  De Maqueen met de computer verbinden  Start MakeCode. Voeg de Maqueen functies toe aan MakeCode door helemaal onderaan het menu met de blokken op Uitbreidingen te klikken. Plak deze url in de zoekbalk boven in het scherm dat nu verschijnt: https://github.com/MKleinSB/maqueen en klik op het plaatje dat verschijnt. Steek de micro:bit in de Maqueen. De knoppen en LEDjes moeten aan de voorkant zitten. Sluit de micro:bit met de USB-kabel op de computer aan. Je hoeft de Maqueen zelf nog niet aan te zetten. Klik nu op verbinden, begin met de Live stand. Test of de verbinding gelukt is door dit programma te maken en het naar de micro:bit te downloaden: De LED linksvoor zou nu moeten gaan branden. Je bent nu klaar om een eigen programma te gaan schrijven!  De input en output van de Maqueen Voelen (met de sensoren) De Maqueen heeft een aantal sensoren om z\u0026rsquo;n omgeving te voelen.\n Ultrasoon: dit zijn de twee \u0026lsquo;ogen\u0026rsquo; voorop de Maqueen. De Maqueen gebruikt net als een vleermuis echo\u0026rsquo;s om voorwerpen te \u0026lsquo;zien\u0026rsquo;. Het ene oog stuurt een geluidje en het andere oog vangt de echo op. De afstand die de sensor meet heet in MakeBlock Sensor eenheid. Lijnvolg: onderop, achter het voorwiel, zitten twee sensoren die het verschil tussen licht en donker kunnen meten. Als de Maqueen over een lijn rijdt kan hij op deze manier zien of er een bocht aankomt. Wat deze sensoren meten heet in MakeBlock Lees route geleiding. Infrarood: voorop, als een soort neusje, zit een infrarood sensor waarmee je de Maqueen bijvoorbeeld met een afstandsbediening kunt besturen.  Doen (met de actuatoren)  Motoren: ieder wiel wordt met een aparte motor bestuurd. LEDs: voorop zitten twee rode LEDs, onderop zitten 4 LEDs (NeoPixels) die je iedere kleur kunt maken die je wilt. Buzzer: net achter de micro:bit zit een buzzer waarmee je de Maqueen allerlei tonen kunt laten maken, en zelfs een beetje laten praten. Meer over de Maqueen kun je hier lezen (in het Engels).  MakeCode opdrachten Voorbeeldopdracht 1: een vierkant rijden  De eerste stap is om de Maqueen een stuk vooruit te laten rijden. 100 is een mooie snelheid om mee te beginnen. Laat de Maqueen gaan rijden als je op de linkerknop van de micro:bit drukt. Zet \u0026rsquo;m eerst op de grond! MakeCode code     Nu rijdt de Maqueen eindeloos door! Zorg dus dat deze na een paar seconden weer stopt met rijden. MakeCode code     Laat nu de Maqueen een bocht maken. Probeer de tijd zo in te stellen dat ie rechtsaf (of linksaf) slaat. MakeCode code     Nu wil je meer bochten maken. Probeer daar eens een herhaal-blok voor te gebruiken! MakeCode code      Voorbeeldopdracht 2: help, een muur! In deze opdracht is het de bedoeling om te voorkomen dat de Maqueen tegen de muur botst (nadat je \u0026rsquo;m er wel naar toe laat rijden natuurlijk).\n Begin weer met de Maqueen te laten rijden na het indrukken van de knop. MakeCode code     Maak nu een voorwaarde waarbij de Maqueen bij een afstand van minder dan 20 centimeter stopt met rijden. MakeCode code     Gebeurt er nu wat je wil? Zo niet, denk dan eens na waarom niet? Heb je een stukje code vergeten? MakeCode code oplossing 1    MakeCode code oplossing 2     Sla maar eens flink alarm met licht en geluid om duidelijk te maken dat de Maqueen bijna gebotst was! Natuurlijk kan dit op veel manieren, de voorbeeldcode is er daar één van. MakeCode code      Voorbeeldopdracht 3: knipperen op de zebra. In deze opdracht is het de bedoeling dat je de LEDs van de Maqueen aan laat gaan op het moment dat je over zwarte strepen rijdt. Je kunt hiervoor het best zwart tape gebruiken, stiften werken niet zo goed.\n Begin weer met de Maqueen te laten rijden na het indrukken van de knop. MakeCode code     Welke sensor kun je gebruiken om de zwarte strepen te herkennen? En welke waarde heeft de sensor als deze zwart ziet? Hint: je kunt de display van de micro:bit (de 25 LEDs) gebruiken om deze waarde te laten zien. MakeCode code     Gebruik deze waarde nu in een voorwaarde om de LED aan en uit te laten gaan terwijl je over de strepen rijdt. MakeCode code      Uitdagingen Hier nog een paar uitdagingen waar je aan kunt werken. Ze beginnen makkelijk en worden steeds moeilijker.\nGa zelf aan de gang! Natuurlijk kun je zelf iets verzinnen voor de Maqueen, hier zijn wat ideeën voor als je inspiratie nodig hebt:\n Rijd een achtje (of extra moeilijk: een spiraal) Lichten aan in de tunnel Aan de slag als politieauto of ambulance Volg de lijn Ontwijk de voorwerpen Volg een voorwerp  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/maqueen/","title":"Micro:Bit - Maqueen"},{"categories":null,"contents":"In deze opdracht ga je het spelletje steen-papier-schaar programmeren op de micro:bit, en dit spelen tegen iemand anders.\nVoorbereiding Wat heb je nodig:  een micro:bit (of twee) een USB kabel om de micro:bit aan te sluiten aan de computer een batterij om de micro:bit los van de computer te kunnen gebruiken  Het programma Stap 1: steen, papier en schaar tekenen Bij dit programma maken we gebruik van de LEDjes op de micro:bit. Hier kun je allerlei figuren op maken, teken nu eerst een steen, vel papier en een schaar.\nStap 2: een keuze maken De micro:bit gaat een van de drie kiezen. Hiervoor moet je een paar dingen programmeren.\n  Eerst heb je het blok pick random 0 to 10 voor nodig, dit vind je in het menu Wiskunde. Stel het blok zo in dat het drie getallen kan kiezen, namelijk 1, 2 of 3:   Maak nu een variabele aan om het gekozen getal een naam te geven en later weer te kunnen gebruiken. Noem het bijvoorbeeld \u0026ldquo;keuze\u0026rdquo;:   Geef nu deze variabele de waarde van het gekozen getal, en laat de micro:bit deze opdracht uitvoeren als je op de A knop van de micro:bit drukt:   Stap 3: het gekozen plaatje laten zien Je hebt nu een variabele keuze die het cijfer 1, 2 of 3 kan zijn, en drie plaatjes. Nu moet elk van de keuzes een ander plaatje laten zien: 1 = steen, 2 = papier en 3 = schaar.\nGebruik hiervoor het blok als \u0026hellip; dan \u0026hellip; blok en het \u0026hellip; = \u0026hellip; blok uit het menu Logisch:\nAls je het programma hierboven uitvoert laat de micro:bit alleen een plaatje zien als keuze 1 is, voeg daarom nu ook de andere twee plaatjes toe.\nAls iemand anders nu ook het steen-papier-schaar programma op een micro:bit zet dan kun je het tegen elkaar spelen!\nStap 4: een bericht sturen en ontvangen Als je nog tijd over hebt en het programma nog verder wilt uitbreiden dan kun je proberen de micro:bits met elkaar te laten praten. Als de micro:bits hun keuze naar elkaar sturen kunnen ze de keuzes vergelijken en zelf ook zien wie er gewonnen heeft.\nMicro:bits praten met elkaar via de radio. Ze kunnen bijvoorbeeld woorden of getallen naar elkaar sturen, en je kunt de micro:bit programmeren om een opdracht uit te voeren bij het ontvangen van een bericht.\nBij steen-papier-schaar sturen de micro:bits de waarde van keuze naar elkaar toe (pijl 1). Wacht voor je je keuze naar de andere micro:bit stuur eerst even (pijl 2), anders verdwijnt je plaatje meteen weer:\nOm een bericht te kunnen ontvangen moeten micro:bits op hetzelfde kanaal sturen en ontvangen (net als bijvoorbeeld bij een walkie-talkie):\nStap 5: de winnaar bekend maken De micro:bit kan nu de keuze van de ander ontvangen, maar doet er nog niks mee. Om de eigen keuze met die van de andere te vergelijken om te kijken wie er gewonnen heeft gebruik je weer een als \u0026hellip; dan \u0026hellip; blok uit het menu Logisch, waarbij er natuurlijk een boel verschillende combinaties zijn!\n Speler 1 heeft steen en speler 2 ook: gelijkspel! Speler 1 heeft steen en speler 2 heeft schaar: speler 1 wint! Speler 1 heeft steen en speler 2 heeft papier: speler 2 wint! Enzovoorts  In het voorbeeld hieronder zie je dat je moet kijken naar het receivedNumber, het ontvangen nummer dus de keuze van de andere micro:bit.\nEr zijn alvast twee gevallen geprogrammeerd:\n dat waarbij de micro:bits allebei dezelfde keus maakten: dan is \u0026ldquo;keuze\u0026rdquo; gelijk aan receivedNumber dat waarbij de eigen keuze steen was (getal 1) en dat van de ander papier (getal 2). Deze micro:bit heeft dan dus verloren.  Programmeer nu zelf de rest van de mogelijkheden.\nStap 6: tot drie tellen voor je het plaatje laat zien Om het nog even spannend te houden kun je de micro:bit eerst nog tot drie laten tellen voor je de keuze laat zien. Hier heb je een x keer herhalen blok voor nodig uit het menu Lussen en het toon nummer blok uit het menu Basis:\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/steen-papier-schaar/","title":"Micro:Bit - Steen-papier-schaar"},{"categories":null,"contents":"In deze opdracht ga je een stoplicht maken.\nHet stoplicht heeft twee kleuren: groen en rood. Normaal staat het stoplicht op rood. Als je op een knopje drukt springt het op groen, en na een tijdje weer op rood. Als dit gelukt is kun je het programma zo aanpassen dat het stoplicht op groen springt als er een auto over de micro:bit heen \u0026ldquo;rijdt\u0026rdquo;, bijvoorbeeld door je hand erboven te houden.\nVoorbereiding Wat heb je nodig:  een micro:bit een USB kabel om de micro:bit aan te sluiten aan de computer een rode en een groene LED vier \u0026ldquo;krokodillenbekken\u0026rdquo;  Alles aansluiten Net als batterijen hebben LED lampjes een plus en een min. Als je goed kijkt zijn de pootjes van de LED\u0026rsquo;s niet even lang: het net iets langere pootje is de plus, de kortere de min. Gebruik de krokodillenbekken om de plussen van de rode en groene LED vast te maken op aansluitingen Pin 0 en Pin 1 van de micro:bit, en de minnen aan de GND (je kunt de eerste krokodillenbek aan GND vastmaken en de tweede aan de eerste). Het zou er dan ongeveer zo uit moeten zien:\nHet programma Stap 1: Een LED aanzetten Om een LED aan te zetten moet je stroom laten lopen van de plus-aansluiting door de LED naar de min. Dit doe je met het blok schrijf digitaal pin \u0026lt;P0\u0026gt; naar 0. Dit vind je door op Geavanceerd (zie pijl 1) te klikken en daarna op Pinnen (pijl 2), zie het plaatje hieronder. Laat de LED aan gaan wanneer je op knop A drukt.\nStap 2: De LED weer uit laten gaan Je hebt er weinig aan als de LED de hele tijd aan blijft. Deze moet dus na een tijdje weer uit. Wacht na het aanzetten bijvoorbeeld een seconde (1000 ms) en zet de LED dan weer uit door Pin 0 weer op 0 te zetten:\nStap 3: Het stoplicht staat op rood, tot je op de knop drukt Nu is het tijd om allebei de LEDs te gebruiken: de rode moet eigenlijk altijd aan zijn, behalve wanneer op knop A wordt gedrukt. Dit doe je door bij het opstarten de rode LED al aan te zetten, en deze uit te zetten op het moment dat de groene LED aan gaat:\nStap 4: de knop vervangen door een “auto” Als extra uitdaging kun je nu het indrukken van knop A vervangen door wat er gebeurt als de micro:bit in het donker terecht komt doordat er een auto overheen rijdt. Hiervoor heb je het blok lichtniveau uit het menu Invoer nodig, en moet je kijken hoeveel licht (een getal tussen 0=helemaal donker en 255=heel licht) de micro:bit ziet als je er bijvoorbeeld je hand boven houdt. Deze waarde kun je dan gebruiken als voorwaarde om het stoplicht op groen te laten springen. Om een programma met deze voorwaarde te maken heb je ook blokken uit het menu Logisch nodig: het als waar dan \u0026hellip; blok en het \u0026hellip; \u0026lt; \u0026hellip; blok. En je moet ervoor zorgen dat je programma de hele tijd kijkt of de voorwaarde waar is of niet. Uiteindelijk moet het er dan ongeveer zo uitzien:\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/stoplicht/","title":"Micro:Bit - Stoplicht"},{"categories":null,"contents":"We gaan de slag met Scratch en videosensing.\nInleiding Deze Dojo gaat over Scratch 3, en als je een webcam hebt (ingebouwd of los) kun je in Scratch 3 aan de slag met video sensing.\nScratch 3 is de nieuwste versie van Scratch en komt in januari 2019 officieel uit. Op dit moment is er een beta versie beschikbaar, dit betekent dat nog niet alles af is en er nog dingen kunnen veranderen in de definitieve versie.\nBelangrijk: het is nog niet mogelijk om online een programma op te slaan, dit moet je op je eigen computer doen. Het is aan te raden dit regelmatig te doen om te zorgen dat je geen werk verliest. Je kunt opgeslagen programma\u0026rsquo;s ook weer uploaden.\nScratch is er in een heleboel talen. De plaatjes hieronder zijn in het Nederlands dus is het handig om dat ook als taal te kiezen.\nVideo sensing Je kunt in Scratch programma\u0026rsquo;s schrijven die reageren wat er gebeurt op wat de webcam \u0026ldquo;ziet\u0026rdquo;, en dan ook de kleur van wat ie ziet. Hier zijn allerlei spelletjes mee te verzinnen. Hieronder staan wat bouwblokken en ideeën die je kunt gebruiken voor je eigen spel. Sommige zijn meer geschikt voor een ingebouwde webcam en sommige meer voor een losse.\nBegin met het aanzetten van de webcam. De blokken die je hiervoor nodig hebt moet je eerst toevoegen door linksonder te klikken op de knop \u0026ldquo;Voeg een uitbreiding toe\u0026rdquo; en daarna \u0026ldquo;Video\u0026rdquo; te kiezen. Scratch zal je nu waarschijnlijk vragen om toestemming om de webcam te gebruiken. Door nu op het blok \u0026ldquo;zet video aan\u0026rdquo; te klikken zal je op de achtergrond van Scratch zien wat de webcam ziet. Het is nog een beetje onduidelijk, als je het blok \u0026ldquo;zet video transparantie\u0026rdquo; instelt op 0 en er op klikt zie je het beter.\nKleur instellen Om ervoor te zorgen dat Scratch reageert op de kleur die de webcam ziet moet je deze eerst instellen. Zet eerst de webcam aan in Scratch Dit doe je door op de kleur van het blok \u0026ldquo;raak ik kleur\u0026rdquo; te klikken en daarna op het icoon in de rode cirkel. Je kunt nu een kleur in het beeld van de webcam aanklikken.\nBouwblokken Sprite beweegt tegen een kleur aan\nDit bouwblok is het makkelijkst te gebruiken als je een losse webcam hebt die je op tafel kunt richten. In dit geval liggen de gekleurde voorwerpen (papiertjes, legoblokjes, M\u0026amp;M\u0026rsquo;s, noem maar op) en beweegt een sprite tegen de voorwerpen aan. Je kunt dan programmeren wat er moet gebeuren als de sprite een kleur raakt: hij verandert van uiterlijk, er klinkt een geluid, je poppetje is \u0026ldquo;af\u0026rdquo;, enzovoorts.\nKleur beweegt tegen een sprite aan\nIn dit geval gaat het er om dat een kleur op een bepaalde plek op het scherm verschijnt en Scratch daarop reageert. Om dat voor elkaar te krijgen doe je eigenlijk hetzelfde als in het vorige voorbeeld - bijvoorbeeld \u0026ldquo;als deze sprite kleur rood raakt\u0026rdquo;, maar zit de sprite vast op één plek, bijvoorbeeld het linker- of rechterdeel van het scherm. Het kan voor je spelletje handig zijn om deze sprites te verbergen. Dit kun je doen door eerst op een sprite te klikken en daarna op het blok \u0026ldquo;verberg\u0026rdquo;.\nMogelijke spelletjes Speed color: wie houdt het snelst de goede kleur in beeld\n In dit spelletje speel je met twee spelers, en heeft elke speler één helft van het scherm (links en rechts). Tel af en laat dan een kleur zien, de spelers moeten nu de goede kleur papier omhoog houden. Tip: gebruik hiervoor de functie \u0026ldquo;willekeurig getal tussen 1 en \u0026hellip;\u0026rdquo; Extra moeilijk: laat de kleur die spelers omhoog moeten houden zien als woord met de letters in een andere kleur, bijvoorbeeld \u0026ldquo;blauw\u0026rdquo; maar dan met rode letters.  Kleurenmuziek\n Dit is een spelletje om muziek te maken met kleuren die je in beeld laat zien. Dit kan met een ingebouwde en losse webcam. Als je gekleurde voorwerpen op tafel legt kun je bijvoorbeeld een bewegende \u0026ldquo;streep\u0026rdquo; maken die steeds over het beeld schuift.  Gekleurde platformen\n In dit spel maak je een platform van gekleurde voorwerpen en moet een sprite daar overheen lopen/rennen. Begin met programmeren van de beweging van de sprite met een platform dat je in Sprite hebt getekend. Bepaal dan wat de kleuren moeten doen als je ze raakt (bijvoorbeeld opnieuw beginnen). Vervang dan het getekende platform door voorwerpen die de webcam ziet. Bonus: hieronder vind je een aantal tips om de beweging van de sprite minder schokkerig te maken.  Platform spel Het maken van een vloeiende beweging\nIn Scratch kun je bewegen van links naar rechts, en van boven naar onder. De plek van links naar rechts wordt bepaald door de waarde van x, en die van boven naar onder door y. Deze waarden noem je de coördinaten.\nDe makkelijkste manier om dit te doen is door een knop aan een verandering in de waarde van x en y te verbinden: Dit kun je ook voor beweging de andere kant op, naar boven en beneden doen. Deze beweging is nogal schokkerig. Je kunt deze beweging op meerdere manieren vloeiender maken. Een manier is de volgende. Als eerste moet je hiervoor de waarde van x niet meteen als getal intypen, maar dit doen via een variabele die de snelheid van de sprite bepaalt (zie het menu \u0026lsquo;variabelen\u0026rsquo;):\nDe volgende stap is om deze stap in een herhaal lus te zetten, daardoor blijft de snelheid veranderen zo lang je de knop ingedrukt houdt:\nWat er nu gebeurt is dat de sprite na het loslaten van de knop net zo snel blijft gaan. Je moet dus instellen dat de snelheid omlaag gaat als je de knop niet indrukt:\nJe zult nu zien dat de snelheid na een tijdje onder de 0 gaat en de sprite dus de andere kant op zal gaan bewegen. O dit te voorkomen moet een je een voorwaarde toevoegen dat de snelheid niet onder de 0 mag komen.\nBeweging naar links kun je op dezelfde manier programmeren, uiteindelijk ziet het er dan zo uit:\nJe kunt de beweging nog verder verbeteren door een maximale snelheid te bepalen en de snelheid alleen te verhogen als die nog niet is bereikt. Je voegt dan een extra voorwaarde toe:\nNatuurlijk hoort springen (en daarna weer vallen) ook bij een platform spel. Een manier om dit voor elkaar te krijgen zie je in het blok hieronder, waarbij Het blok hieronder een paar dingen doet:\n als je een onderdeel van het platform raakt is je snelheid in de y-richting 0 als je op het platform staat en springt gaat je snelheid omhoog als je niet op het platform staat wordt je snelheid y-snelheid steeds hoger (je gaat naar beneden dus die wordt steeds meer negatief).  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/scratch-videosensing/","title":"Scratch - Videosensing"},{"categories":null,"contents":"We gaan met 2D game \u0026ldquo;framework\u0026rdquo; Löve2D een shooter bouwen.\nWe gaan een eenvoudige shooter maken. Deze instructie is een vertaling en bewerking van een tutorial gemaakt door \u0026gt;_OSMSTUDIOS.\nWat leer je? Tijdens de Dojo\u0026rsquo;s over Scratch hebben jullie kennis gemaakt met variabelen en functies (blokken). Daar gaan we mee verder.\nIn Scratch kun je met drag-and-drop variabelen en functies combineren tot een programma, maar bij de meeste programmeertalen wordt het programma in tekst geschreven. Dat is ook het geval bij Löve. We gaan dus typen.\nOm het geen type sessie te laten zijn, zijn een aantal functies, net als bij Scratch, al voor jullie gemaakt. Je hoeft ze dus niet helemaal zelf meer te maken. Je hoeft ze alleen maar te gebruiken.\nBenodigdheden Om deze instructie te kunnen volgen, moet je Löve en een goede editor geïnstalleerd hebben. Verder moet je wat code downloaden om verder op te bouwen, maar dit wordt in stap 0 uitgelegd.\nInstallatie Löve Hopelijk heb je de installatie al voorbereid na het ontvangen van de uitnodiging voor deze Dojo. Als dat zo is, kun je dit hoofdstukje overslaan en doorgaan naar Stap 1.\nWindows Löve is op Windows gemakkelijk te installeren via één van de installers. Als alternatief kun je kiezen voor één van de zipbestanden en deze op een gewenste locatie unzippen. Maak het jezelf gemakkelijk door Löve op een eenvoudig te onthouden plek te installeren, bijvoorbeeld in de map\nc:\\love\\  Zie de Löve download pagina voor de installatie bestanden. Als je twijfelt tussen de 32- of 64-bits versie, kun je voor de zekerheid kiezen voor 32-bits versie of gewoon even checken welke versie je hebt.\nMac Download het zip bestand voor Mac en unzip het op de gewenste locatie.\nLinux Voor Ubuntu kun je kiezen voor het toevoegen van de Löve PPA of voor de installatie van één van de .deb bestanden.\nTekst editor Als je gaat programmeren is het handig om een editor te installeren met meer mogelijkheden dan \u0026lsquo;kladblok\u0026rsquo;. Sublime Text snapt Lua en dus Löve. Als alternatief kun je kiezen voor Notepad++.\nStappen TIP: de onderstaande stukken code hoef je niet over te typen. Je kunt ze natuurlijk gewoon copy-pasten in je editor.\nStap 0: installatie voorbereidde code Download the code van GitHub: Löve 2D shooter code De zip-file bevat een src/ folder. Kopieer de inhoud daarvan naar c:\\games\\shooter Om de voorbereidde code uit te voeren, druk je op de Windows knop en typ je \u0026lsquo;cmd\u0026rsquo;. Je krijgt dan een zwart venster. Typ dan cd c:\\games\\shooter om naar de folder te gaan waar je de code hebt neergezet. Typ tenslotte c:\\love\\love.exe .\\ om het programma te starten. Als alles goed gaat, krijg je een zwart venster.\nStap 1: teken het vliegtuig van de speler In deze stap doen we het volgende:\nWe laden het plaatje van het vliegtuig van de speler Tekenen het plaatje op het scherm Open main.lua in je tekst editor en type het volgende:\n-- variabele om het plaatje in op te slaan spelersVliegtuig = nil function love.load(arg) -- laadt het plaatje in de variabele spelersVliegtuig = love.graphics.newImage(\u0026#39;plaatjes/spelersVliegtuig.png\u0026#39;) end En vervolgens om op het scherm te tekenen:\nfunction love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(spelersVliegtuig, 100, 100) end Start je programmaatje en zie het resultaat:\nx en y as In de code hebben we bij het aanroepen van functie love.graphics.draw twee keer het getal 100 gebruikt. Deze worden gebruikt om de positie van het plaatje in het scherm te bepalen. Daarbij is positie 0,0 links bovenin. Bij 100,100 is het plaatje dus 100 stappen naar beneden en 100 naar rechts verschoven ten opzichte van 0,0. Voor de horizontale positie wordt vaak variabele naam x gebruikt en voor de verticale positie y.\nIn Scratch komen x en y waarden voor de plaats van een Sprite ook terug. Hieronder staat Scratch op x = 31 en y = -36\n Stap 2: eigenschappen van de speler Het vliegtuig van de speler staat nu nog stil op positie 100,100, maar zal natuurlijk van links naar rechts gaan bewegen als we wat verder zijn. Je zou kunnen zeggen dat de speler een aantal eigenschappen heeft:\n het plaatje de positie  Om die informatie bij elkaar te houden, vervangen we variabele spelersVliegtuig door een nieuwe variabele waarin meerdere eigenschappen opgeslagen kunnen worden:\n-- variabele om eigenschappen van de speler in op te slaan speler = { x = 200, y = 560, plaatje = nil } function love.load(arg) -- laadt het plaatje in eigenschap plaatje van de variabele speler speler.plaatje = love.graphics.newImage(\u0026#39;plaatjes/spelersVliegtuig.png\u0026#39;) end Het tekenen van het plaatje moet ook aangepast worden, zodat de nieuwe variabele met spelers eigenschappen gebruikt worden:\nfunction love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) end Start opnieuw je programma en zie dat het vliegtuig nu onder in het venster staat. De wijzigingen die je hebt gemaakt zijn een voorbereiding om plaatje te kunnen laten bewegen.\nStap 3: de speler bewegen Je programma toont nu alleen een stilstaand plaatje. Dat is natuurlijk niet erg interessant. In deze stap ga je het plaatje laten bewegen.\nBewegen met pijltjes Om het plaatje te horizontaal te laten bewegen, moet de speler.x eigenschap worden aangepast. De waarde van speler.x moet kleiner worden om naar links te bewegen en groter om naar rechts te bewegen. Je kunt dit ook eenvoudig uitproberen door de waarde 200 in de code groter of kleiner te maken en je programma te starten.\nOm het plaatje te laten bewegen terwijl het programma draait, moet het programma gaan reageren op toetsen van je toetsenbord. De pijl naar links zorgt voor een beweging naar links en de pijl naar rechts voor een beweging naar rechts:\nfunction love.update(dt) -- als pijltje naar links wordt ingedrukt if love.keyboard.isDown(\u0026#39;left\u0026#39;) then -- dan doe een stap naar links speler.x = speler.x - 1 -- als pijltje naar rechts wordt ingedrukt elseif love.keyboard.isDown(\u0026#39;right\u0026#39;) then -- dan doe een stap naar rechts speler.x = speler.x + 1 end end Als je voor het eerst naar programmeercode kijkt ziet het bovenstaande er ingewikkeld uit, maar vergelijk het eens met het bewegen met pijltjes in Scratch. love.update(dt) wordt steeds opnieuw uitgevoerd en is daarom vergelijkbaar met de \u0026lsquo;herhaal\u0026rsquo; in Scratch en \u0026lsquo;if \u0026hellip; then\u0026rsquo; is gelijk aan \u0026lsquo;als \u0026hellip; dan\u0026rsquo; in Scratch.\nAls je de programmeercode hebt ingevoerd, kun je het programma starten om uit te proberen of het werkt.\nProbeer ook eens een andere stapgrootte dan 1. Doet dat wat je ervan verwacht? Wat gebeurt er als je er een negatief getal van maakt? Kun je de code aanpassen, zodat je ook naar boven en beneden kunt bewegen (gebruik toetsen \u0026lsquo;up\u0026rsquo; voor naar boven en \u0026lsquo;down\u0026rsquo; voor naar beneden)? Wat gebeurt er als je bijvoorbeeld het pijltje naar rechts lang ingedrukt houdt?\nStoppen bij de rand Om te voorkomen dat het plaatje onzichtbaar wordt, moeten we voorkomen dat het verder beweegt als het aan de randen van het venster komt. Aan de linker kant is dat makkelijk: beweeg niet verder als speler.x gelijk is aan 0. In code ziet dat er als volgt uit:\n-- als pijltje naar links ingedrukt if love.keyboard.isDown(\u0026#39;left\u0026#39;) then -- en linker rand is nog niet bereikt if speler.x \u0026gt; 0 then -- dan doe een stap naar links speler.x = speler.x - 1 end Aan de rechter zijde is dat lastiger. Daar hangt de maximale \u0026lsquo;x\u0026rsquo; af van de breedte van het venster. De maximale waarde voor x is gelijk aan de breedte van het venster, of xRechterRand():\n-- als pijltje naar rechts ingedrukt elseif love.keyboard.isDown(\u0026#39;right\u0026#39;) then -- en de rechter rand is nog niet bereikt if speler.x \u0026lt; xRechterRand() then -- dan doe een stap naar rechts speler.x = speler.x + 1 end end Pas de code die je eerder bij stap 3 (bewegen met pijltjes) hebt geschreven aan, zodat je stopt bij de rand. Controleer ook of het plaatje nu niet aan de rechterkant verdwijnt. Voor de duidelijkheid hebben we de Scratch code ook aangepast en bijgevoegd (zie plaatje rechts).\nStap 4: de vijand Het spel draait natuurlijk niet alleen om het heen en weer bewegen van een vliegtuigje. Er is ook een vijand. In deze stap gaan we vijanden maken.\nWe beginnen met het tekenen van één vijand. Daarvoor voegen we één regel toe (bijna bovenaan je code) en we voegen een regel code toe aan de love.load() en love.draw() functies:\n-- variabelen om eigenschappen van de speler en vijand in op te slaan speler = { x = 200, y = 560, plaatje = nil } vijand = { x = 200, y = 0, plaatje = nil } function love.load(arg) -- laadt het plaatje in eigenschap plaatje van de variabele speler speler.plaatje = love.graphics.newImage(\u0026#39;plaatjes/spelersVliegtuig.png\u0026#39;) vijand.plaatje = love.graphics.newImage(\u0026#39;plaatjes/vijandsVliegtuig.png\u0026#39;) end function love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) love.graphics.draw(vijand.plaatje, vijand.x, vijand.y) end Probeer bovenstaande code uit.\nEr is nu één vijand en deze staat recht tegenover de speler. Een stilstaande vijand is niet zo interessant, dus we laten \u0026rsquo;m naar de speler bewegen. Dat kan vrij eenvoudig door het volgende aan de code toe te voegen aan je love.update(dt) functie:\nfunction love.update(dt) -- laat de vijand een stapje naar beneden doen  vijand.y = vijand.y + 1 Bovenstaande code werkt hetzelfde als het verplaatsen van de speler. Nu bewegen we alleen wel verticaal (van boven naar beneden). Daardoor moeten we y in plaats van x veranderen. De positie van de vijand wordt steeds met 1 stapje naar beneden verzet. Zo beweegt de vijand naar de speler toe.\nOm het plaatje van buiten het venster tevoorschijn te laten komen, moet de y positie aangepast worden naar -100. Pas de code bovenin je script aan door y = 0 te veranderen naar y = -100:\nvijand = { x = 200, y = -100, plaatje = nil } Onder aan het scherm vliegt de vijand het venster uit en is dan verdwenen. Het is natuurlijk leuker als er aan de bovenkant een nieuwe vijand verschijnt. Daarvoor moet je, net als bij het bewegend maken van de vijand, onderstaande code toevoegen aan love.update(dt):\n-- als de vijand de onderrand heeft bereikt if vijand.y \u0026gt; yOnderRand() then -- verplaats het dan uit het zicht boven het venster vijand.y = -100 end Om je te helpen met het begrijpen van de code: het verplaatsen van de vijand in Scratch zou er ongeveer zo uitzien:\nOm het nog interessanter te maken, zou het leuk zijn als de vijand niet steeds op dezelfde plaats van boven naar beneden beweegt. De waarde van vijand.x (horizontale positie) zou iedere keer anders moeten zijn. Gebruik daarvoor de functie xWillekeurig():\n-- als de vijand de onderrand heeft bereikt if vijand.y \u0026gt; yOnderRand() then -- verplaats het dan uit het zicht boven het venster vijand.y = -100 -- en zet de horizontale positie naar een willekeurige waarde vijand.x = xWillekeurig() end Wat je in Scratch zo zou doen:\nStap 5: meerdere vijanden We hebben nu een enkele vijand. Die is natuurlijk makkelijk te ontwijken. Spannender wordt het, als we er meerdere hebben. Daarvoor moeten we het één en ander aanpassen, de code die je eerder hebt geschreven voor één vijand, gaan we vervangen met code voor meerdere vijanden. Je moet hier en daar dus code verwijderen!\nAllereerst hebben we een lijst met vijanden nodig, die voegen we bovenaan de code toe, bij \u0026lsquo;speler\u0026rsquo;. Variabelen staan vaak bovenaan in code:\n-- variabelen om eigenschappen van de speler in op te slaan speler = { x = 200, y = 560, plaatje = nil } -- lijst om vijanden in op te slaan vijanden = {} Een andere variabele die we nodig hebben is het plaatje van de vijand. Eerder deden we dat in de functie love.draw(dt) met speler.plaatje. Die regel mag nu verwijderd worden en in plaats daarvan zetten we bij de variabelen \u0026lsquo;speler\u0026rsquo; en \u0026lsquo;vijanden\u0026rsquo; ook het plaatje voor de vijand:\n-- laad het plaatje van de vijand vijandPlaatje = love.graphics.newImage(\u0026#39;plaatjes/vijandsVliegtuig.png\u0026#39;) De vijanden moeten ook getekend worden, zorg ervoor dat jouw love.draw(dt) functie eruit ziet zoals hieronder:\nfunction love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) -- teken de vijanden in de lijst tekenVijanden(vijanden) end Er worden alleen vijanden getekend die bestaan, daarom moeten vijanden ook aangemaakt worden:\nfunction love.update(dt) maakNieuweVijand(vijanden) In de vorige stap hebben we de vijand laten bewegen. Deze code moeten we nu voor iedere vijand in de lijst uitvoeren:\nfunction love.update(dt) maakNieuweVijand(vijanden) -- voor elke vijand in de lijst  for index, vijand in ipairs(vijanden) do -- laat de vijand een stapje naar beneden doen  vijand.y = vijand.y + 2 -- als de vijand de onderrand heeft bereikt if vijand.y \u0026gt; yOnderRand() then -- verwijder de vijand table.remove(vijanden, index) end end Het maken en verwijderen van vijanden zoals we dat hierboven doen is in Scratch heel lastig. We geven daarom geen voorbeeld van het bovenstaande in Scratch. Waar het kan doen we dat wel.\nVoer het programma uit. Als het goed is ziet het eruit als onderstaande plaatje:\nStap 6: de vijand ontwijken Als de speler een vijand raakt, is het spel afgelopen. Om te zien of de speler een vijand geraakt heeft, hebben we functie spelerHeeftVijandGeraakt().\nAls het resultaat van de functie waar (true) is, dan moet het spel gestopt worden.\nVoeg daarvoor de volgende code toe aan functie love.update(dt):\n-- als de speler een vijand geraakt heeft if spelerHeeftVijandGeraakt() then -- is het spel afgelopen spelIsAfgelopen = true end In variabele spelIsAfgelopen wordt bijgehouden of het spel nog loopt of al is afgelopen. Als het is afgelopen, wordt de speler niet langer getekend. Pas daarvoor functie love.draw(dt) aan door het tekenen van de speler binnen een if statement te plaatsen:\nfunction love.draw(dt) -- als het spel nog niet is afgelopen if spelIsAfgelopen == false then -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) end In Scratch zou het er zo uitzien:\nVergeet niet om bovenaan het bestand de variabele toe te voegen:\nspelIsAfgelopen = false Als je nu het spel speelt, wordt het spelersvliegtuig niet meer getekend als je een vijand hebt geraakt.\nStap 7: schieten De stap schieten lijkt op een combinatie van stappen 4 en 5..\nEr moet een lijst worden toegevoegd voor de kogels:\n-- variabelen om eigenschappen van de speler in op te slaan speler = { x = spelerX, y = spelerY, plaatje = nil } -- lijst om vijanden in op te slaan vijanden = {} -- lijst om kogels in op te slaan kogels = {} Het plaatje van de kogel moet worden geladen:\n-- laad het plaatje van de vijand vijandPlaatje = love.graphics.newImage(\u0026#39;plaatjes/vijandsVliegtuig.png\u0026#39;) -- laad het plaatje van de kogel kogelPlaatje = love.graphics.newImage(\u0026#39;plaatjes/kogel.png\u0026#39;) En het plaatje moet worden getekend, dat doe je in de love.draw(dt) functie:\n-- teken de kogels in de lijst tekenKogels(kogels) In tegenstelling tot de vijanden, worden nieuwe kogels alleen aangemaakt als de speler de spatiebalk indrukt. In de love.update(dt) functie voeg je het volgende toe:\nif spelIsAfgelopen == false then -- als de spatiebalk wordt ingedrukt if love.keyboard.isDown(\u0026#39;space\u0026#39;) then -- schiet dan maakNieuweKogel(kogels, speler) end maakNieuweVijand(vijanden)  Als je de code tot nu toe uitprobeert, krijg je wel een kogels te zien, maar die bewegen niet, het ziet eruit als het plaatje hieronder.\nAan de love.update(dt) functie moet nog wat extra code worden toegevoegd om de kogels te laten bewegen. Elke kogel in de lijst laten we telkens vier stappen omhoog gaan en als een kogel uit beeld verdwijnt, halen we de kogel ook uit de lijst:\nif spelIsAfgelopen == false then -- als de spatiebalk wordt ingedrukt if love.keyboard.isDown(\u0026#39;space\u0026#39;) then -- schiet dan maakNieuweKogel(kogels, speler) end -- voor elke kogel in de lijst for index, kogel in ipairs(kogels) do -- beweeg de kogel naar boven kogel.y = kogel.y - (2 * stapGrootte) -- als de kogel de bovenrand heeft bereikt if kogel.y \u0026lt; -20 then -- verwijder het uit de lijst table.remove(kogels, index) end end maakNieuweVijand(vijanden)  Dat ziet er beter uit!\nStap 8: raken en scoren De vijanden vliegen, je kunt je vliegtuig richten en je kunt schieten. Maar je schoten raken nog niets en de vijanden vliegen door. Daar gaan we in deze stap wat aan doen.\nFunctie kogelHeeftVijandGeraakt() laat ons weten of een kogel een vijand geraakt heeft. Ook verwijderd deze functie de geraakte vijand en de kogel:\n-- als de kogel een vijand geraakt heeft if kogelHeeftVijandGeraakt() then -- heb je een punt gescoord score = score + 1 end Voeg bovenstaande code toe aan love.update(dt). Om de score in op te slaan, moet je ook nog een variabele aanmaken boven aan het bestand:\nscore = 0 In Scratch ziet het er zo uit:\nWe willen natuurlijk de score kunnen zien, dus moeten we die in het scherm afdrukken. Voeg daarvoor in love.draw(dt) het volgende toe:\n-- zet de tekstkleur op wit love.graphics.setColor(255, 255, 255) -- en druk de score af love.graphics.print(\u0026#34;SCORE: \u0026#34; .. tostring(score), 400, 10) Stap 9: opnieuw starten Mocht je een vijand aanraken, dan is het spel afgelopen, maar dan wil je natuurlijk wel opnieuw kunnen beginnen. Daarvoor gaan we code toevoegen aan love.update(dt):\n-- als de o van opnieuw wordt ingedrukt if love.keyboard.isDown(\u0026#39;o\u0026#39;) then -- wordt het spel opnieuw gestart kogels = {} vijanden = {} score = 0 spelIsAfgelopen = false end Als je op \u0026lsquo;o\u0026rsquo; drukt begint je spel opnieuw. Het spel is nu klaar!\nVoorbereide functies Bij het maken van het spelletje heb je gebruik gemaakt van een aantal voorbereide functies. Als je je nu afvraagt hoe die functies zijn gemaakt, dan kun je eens kijken in bestand functies.lua.\nVoorbeeld code Mocht je nu ook nog een voorbeeld van de volledige code willen bekijken, dan moet je eens kijken in voorbeeld.lua.\nConclusie Het spelletje is af en je hebt geleerd hoe je vrij gemakkelijk een 2D shooter kunt maken met Löve.\nVervolg Als je meer wilt maken met Löve, dan zijn er meerdere instructies (in het Engels: tutorials) op het internet te vinden. Helaas zijn die wel vrijwel allemaal Engelstalig.\nEen overzicht vind je op site van Löve zelf: https://love2d.org/wiki/Category:Tutorials.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 26, 2020","permalink":"/instructies/love2d-shooter/","title":"Löve2D - Shooter"},{"categories":null,"contents":"Deze keer gaan we tekenen met Python Turtle.\nTurtle introductie Commando\u0026rsquo;s Python Interpreter Start Thonny.\nType onderin (je hoeft de \u0026raquo;\u0026gt; niet te typen):\n\u0026gt;\u0026gt;\u0026gt; from turtle import *  Hiermee geef je Python de opdracht om de turtle te gebruiken.\nTekenen Je turtle kan voor je tekenen door hem opdrachten te geven. Type het volgende:\n\u0026gt;\u0026gt;\u0026gt; forward(100)  Met dit commando gaat je turtle 100 stapjes vooruit. Als dat nog niet gebeurd was, moet nu een scherm zijn geopend, waarin je de de turtle en een lijn kan zien.\nDe turtle kan ook achteruit:\n\u0026gt;\u0026gt;\u0026gt; backward(100)  Dikkere lijnen Je kan je lijnen dikker maken met width(). Probeer deze commando\u0026rsquo;s maar eens uit:\n\u0026gt;\u0026gt;\u0026gt; width(5) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; width(2) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; width(1) \u0026gt;\u0026gt;\u0026gt; forward(100)  Tip: met de pijltjestoetsen (omhoog en omlaag) op je toetsenbord kun je eerdere commando\u0026rsquo;s terug halen. Met enter kun je die dan opnieuw uitvoeren.\nDraaien Je kan je turtle laten draaien:\n\u0026gt;\u0026gt;\u0026gt; right(90)  Hiermee draait de turtle 90 graden naar rechts. Als je niet weet wat 90 graden betekent, kun je verschillende getallen uitproberen. Je kan ook naar links draaien. Probeer deze commando\u0026rsquo;s maar eens uit:\n\u0026gt;\u0026gt;\u0026gt; left(45) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; right(180) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; left(360) \u0026gt;\u0026gt;\u0026gt; forward(100)  Kleur Je turtle en de lijnen zijn nu nog zwart. Je kan de kleur van de turtle en de achtergrond kleur makkelijk veranderen. Probeer deze commando\u0026rsquo;s eens uit en kijk bij elk commando wat er verandert op je scherm:\n\u0026gt;\u0026gt;\u0026gt; color('green') \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; bgcolor('yellow') \u0026gt;\u0026gt;\u0026gt; color('red') \u0026gt;\u0026gt;\u0026gt; forward(100)  Experimenteer vooral ook met andere kleuren! Onderin deze pagina zie je een overzichtje van allerlei verschillende kleuren.\nOpnieuw beginnen Je kan de tekening die de turtle heeft gemaakt verwijderen:\n\u0026gt;\u0026gt;\u0026gt; clear()  Je kan ook helemaal opnieuw beginnen:\n\u0026gt;\u0026gt;\u0026gt; reset() \u0026gt;\u0026gt;\u0026gt; bgcolor('white')  Opdrachten Probeer de onderstaande plaatjes eens na te tekenen met je turtle. Gebruik na elke opdracht het reset() commando om aan de volgende te beginnen. De achtergrondkleur staat telkens ingesteld op \u0026lsquo;black\u0026rsquo;.\nOpdracht 1-A kleur: \u0026lsquo;green\u0026rsquo;\nOpdracht 1-B kleuren: \u0026lsquo;lightblue\u0026rsquo; en \u0026lsquo;yellow\u0026rsquo;\nOpdracht 1-C kleuren: \u0026lsquo;darkkhaki\u0026rsquo; en \u0026lsquo;red\u0026rsquo;.\nKleuren overzicht Hier zijn verschillende kleuren die je kan gebruiken voor color() of bgcolor().\nPython introductie Variabelen en loops Variabelen Probeer deze code eens uit en kijk goed wat er gebeurt:\n\u0026gt;\u0026gt;\u0026gt; getal = 45 \u0026gt;\u0026gt;\u0026gt; forward(getal) \u0026gt;\u0026gt;\u0026gt; right(getal) \u0026gt;\u0026gt;\u0026gt; forward(getal) \u0026gt;\u0026gt;\u0026gt; getal = 90 \u0026gt;\u0026gt;\u0026gt; right(getal) \u0026gt;\u0026gt;\u0026gt; forward(getal)  Het woord \u0026ldquo;getal\u0026rdquo; is hier een variabele. Een variabele heeft een naam die je zelf kiest en een waarde. Die waarde begint hier als 45 en wordt later ingesteld als 90.\nJe kan Python ook rekensommetjes laten maken en de uitkomst in een variabele stoppen. Om te weten wat voor waarde een variabele heeft, type je de naam van de variabele in en druk je op enter. Probeer maar eens uit:\n\u0026gt;\u0026gt;\u0026gt; getal1 = 1 + 1 \u0026gt;\u0026gt;\u0026gt; getal1 2 \u0026gt;\u0026gt;\u0026gt; getal2 = 9 - getal1 \u0026gt;\u0026gt;\u0026gt; getal2 7 \u0026gt;\u0026gt;\u0026gt; getal3 = getal2 * 2 \u0026gt;\u0026gt;\u0026gt; getal3 14 \u0026gt;\u0026gt;\u0026gt; getal4 = 28 / getal3 \u0026gt;\u0026gt;\u0026gt; getal4 2.0  Zoals je ziet: \u0026lsquo;*\u0026rsquo; betekent vermenigvuldigen, en \u0026lsquo;/\u0026rsquo; is delen door.\nHerhaling Je kan bepaalde commando\u0026rsquo;s ook meerdere keren laten uitvoeren, dat noemen we een loop:\n\u0026gt;\u0026gt;\u0026gt; for teller in range(4): ... forward(100) ... right(90)  Let op: Nadat je dit getypt hebt moet je nog een keer op enter drukken, zodat Python weet dat je klaar bent met je loop.\nIn dit voorbeeld is \u0026ldquo;teller\u0026rdquo; een variabele die optelt en range() geeft aan tot welk getal geteld moet worden. Teller begint bij 0 en telt tot 4. Als je nu de waarde van teller vraagt, zie je dat het tellen is opgehouden voordat 4 werd bereikt:\n\u0026gt;\u0026gt;\u0026gt; teller 3  Je kan teller dus ook gebruiken in je turtle opdrachten! Kun jij voorspellen wat er gebeurt als je onderstaande commando\u0026rsquo;s intypt?\n\u0026gt;\u0026gt;\u0026gt; for teller in range(1,5): ... forward(50 * teller) ... right(90)  Met range(1,5) begint het tellen bij 1 en eindigt op 4 (voordat de 5 wordt bereikt).\nFiguren tekenen Veelhoek Met een klein rekensommetje kun je ook een veelhoek tekenen! Om een veelhoek te tekenen moet je weten wat voor hoek je turtle moet maken. Gelukkig kan Python dat voor je berekenen: om de turtle helemaal rond te laten gaan moet deze 360 graden gedraaid zijn.\n\u0026gt;\u0026gt;\u0026gt; aantal_punten = 5 \u0026gt;\u0026gt;\u0026gt; hoek = 360 / aantal_punten \u0026gt;\u0026gt;\u0026gt; for teller in range(aantal_punten): ... forward(100) ... right(hoek)  Wat gebeurt er nu als je de variabele aantal_punten een hoger getal geeft?\nSter De hoek die je nodig hebt voor een ster is moeilijker te berekenen. Sommige sterren zijn niet eens in 1 lijn te tekenen, bijvoorbeeld de 6-puntige ster. De 5-puntige ster is makkelijker:\n\u0026gt;\u0026gt;\u0026gt; hoek = 144 \u0026gt;\u0026gt;\u0026gt; for teller in range(5): ... forward(100) ... right(hoek)  Opdrachten Probeer de onderstaande figuren te tekenen.\nOpdracht 2-A Tip: De hoek is 150 graden.\nOpdracht 2-B Uitdaging: probeer zo min mogelijk commando\u0026rsquo;s te gebruiken om de opdracht uit te voeren. Lukt het in 5 regels? Vraag een mentor om tips!\nOpdracht 2-C Tip: Gebruik een zo klein mogelijke waarde in je forward() zodat de cirkel niet te groot wordt!\nTurtle voor gevorderden Meer turtle commando\u0026rsquo;s Veelhoeken functie Tot nu toe tekenen we veelhoeken door herhaaldelijk vooruit te lopen en een stukje te draaien. Omdat veelhoeken vaak van pas komen, is hier echter ook een aparte functie voor:\n\u0026gt;\u0026gt;\u0026gt; circle(50, 360, 4)  In dit geval tekenen we een veelhoek met een afstand van 50 tussen de omtrek en het middelpunt; dit noemen we de radius. Met 360 geven we aan dat we de volledige vorm willen tekenen. Voor een halve veelhoek gebruiken we hier bijvoorbeeld 180. Het laatste getal, 4, geeft aan dat we vier keer willen draaien en vooruit lopen. Hiermee maken we dus een ruit!\nAls je wil kan je de volgende code proberen. Deze tekent tien veelhoeken naast elkaar: van een eenhoek (monogoon) tot een tienhoek (decagoon).\n\u0026gt;\u0026gt;\u0026gt; for i in range(10): \u0026gt;\u0026gt;\u0026gt; radius = 50 \u0026gt;\u0026gt;\u0026gt; aantal_punten = i + 1 \u0026gt;\u0026gt;\u0026gt; locatie_x = -500 + i * 100 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(locatie_x, -radius) \u0026gt;\u0026gt;\u0026gt; pendown() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; circle(radius, 360, aantal_punten)  Vormen en stempels Je turtle lijkt tot nu toe niet echt op een schildpad, maar dat kun je veranderen:\n\u0026gt;\u0026gt;\u0026gt; shape('turtle') \u0026gt;\u0026gt;\u0026gt; color('darkgreen')  Met shape() kun je dus de vorm veranderen. Andere vormen zijn “arrow”, “circle”, “square”, “triangle” en “classic”.\nJe turtle kan ook stempelen, net als in Scratch. Probeer deze commando\u0026rsquo;s eens uit en kijk na elke stap wat er gebeurt:\n\u0026gt;\u0026gt;\u0026gt; shape('circle') \u0026gt;\u0026gt;\u0026gt; color('red') \u0026gt;\u0026gt;\u0026gt; stempel1 = stamp() \u0026gt;\u0026gt;\u0026gt; right(90) \u0026gt;\u0026gt;\u0026gt; forward(50) \u0026gt;\u0026gt;\u0026gt; shape('square') \u0026gt;\u0026gt;\u0026gt; color('yellow') \u0026gt;\u0026gt;\u0026gt; stempel2 = stamp()∏ \u0026gt;\u0026gt;\u0026gt; forward(50) \u0026gt;\u0026gt;\u0026gt; shape('triangle') \u0026gt;\u0026gt;\u0026gt; color('blue') \u0026gt;\u0026gt;\u0026gt; stempel3 = stamp() \u0026gt;\u0026gt;\u0026gt; forward(50) \u0026gt;\u0026gt;\u0026gt; shape('classic') \u0026gt;\u0026gt;\u0026gt; clearstamp(stempel2)  Elke keer dat we stempelen, met stamp(), maken we ook een variabele aan. Die variabelen kunnen we gebruiken om stempels die we gedrukt hebben te verwijderen, met clearstamp(). Daarom is het handig om ze een naam te geven zoals stempel1, stempel2, etc. Dan weet je later nog precies welke stempel dat is geweest.\nTurtle posities Tot nu toe hebben we de turtle verplaatst door vooruit/achteruit te gaan en te draaien, maar je kan ook de turtle opdracht geven om naar een bepaalde plek te gaan:\n\u0026gt;\u0026gt;\u0026gt; setpos(50,50) \u0026gt;\u0026gt;\u0026gt; setpos(-25,75) \u0026gt;\u0026gt;\u0026gt; setpos(0,0)  Om erachter te komen wat elk getal betekent, kun je het beste 1 van de 2 veranderen en dan zien wat er gebeurt. Het eerste getal noemen we de X-as, het tweede getal noemen we de Y-as.\nSoms wil je de turtle verplaatsen zonder dat er een lijn wordt getekend. Je turtle kan zijn pen optillen en neerzetten met penup() en pendown(). Om bijvoorbeeld een vork te tekenen, schrijf je dit:\n\u0026gt;\u0026gt;\u0026gt; left(90) \u0026gt;\u0026gt;\u0026gt; backward(100) \u0026gt;\u0026gt;\u0026gt; forward(125) \u0026gt;\u0026gt;\u0026gt; setpos(0,0) \u0026gt;\u0026gt;\u0026gt; left(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; right(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(0,0) \u0026gt;\u0026gt;\u0026gt; pendown() \u0026gt;\u0026gt;\u0026gt; right(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; left(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(0,0)  Je kan aan je turtle vragen wat zijn X positie is en wat zijn Y positie is. Je kan die positie ook opslaan in variabelen, zodat je ze later kan gebruiken:\n\u0026gt;\u0026gt;\u0026gt; left(30) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; xcor() 86.60254037844388 \u0026gt;\u0026gt;\u0026gt; ycor() 49.99999999999999 \u0026gt;\u0026gt;\u0026gt; x = xcor() \u0026gt;\u0026gt;\u0026gt; setpos(x, 0) \u0026gt;\u0026gt;\u0026gt; setpos(0, 0)  Turtle draaien Zoals je de turtle naar een bepaalde plek kan laten gaan, kan je deze ook naar een bepaalde hoek laten draaien:\n\u0026gt;\u0026gt;\u0026gt; setheading(0) # rechts \u0026gt;\u0026gt;\u0026gt; setheading(90) # boven \u0026gt;\u0026gt;\u0026gt; setheading(180) # links \u0026gt;\u0026gt;\u0026gt; setheading(270) # onder \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; setheading(135) # ???  De turtle draait dus naar een bepaalde hoek, zonder dat het uitmaakt waar hij daarvoor naartoe kijkt.\nInkleuren Je turtle tekent mooie lijnen, maar je vormen kunnen ook ingekleurd worden:\n\u0026gt;\u0026gt;\u0026gt; bgcolor('black') \u0026gt;\u0026gt;\u0026gt; color('green') \u0026gt;\u0026gt;\u0026gt; fillcolor('darkgreen') \u0026gt;\u0026gt;\u0026gt; width(3) \u0026gt;\u0026gt;\u0026gt; begin_fill() \u0026gt;\u0026gt;\u0026gt; for x in range(4): ... forward(100) ... right(90) ... \u0026gt;\u0026gt;\u0026gt; end_fill()  Let op dat het invullen pas gebeurt bij end_fill(). Je kan de invulkleur kiezen met fillcolor(). Als je geen invulkleur kiest, wordt de kleur van je pen gebruikt.\nDeze techniek wordt echt indrukwekkend als je het gebruikt bij meer ingewikkelde tekeningen. Met deze code teken je bijvoorbeeld een mooie geel-zwarte ster:\n\u0026gt;\u0026gt;\u0026gt; color('yellow') \u0026gt;\u0026gt;\u0026gt; bgcolor('black') \u0026gt;\u0026gt;\u0026gt; begin_fill() \u0026gt;\u0026gt;\u0026gt; for x in range(18): ... forward(200) ... left(100) ... \u0026gt;\u0026gt;\u0026gt; end_fill()  Tekst en turtle verbergen De laatste twee technieken die we hier behandelen spreken bijna voor zich. Probeer de onderstaande code maar eens om een deurmat te tekenen. Welke commando\u0026rsquo;s ken je nog niet? Snap je waar ze voor bedoeld zijn?\n\u0026gt;\u0026gt;\u0026gt; write('Welkom!') \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(-20,20) \u0026gt;\u0026gt;\u0026gt; pendown() \u0026gt;\u0026gt;\u0026gt; for x in range(2): ... forward(70) ... right(90) ... forward(40) ... right(90) ... \u0026gt;\u0026gt;\u0026gt; hideturtle()  Tip: hideturtle() is ook een handig commando bij het stempelen. Om de turtle weer te tonen gebruik je showturtle().\nOpdrachten Probeer de onderstaande tekeningen na te maken, of bedenk je eigen tekeningen.\nOpdracht 3-A Schildpadden in een zandbak\nOpdracht 3-B Een analoge klok.\nChallenge: als je de wijzers een bepaalde stand in wil laten nemen, kan je hiervoor de volgende functies gebruiken:\ndef uren_naar_hoek(uren): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;uren\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (uren / 12.0) * 360 + 90 def minuten_naar_hoek(minuten): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;minuten\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (minuten / 60.0) * 360 + 90  De hoek kan je vervolgens aan setheading() geven.\nOpdracht 3-C Een ruiten drie speelkaart. Maar: er klopt iets niet helemaal!\nDe kaart bevat twee vormen die meerdere keren herhaald worden: de ruit en het getal drie. Als je bekend bent met functies, kan het handig zijn om deze hier te gebruiken. Daarnaast kan je natuurlijk ook een ruiten een kaart maken, als je de circle() functie nog lastig vindt.\nAntwoorden Mocht je er niet uitkomen, dan kun je hier klikken voor antwoorden.  Let op: de volgende lijn ontbreekt aan de bovenkant van deze voorbeelduitwerkingen: from turtle import *  Deel 1 Opdracht 1-A bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;green\u0026#39;) width(5) forward(100) right(90) forward(100) right(90) forward(100) right(90) forward(100) right(90) Opdracht 1-B bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;yellow\u0026#39;) width(3) left(90) forward(50) right(90) forward(200) right(90) forward(100) right(90) forward(200) right(90) forward(50) color(\u0026#39;lightblue\u0026#39;) width(1) right(45) forward(100) right(90) forward(100) right(90) forward(100) right(90) forward(100) Opdracht 1-C bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;darkkhaki\u0026#39;) width(5) forward(200) right(90) forward(100) right(90) forward(200) right(90) forward(100) color(\u0026#39;red\u0026#39;) width(2) right(45) forward(100) right(90) forward(100) color(\u0026#39;darkkhaki\u0026#39;) right(45) forward(100) Deel 2 Opdracht 2-A Tip: 12 x 150 = 1800, en 1800 / 360 = 5. Omdat 1800 deelbaar is door 360, komen de hoeken precies goed uit voor een ster. bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;lightblue\u0026#39;) width(3) for i in range(12): forward(100) right(150) Opdracht 2-B bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;lightblue\u0026#39;) width(3) for i in range(4): for j in range(3): forward(100) right(120) right(90) Opdracht 2-C Tip: In plaats van 360 en 1 kan je ook andere getallen kiezen. Zorg dat deze keer elkaar 360 zijn. bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;lightblue\u0026#39;) width(3) for i in range(360): forward(2) right(1) Deel 3 Opdracht 3-A In deze voorbeelduitwerking staan 2 stempels. Je kan er zelf nog een paar toevoegen als je wil! bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;yellow\u0026#39;) width(5) fillcolor(\u0026#39;lightyellow\u0026#39;) begin_fill() setpos(0,200) setpos(200,200) setpos(200,0) setpos(0,0) end_fill() penup() setpos(50,50) shape(\u0026#39;turtle\u0026#39;) color(\u0026#39;green\u0026#39;) stempel1 = stamp() setpos(84,129) right(120) shape(\u0026#39;turtle\u0026#39;) color(\u0026#39;blue\u0026#39;) stempel2 = stamp()  Opdracht 3-B def uren_naar_hoek(uren): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;uren\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (uren / 12.0) * 360 + 90 def minuten_naar_hoek(minuten): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;minuten\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (minuten / 60.0) * 360 + 90 # De radius van de circel voor de klok. radius = 100 # Voer hier de beoogde tijd in. Je kan de hoeken natuurlijk ook op gevoel kiezen!  minuten = 45 # 45 / 60 uren = 12 # 12 / 12 # Maak de omgeving in orde. speed(\u0026#39;fastest\u0026#39;) bgcolor(\u0026#39;white\u0026#39;) color(\u0026#39;black\u0026#39;) penup() # Start met het tekenen van een circel en een twaalfhoek. width(5) setpos(0, -radius) pendown() circle(radius, 360, 360) circle(radius, 360, 12) penup() # Vervolgens tekenen we de kleine wijzer, op basis van \u0026#34;uren\u0026#34;. setpos(0, 0) setheading(minuten_naar_hoek(minuten)) pendown() forward(.8 * radius) stempel0 = stamp() penup() # De grote wijzer tekenen we op een soortgelijke manier. setpos(0, 0) setheading(uren_naar_hoek(uren)) pendown() forward(.5 * radius) stempel1 = stamp() penup() # Challenges: # - voeg een secondewijzer toe; # - voeg (enkele) getallen toe; # - voeg streepjes voor uren aan de buitenrand toe. done()  Opdracht 3-C speed(\u0026#39;fastest\u0026#39;) def teken_ruit(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34;Teken een ruit met radius: radius. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y-radius) setheading(0) pendown() begin_fill() circle(radius, 360, 4) end_fill() penup() def teken_drie(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een drie met hoogte: 2 * diameter, breedte: diameter. Van belang: circle draait linksom. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y) setheading(0) pendown() circle(radius, 270) penup() setpos(midden_x-radius, midden_y-radius) setheading(270) pendown() circle(radius, 270) penup() # De hoogte en breedte van de kaart. hoogte = 400 breedte = 250 # De radius van de ruiten op de kaart. ruit_radius_groot = 40 ruit_radius_klein = 10 # De radius van de circels van de drie op de kaart. drie_radius = 10 # Teken de omtrek van de kaart. penup() setpos(-.5 * breedte, .5 * hoogte) pendown() for i in range(2): forward(breedte) right(90) forward(hoogte) right(90) # Vanaf hier kleuren we alles rood. color(\u0026#39;red\u0026#39;) fillcolor(\u0026#39;red\u0026#39;) # De ruit in het midden: teken_ruit(0, 0, ruit_radius_groot) # De ruit aan de bovenkant, op een afstand van 20 van de ruit in het midden: teken_ruit(0, 2 * ruit_radius_groot + 20, ruit_radius_groot) # De ruit aan de onderkant, op een afstand van 20 van de ruit in het midden: teken_ruit(0, -2 * ruit_radius_groot - 20, ruit_radius_groot) # Het getal drie in de hoek linksboven. # De afstanden tot de omtrek kan je eventueel nog op \u0026#39;drie_radius\u0026#39; afstemmen. width(5) teken_drie(-.5 * breedte + 15, .5 * hoogte - 25, drie_radius) teken_drie( .5 * breedte - 15, -.5 * hoogte + 25, drie_radius) # Extra: de kleine ruiten onder- en boven de getallen: teken_ruit(-.5 * breedte + 15, .5 * hoogte - 65, ruit_radius_klein) teken_ruit( .5 * breedte - 15, -.5 * hoogte + 65, ruit_radius_klein) setpos(0, 0) done()  Extra: getallen 0, 1, 2, 3, 4 tekenen. speed(\u0026#39;fastest\u0026#39;) def teken_nul(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een nul met hoogte: 2 * diameter, breedte: diameter. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x + radius, midden_y + radius) setheading(90) pendown() circle(radius, 180) forward(2 * radius) circle(radius, 180) forward(2 * radius) penup() def teken_een(midden_x, midden_y, lengte): \u0026#34;\u0026#34;\u0026#34; Teken een (simpele) een met hoogte: lengte, breedte: width. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y + .5 * lengte) setheading(270) pendown() forward(lengte) penup() def teken_twee(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een tween met hoogte: 2 * diameter, breedte: diameter. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x + radius, midden_y + radius) setheading(90) pendown() circle(radius, 180) penup() setpos(midden_x + radius, midden_y + radius) pendown() setpos(midden_x - radius, midden_y - 2 * radius) setheading(0) forward(2 * radius) penup() def teken_drie(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een drie met hoogte: 2 * diameter, breedte: diameter. Van belang: circle draait linksom. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y) setheading(0) pendown() circle(radius, 270) penup() setpos(midden_x-radius, midden_y-radius) setheading(270) pendown() circle(radius, 270) penup() def teken_vier(midden_x, midden_y, hoogte): \u0026#34;\u0026#34;\u0026#34; Teken een vier met hoogte: 2 * diameter, breedte: diameter \u0026#34;\u0026#34;\u0026#34; breedte = .5 * hoogte penup() setpos(midden_x + .25 * breedte, midden_y - .5 * hoogte) pendown() setpos(midden_x + .25 * breedte, midden_y + .5 * hoogte) setpos(midden_x - .5 * breedte, midden_y) setpos(midden_x + .5 * breedte, midden_y) penup() # Stel vast hoe groot de getallen moeten worden. radius = 50 getal_hoogte = 4 * radius getal_breedte = 2 * radius teken_nul(-200, 0, radius) teken_een(-100, 0, getal_hoogte) teken_twee(0, 0, radius) teken_drie(100, 0, radius) teken_vier(200, 0, getal_hoogte) done()    Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 24, 2020","permalink":"/instructies/python-turtle/","title":"Python - Turtle"},{"categories":null,"contents":"We gaan met Scratch het klassieke spel Snake bouwen.\nBenodigdheden Deze opdrachten maak je met Scratch. Als je nog geen account had, maak dit dan eerst aan.\nZet in Scratch eerst de taal op Nederlands via de wereldbol linksboven.\nInleiding In deze opdracht ga je het klassieke spelletje Snake, dus Slang, programmeren. Je bestuurt in dit spelletje een slang en je doel is door zo veel mogelijk te eten zo lang mogelijk te worden. Maar pas op, als je in je eigen staart bijt dan ben je af!\nDit zijn de stappen die je gaat programmeren:\n Maak de slang Zorg dat de slang kan bewegen Laat het eten van de slang verschijnen Maak de slang langer door het eten Laat het spel eindigen als de slang in de eigen staart bijt  Als je dan nog zin (en tijd) hebt dan zijn er nog allerlei uitbreidingen mogelijk.\nAls startpunt voor de opdracht kun je dit project gebruiken (je kunt dan stap 1 van de opdracht overslaan). Je kunt het project zelf gaan bewerken door op de Remix knop boven in Scratch te klikken:\nDe opdracht is afgeleid van deze instructies (Github bron).\nMaak de slang Als je gekozen hebt het project helemaal vanaf het begin te doen, ontwerp dan je eigen slang of download deze plaatjes om de twee uiterlijken van de slang mee te maken:\nVolg deze stappen om een sprite van de slang te maken:\n Klik op het icoon voor een nieuwe sprite (rechtsonder, plaatje van de kat) en kies voor Upload sprite. Upload het hoofd van de slang. Ga naar het tabblad Uiterlijken (linksboven, rechts naast het Code tabblad). Klik op het icoon voor een nieuw uiterlijk (linksonder, plaatje van de kat) en kies voor Upload uiterlijk. Upload het lijf van de slang. Klik nu op het hoofd van de slang.  Zorg dat de slang kan bewegen Het is de bedoeling om de slang met de pijltjestoetsen te laten bewegen. Er zijn verschillende manieren om dit te doen, bijvoorbeeld zo:\nwanneer [pijltje omhoog v] is ingedrukt richt naar (0) graden neem (5) stappen  Met richt naar 0 graden draai je het hoofd van de slang naar boven, met neem 5 stappen beweegt de slang 5 stappen in die richting. Maar\u0026hellip; als je de toets loslaat, dan houdt de slang op met bewegen.\nOpdracht Zorg dat de slang doorgaat met bewegen totdat je een andere kant op gaat.\nTip 1: hiervoor heb je het herhaal blok uit het menu Besturen nodig.\nTip 2: begin het programma met het wanneer op de vlag wordt geklikt blok uit het menu Gebeurtenissen.\nKlik om de voorbeeldcode te laten zien om de slang omhoog te laten bewegen  wanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje omhoog v] ingedrukt?\u0026gt; dan richt naar (0) graden end neem (10) stappen wacht (0.1) sec.    In de voorbeeldcode wordt het blok wacht 0.1 sec. gebruikt. Dit is niet nodig om de slang te laten bewegen, maar wordt verderop in het spel belangrijk. Door de wachttijd en/of het aantal stappen dat de slang zet te veranderen kun je de snelheid van de slang bepalen.\nExtra: via de volgende aanpassing reageert de slang beter!  wanneer groene vlag wordt aangeklikt herhaal neem (10) stappen wacht (0.1) sec. end  wanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje omhoog v] ingedrukt?\u0026gt; dan richt naar (0) graden end  Met deze aanpassing check je elke update of er een pijltje is ingedrukt. Voorheen gebeurde dit niet altijd, omdat we tussendoor ook 0.1 seconde wachtten.   Laat de appels verschijnen Nu is het tijd om de slang eten te geven. Dit voorbeeld gaat uit van appels, je kunt natuurlijk ook iets heel anders verzinnen. Om het lekker onvoorspelbaar te maken waar de appel verschijnt, is het blok ga naar willekeurige positie uit het menu Beweging heel geschikt.\nOpdracht Maak een nieuwe sprite voor de appel, en zorg dat er bij het begin van het spel een appel verschijnt.\nTip: zorg dat je de appel-sprite hebt gekozen, zodat de code die je maakt ook echt bepaalt wat de appel moet doen.\nKlik om de voorbeeldcode te laten zien  wanneer groene vlag wordt aangeklikt ga naar (willekeurige positie)    De volgende stap is om een \u0026ldquo;nieuwe\u0026rdquo; appel op een andere plek te laten verschijnen wanneer de slang er een heeft opgegeten. Hiervoor maak je niet echt een nieuwe appel, maar je laat de appel-sprite gewoon op een andere plek verschijnen.\nOpdracht Laat de appel op een andere plek verschijnen als de slang er een heeft opgegeten.\nTip: hiervoor kun je het blok raak ik \u0026hellip; uit het menu Waarnemen gebruiken.\nKlik om de voorbeeldcode te laten zien  wanneer groene vlag wordt aangeklikt ga naar (willekeurige positie) herhaal als \u0026lt;raak ik (slang hoofd v)?\u0026gt; dan ga naar (willekeurige positie) end    Maak de slang langer Van al die appels groeit de slang natuurlijk wel! Het is nu tijd om de slang langer te maken als je een appel eet. Hiervoor is het eerst nodig dat je bijhoudt hoeveel appels de slang al heeft gegeten, dat kun je ook meteen als je score in het spel gebruiken!\nOpdracht Hou het aantal gegeten appels bij.\nTip 1: hiervoor heb je een variabele nodig, deze maak je in het menu Variabelen.\nTip 2: zet aan het begin van het spel de waarde van de variabele op 0.\nKlik om de voorbeeldcode voor de slang te laten zien  wanneer groene vlag wordt aangeklikt maak [score v] (0) enzovoort    Klik om de voorbeeldcode voor de appel te laten zien  wanneer groene vlag wordt aangeklikt ga naar (willekeurige positie) herhaal als \u0026lt;raak ik (slang hoofd v)?\u0026gt; dan ga naar (willekeurige positie) verander [score v] met (1) end    Nu komt het moeilijkste stukje van het spel: het lijf van de slang! Hiervoor ga je werken met klonen van de slang, deze functies vind je in het menu Besturen. Dit werkt zo:\n het lijf van de slang maak je door op de plek van het hoofd een kloon te maken. het lijf van de slang is het tweede uiterlijk van de slang sprite, om de kop in een lijf te laten veranderen heb je het verander uiterlijk naar blok in het menu Uiterlijken nodig. als je nog geen of weinig appels hebt gegeten, dan wil je zo\u0026rsquo;n kloon meteen - of in ieder geval heel snel - weer laten verdwijnen. hoe meer appels je hebt gegeten dus hoe hoger je score, hoe langer je wilt wachten met het laten verdwijnen van de kloon.  Opdracht Kloon de kop van de slang (bij iedere stap), en laat de kloons na een tijdje weer verdwijnen. Tip: je kunt uitrekenen hoe lang je moet wachten door je score te vermenigvuldigen met hoe lang 1 stap van de slang duurt.\nKlik om de voorbeeldcode voor de slang te laten zien  wanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje omhoog v] ingedrukt?\u0026gt; dan richt naar (0) graden end neem (10) stappen wacht (0.1) sec. maak een kloon van (mijzelf v)    Klik om de voorbeeldcode van kloons van de slang te laten zien  wanneer ik als kloon start verander uiterlijk naar (slang_lijf v) wacht ((score) * (0.1)) sec. verwijder deze kloon    Verliezen als je in jezelf hapt Je hebt nu een slang die steeds langer wordt als ie meer appels eet. Wat nog mist is dat het spel is afgelopen als je slang in zichzelf bijt. Dit gebeurt wanneer een deel van het lijf een ander deel van het lijf raakt.\nOpdracht Zorg ervoor dat het spel stopt als de slang in zichzelf bijt.\nTip: hiervoor kun je weer het raak ik blok gebruiken.\nKlik om de voorbeeldcode te laten zien  wanneer ik als kloon start als \u0026lt;raak ik kleur [#9afeb6]?\u0026gt; dan stop [alle v]    Uitbreidingen Je kunt het spel natuurlijk nog veel mooier, spannender en moeilijker maken. Hier heb je alvast een lijstje met ideeën als je nog verder wil programmeren aan Snake:\n laat de appels na een tijdje weer verdwijnen maak een start- of eindscherm voor het spel laat de slang sneller gaan als je meer appels hebt gegeten laat het spel ook afgelopen zijn als je de rand raakt kies een mooie achtergrond voor je spel laat ook voorwerpen verschijnen die je juist moet ontwijken programmeer het spel voor twee spelers  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 22, 2020","permalink":"/instructies/scratch-snake/","title":"Scratch - Snake"},{"categories":null,"contents":"We gaan met 2D game framework Löve2D het klassieke spel Snake bouwen.\n0. Voorbereiding  Download en installeer LÖVE: https://love2d.org Download en installeer Visual Studio Code: https://code.visualstudio.com/download  1. Introductie Vandaag gaan we aan de slag met het spel Snake. Begin met het downloaden van het materiaal en pak daarna de bestanden uit. Open daarna Visual Studio Code en sleep het mapje met de uitgepakte bestanden in het scherm van Visual Studio Code. Als het goed is zie je nu aan de linkerkant een lijstje met alle bestanden. Met deze bestanden gaan we straks aan de slag. Maar laten we eerst kijken naar de spelregels.\nSpelregels Het doel van het spel Snake is om zoveel mogelijk fruit te eten (dit is je score). Hoe meer je eet, hoe langer de slang wordt en ook beweegt de slang sneller. Als de slang tegen zichzelf botst of buiten het scherm gaat is het game over.\nDus om Snake te bouwen moet het spel het volgende doen:\n Beeweeg de slang met de pijltjestoetsen; Plaats op een willekeurige plek fruit; De slang moet het fruit kunnen eten;  Als er fruit gegeten is moet de slang sneller bewegen; Als er fruit gegeten is moet de slang langer worden; Als er fruit gegeten is krijg je een punt;   Als de slang tegen zichzelf botst is het game over; Ook als de slang buiten het scherm gaat is het game over;  Nu we de spelregels duidelijk hebben en weten wat het spel moet gaan doen, is het tijd om Snake te gaan bouwen!\n2. Aan de slag! We beginnen door het main.lua bestand te openen. Klik hierop in de lijst die je aan de linkerkant ziet. Als je het juiste bestand hebt geopend zie je de volgende code:\nextra = require \u0026quot;extrafuncties\u0026quot; function love.load() end function love.draw() end function love.update(dt) end function love.keypressed(key) end De zogenaamde functions (in het Nederlands functie(-s)) die je hier ziet worden uitgevoerd zodra zij nodig zijn. Zo is er een functie die love.load() heet, waarbinnen we de code zetten om bijvoorbeeld onze plaatjes te laden.\n3. Slangenkop Dus als we bijvoorbeeld de kop van de slang willen laden, typen we de volgende regel tussen function love.load() en de eerstvolgende end.\nslangKopPlaatje = love.graphics.newImage(\u0026quot;plaatjes/slangkop.png\u0026quot;)\nAls je het goed getypd hebt, ziet je code er zo uit:\nextra = require \u0026quot;extrafuncties\u0026quot; function love.load() slangKopPlaatje = love.graphics.newImage(\u0026quot;plaatjes/slangkop.png\u0026quot;) end function love.draw() end function love.update(dt) end function love.keypressed(key) end Als je goed kijkt zie je in het voorbeeld hierboven dat de regel iets verder staat dan alle andere tekst. Dit noemen we inspringen. Als programmeur gebruik je dit om je code beter leesbaar te maken. Je kunt dit zelf doen door je tekstcursor aan het begin van de regel te plaatsen en dan op de toets Tab te drukken.\nSla het programma nu op (Ctrl/Cmd + S). Als je op Windows werkt doe je nu het volgende:\n open een opdrachtprompt door \u0026ldquo;cmd\u0026rdquo; in te typen in het startmenu. voer het volgende commando uit: \u0026ldquo;c:\\Program Files\\LOVE\\love.exe\u0026rdquo; \u0026ldquo;c:\u0026lt;de_map_waar_jouw_programma_staat\u0026gt;\\love\\snake\u0026rdquo;  Als je op een Mac werkt:\n Start LÖVE sleep de map met je Lua-programma op het LÖVE-scherm.  Deze stap doe je vanaf nu elke keer als je iets hebt veranderd aan je programma en je wilt kijken wat er is veranderd.\nAls je een blauw scherm met een \u0026ldquo;Error\u0026rdquo; krijgt dan klopt er iets niet aan je code, controleer die nog een keer.\nWe hebben nu de slangenkop geladen, maar we zien hem nog niet. Hiervoor moeten we naar de love.draw() functie.\nOnder de regel function love.draw() typen we de volgende regel:\nlove.graphics.draw(slangKopPlaatje, 100, 50)\nAls we nu weer opslaan (Ctrl + S) en opnieuw laden zie je (als je de code goed hebt overgetypd) de kop van de slang!\n4. De rest van de slang De slang moet steeds langer worden, dus laten we daarom een stukje aan de slang toevoegen. Ook hier hebben we een plaatje voor nodig. Voeg de volgende regel toe aan de love.load() functie, onder de regel voor het slangKopPlaatje.\nslangLichaamPlaatje = love.graphics.newImage(\u0026quot;plaatjes/slanglichaam.png\u0026quot;)\nOok hier moeten het plaatje na het laden tekenen op het scherm. Dit doen we door de volgende regel toe te voegen aan de love.draw() functie, onder de regel voor het tekenen van het slangKopPlaatje.\nlove.graphics.draw(slangLichaamPlaatje, 50, 50)\nAls je nu het bestand opslaat en opnieuw laden zie je als het goed is nu twee plaatjes van de slang.\nAchtergrond Laten we het spel ook een achtergrondje geven. Dit gaat precies op dezelfde manier als het toevoegen van het slangKopPlaatje.\nIn de love.load() functie voeg je de volgende regel toe, boven het slangKopPlaatje:\nachtergrondPlaatje = love.graphics.newImage(\u0026quot;plaatjes/achtergrond.png\u0026quot;)\nDaarna voeg je deze regel toe aan de love.draw() functie, ook boven het slangKopPlaatje:\nlove.graphics.draw(achtergrondPlaatje)\n5. Bediening en beweging Om de slang te kunnen bewegen is het goed om te weten wanneer de slang moet bewegen. Bijvoorbeeld wanneer de pijltjestoetsen worden ingedrukt. De code voor de bediening zetten we in de love.keypressed(key) functie. Deze functie wordt uitgevoerd zodra je een knop indrukt. Laten we beginnen met te controleren of er een pijltjestoets is ingedrukt. Voeg de volgende twee regels toe aan de love.keypressed(key) functie.\nif key == \u0026quot;left\u0026quot; or key == \u0026quot;right\u0026quot; or key == \u0026quot;up\u0026quot; or key == \u0026quot;down\u0026quot; then end De eerste regel zegt eigenlijk het volgende Als toets links is, of toets rechts is, of toets boven is, of toets beneden is, dan.... Zie je de vergelijkenis?\nNet als bij functies, wordt op de tweede regel ook het woord end gebruikt. Dit wordt gebruikt om aan te geven dat alleen binnen if ... en end iets zal worden uitgevoerd. Hiertussen gaan we de volgende code zetten, altijd op een nieuwe regel.\nPosities, richting en keerpunten Nu we weten wanneer een pijltjestoets is ingedrukt, willen we de slang een andere richting op laten gaan. Dit doen we door een aantal waarden bij te houden. We houden de positie en de richting bij. Dit doen we in een object. Dit object geven we dan de naam nieuwKeerPunt.\nVoeg de volgende regels toe onder de if en boven de eerstvolgende end.\nnieuwKeerPunt = { positieX = 0, positieY = 0, richtingX = 0, richtingY = 0 } In nieuwKeerPunt houden we nu vier waarden bij - de positieX, positieY, richtingX en richtingY.\nDe positieX kan elke positie zijn op de x-as. Dat is dus van de linkerkant naar rechterkant van het scherm. De positieX 0 is helemaal aan de rechterkant. De rechterkant van het scherm is 800 (de breedte van het scherm). De positieY is de positie van boven naar beneden. Hier is 0 de bovenkant van het scherm en 600 de onderkant van het scherm.\nDe richtingX en de richtingY kan 0, -1 of 1 zijn. Als de richtingX -1 is, gaat de slang naar links. Als de richtingX 1 is gaat de slang naar rechts. En als de richtingX 0 is, gaat de slang niet naar rechts of naar links. De richtingY is precies hetzelfde maar dan voor de richting boven en beneden.\nNu staan alle waarden op 0. Maar dit is tijdelijk. We gaan nu kijken welke pijltjestoets is ingedrukt om de richting te veranderen.\nVoeg de volgende code toe onder de code waar we het nieuwKeerPunt hebben toegvoegd en boven de end van de if die we hiervoor hebben toegevoegd.\n if key == \u0026quot;left\u0026quot; then nieuwKeerPunt.richtingX = -1 nieuwKeerPunt.richtingY = 0 elseif key == \u0026quot;right\u0026quot; then nieuwKeerPunt.richtingX = 1 nieuwKeerPunt.richtingY = 0 elseif key == \u0026quot;up\u0026quot; then nieuwKeerPunt.richtingY = -1 nieuwKeerPunt.richtingX = 0 elseif key == \u0026quot;down\u0026quot; then nieuwKeerPunt.richtingY = 1 nieuwKeerPunt.richtingX = 0 end Deze code verandert nu de richting van het nieuwKeerPunt.\nNu moeten we nog de positie van het nieuwKeerPunt aanpassen. Hiervoor gebruiken we de positie van de kop van de slang. Hiervoor hebben we de volgende twee regels code nodig. Voeg deze toe onder de code die je net hebt toegevoegd. Dus tussen de end die hoort bij de laatste elseif en de eerstvolgende end.\n nieuwKeerPunt.positieX = slang[#slang].positieX nieuwKeerPunt.positieY = slang[#slang].positieY if not extra.bestaatKeerPunt(keerPunten, nieuwKeerPunt) then table.insert(keerPunten, nieuwKeerPunt) end Deze code verandert de positie van nieuwKeerPunt naar de positie van het laatste stukje van de slang. Daarna wordt er gecontroleerd of het nieuwKeerPunt al bestaat in het keerPunten object en hieraan toegevoegd als dat niet zo is. Nu bestaat het woord slang nog niet in de code, dus dat zal foutmeldingen opleveren.\nHiervoor moeten we terug naar de love.load() functie. We kunnen dit woord (slang) niet in de love.keypressed(key) functie zetten omdat deze functie elke keer als er op een toets gedrukt wordt, wordt uitgevoerd. Dit zou betekenen dat het woord slang op elke toets vernieuwd wordt. Maar dat willen we niet. We willen hier alle stukjes van de slang gaan bijhouden. Dus, scroll naar boven, naar de love.load() functie.\nVoeg de volgende regel toe aan de love.load() functie - op een nieuwe regel onder love.load().\nslang = {}\nDeze regel maakt een leeg object met de naam slang.\nIn de love.keypressed(key) functie hebben we het nieuwKeerPunt de positie van het laatste stukje van de slang gegeven. Alleen de positie van de slang bestaat nog niet. Om deze toe te voegen. Moeten we een aantal stukjes toevoegen aan het slang object. Sla een regel over en voeg de volgende regels toe onder de vorige code.\n for i = 1, 2 do slangStukje = { positieX = 5+1*i, positieY = 5, richtingX = 1, richtingY = 0 } table.insert(slang, slangStukje) end kop = slang[#slang] Deze code voegt stukjes van de slang toe aan het slang object. Bovenaan zie je for i = 1, 2 do staan. Net als bij de if wordt ook for een end. Als je code tussen for en end zet, wordt deze code 2 keer uitgevoerd. Dus in dit geval worden er 2 stukjes van de slang toegevoegd aan het slang object. De laatste functie table.insert(slang, slangStukje) voegt het stukje toe aan het slang object. En de laatste regel geeft aan waar de kop van de slang zit (het laatste stukje).\nEerder maakten we een nieuwKeerPunt aan (in de love.keypressed(key) functie). Ook nieuwKeerPunt wordt toegevoegd aan een object. Het verschil tussen het slang object is, dat het nieuwKeerPunt wordt toegevoegd elke keer als je een pijltjestoets indrukt. Maar ook hier missen we het object waaraan het toegevoegd moet worden, het keerPunten object.\nDaarom voegen we de volgende regel toe onder wat we zonet hebben toegevoegd:\nkeerPunten = {}\nTekenen op de positie van een slangstukje Nu houden we de positie bij van twee slangstukjes, maar we gebruiken deze posities nog niet om hier een plaatje te tekenen. Voor het tekenen van plaatjes moeten we weer terug naar beneden scrollen, naar de love.draw() functie.\nOm de positie te gebruiken om een stukje te tekenen moeten we de twee regels die we in de love.draw() functie hebben gezet vervangen door de volgende code (zorg er voor dat deze code onder love.draw() en boven end staat):\n for k, slangStukje in pairs(slang) do if k == #slang then love.graphics.draw(slangKopPlaatje, slangStukje.positieX*slangKopPlaatje:getWidth(), slangStukje.positieY*slangKopPlaatje:getHeight()) else love.graphics.draw(slangLichaamPlaatje, slangStukje.positieX*slangLichaamPlaatje:getWidth(), slangStukje.positieY*slangLichaamPlaatje:getHeight()) end end Als je de code juist hebt toegevoegd, het bestand hebt opgeslagen (Ctrl + S) en opnieuw hebt geladen, zou je nu de slang ongeveer in het midden van het scherm moeten zien.\nBewegen Nu is het tijd om de slang daadwerkelijk te laten bewegen. Hiervoor moeten we naar de functie love.update(dt). Deze functie zorgt er voor alles wordt berekend. Dus ook de beweging moet berekend worden. Voeg de volgende regels toe aan de love.update(dt) functie:\n if not gameOver and tellerSlang \u0026gt; tijdSlang then beweegSlang() extra.controleerKeerPunten(keerPunten, slang) tellerSlang = 0 end tellerSlang = tellerSlang + dt Aan de love.load() moet je de volgende regels toevoegen. Doe dit onderaan in de love.load() functie, boven de end.\n tijdSlang = 1 tellerSlang = 0 gameOver = false In de love.update(dt) functie mist alleen nog de beschrijving van de functie beweegSlang(). Deze moeten we zelf schrijven. Dit doen we helemaal onderaan. Op een nieuwe regel voeg je de volgende regels toe:\nfunction beweegSlang() for k, slangStukje in pairs(slang) do for k, keerPunt in pairs(keerPunten) do if slangStukje.positieX == keerPunt.positieX and slangStukje.positieY == keerPunt.positieY then slangStukje.richtingX = keerPunt.richtingX slangStukje.richtingY = keerPunt.richtingY end end slangStukje.positieX = slangStukje.positieX + slangStukje.richtingX slangStukje.positieY = slangStukje.positieY + slangStukje.richtingY end end Als je deze code opslaat en het programma opnieuw laadt zal de slang nu langzaam over het scherm bewegen!\n6. Fruit Fruit plaatsen Nu de slang kan bewegen, kunnen we hem fruit laten eten. Laten we hiervoor teruggaan naar de love.load() functie en een fruit object aanmaken. Dit doen we door de volgende regels toe te voegen, waar je wilt, in de love.load() functie:\nfruit = {} tellerFruit = 0 tijdFruit = 3 appelPlaatje = love.graphics.newImage(\u0026quot;plaatjes/appel.png\u0026quot;) Nu we alle waarden en het plaatje hebben geladen moeten we ergens het fruit object vullen met fruit. Dit doen we in de love.update(dt) functie.\n if not gameOver and tellerFruit \u0026gt; tijdFruit then plaatsFruit() tellerFruit = 0 end tellerFruit = tellerFruit + dt Nu hoeven we alleen nog de missende, plaatsFruit() functie maken. Net als bij de beweegSlang() functie, plaatsen we de plaatsFruit() functie helemaal onderaan. Voeg deze code toe:\nfunction plaatsFruit() nieuwFruit = { positieX = math.random(0, math.floor(love.graphics.getWidth()/appelPlaatje:getWidth())), positieY = math.random(0, math.floor(love.graphics.getHeight()/appelPlaatje:getHeight())) } table.insert(fruit, nieuwFruit) end Deze functie voegt op een willekeurige plaats een stuk fruit toe. We zien alleen het fruit nog niet op het scherm verschijnen. Hiervoor moeten we terug naar de love.draw() functie. De volgorde van je code in de love.draw() functie bepaald wat er eerst getekend moet worden. Dus als we de appels onder de slang willen tekenen, moeten we de volgende code, boven de code van de slang plaatsen (binnen de love.draw() functie):\n for k, stukFruit in pairs(fruit) do love.graphics.draw(appelPlaatje, stukFruit.positieX*appelPlaatje:getWidth(), stukFruit.positieY*appelPlaatje:getHeight()) end Als nu opslaan en het programma opnieuw laden, zien we nu appels verschijnen op het scherm. Omdat tijdFruit 3 is, wordt er elke 3 seconden een appel toegevoegd.\nFruit eten Als we nu met de slang over een stukje fruit bewegen, gebeurd er niets. Maar we willen dus het fruit opeten. Hiervoor moeten we weer zelf een functie schrijven, de functie eetFruit(). Voeg deze code toe, helemaal onderaan:\nfunction eetFruit() for k, stukFruit in pairs(fruit) do if stukFruit.positieX == kop.positieX and stukFruit.positieY == kop.positieY then table.remove(fruit, k) score = score + 1 tijdSlang = tijdSlang * 0.9 maakSlangLanger() end end end Voeg daarna de volgende regel toe, na extra.controleerKeerPunten(keerPunten, slang), in de love.update(dt) functie:\neetFruit()\nAls de eetFruit() functie wordt uitgevoerd, gebeuren er een aantal dingen:\n Het fruit wordt verwijderd - table.remove(fruit, k) Je krijgt een score - score = score + 1 De slang gaat sneller bewegen - tijdSlang = tijdSlang * 0.9 En de slang wordt langer - maakSlangLanger()  De laatste functie ontbreekt nog, de maakSlangLanger() functie. Voeg deze toe, ook helemaal onderaan:\nfunction maakSlangLanger() staartStukje = slang[1] nieuwSlangStukje = { positieX = staartStukje.positieX-staartStukje.richtingX, positieY = staartStukje.positieY-staartStukje.richtingY, richtingX = staartStukje.richtingX, richtingY = staartStukje.richtingY } table.insert(slang, 1, nieuwSlangStukje) end Deze code voegt een stukje van de slang toe, waar de staart is. Dit stukje wordt dan toegevoegd aan het slang object, waar zich ook alle andere stukjes bevinden.\n7. Score Als we nu onze code zouden uitvoeren, zouden we een foutmelding krijgen omdat het score object nog niet bestaat. Deze moeten we nog toevoegen aan de love.load() functie. Dus voeg de volgende regel toe aan je love.load() functie, op een nieuwe regel:\nscore = 0\nEn om de score op het scherm te tonen, voegen we de volgende regel toe aan de love.draw() functie:\nlove.graphics.print(score .. \u0026quot; punten\u0026quot;)\nAls we nu de code opslaan en opnieuw laden, zal de slang steeds langer worden en sneller gaan zodra je meer appels eet.\n8. Game Over Het spel mist nu alleen nog twee spelregels. Je moet game over gaan als de slang tegen zichzelf botst of buiten het scherm gaat.\nOm dit te controleren maken we nog één functie. Voeg deze code toe, helemaal onderaan:\nfunction controleerGameOver() if kop.positieX \u0026lt; 0 or kop.positieX \u0026gt; math.floor(love.graphics.getWidth()/slangKopPlaatje:getWidth()) or kop.positieY \u0026lt; 0 or kop.positieY \u0026gt; math.floor(love.graphics.getHeight()/slangKopPlaatje:getHeight()) then gameOver = true end for k, slangStukje in pairs(slang) do if slangStukje ~= kop and kop.positieX == slangStukje.positieX and kop.positieY == slangStukje.positieY then gameOver = true end end end Voeg daarna de volgende regel toe na eetFruit() in de love.update(dt) functie:\ncontroleerGameOver()\nEn tot slot voegen we de volgende regels toe aan het einde van de love.draw() functie om een bericht te tonen dat je game over bent:\n if gameOver then love.graphics.print(\u0026quot;Game Over!\u0026quot;, love.graphics.getWidth()/2, love.graphics.getHeight()/2) end Goed gedaan! En dat is het, je hebt het spel Snake gebouwd! Hoe lang hou jij het vol en wat is de hoogste score die je kunt krijgen?\nHeb je iets niet goed begrepen, vraag het dan aan één van de mentoren, we helpen je natuurlijk graag!\nJe kunt ook altijd een kijkje nemen bij de andere kinderen, misschien kan jij hun helpen!\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"February 6, 2020","permalink":"/instructies/love2d-snake/","title":"Löve2D - Snake"}]