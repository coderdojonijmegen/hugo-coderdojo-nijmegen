[{"categories":null,"contents":"We gaan met 2D game framework Löve2D een spel met vallende blokken maken.\nDe regels Er zijn 7 verschillende stukken. Elk stuk bestaat uit 4 kleinere blokken.\nStukken vallen vanaf boven het speelveld. De speler kan het stuk verplaatsen naar links en rechts en het stuk ronddraaien. Als een stuk is geland, valt er een volgend stuk.\nBoven het speelveld wordt de vorm van het volgende stuk dat gaat vallen getoond.\nAls er een volledig gesloten rij van blokken is gevormd van links naar rechts op het speelveld, verdwijnt het en schuiven alle blokken erboven 1 rij naar beneden.\nHet spel eindigt als een nieuw stuk direct op een al liggend stuk terecht zou komen.\nControls    toets actie     pijl links beweeg links   pijl rechts beweeg rechts   z draai tegen de klok in   x draai met de klok mee   c val op liggende blokken    Overzicht Een rooster bevat de blokken die al zijn gevallen. Een vak in het rooster kan leeg zijn of gevuld met een blok van een bepaalde kleur.\nTekst ' ' (spatie) is een leeg vak zonder blok en 'i', 'j', 'l', 'o', 's', 't' en 'z' zijn vakken met een blok met verschillende kleuren.\nAlle verschillende stukken worden in het rooster opgeslagen met de hoe ze gedraaid waren toen ze vielen.\nEen vallend stuk wordt opgeslagen met een getal dat aangeeft welk type stuk het is, hoe het gedraaid is en wat de positie is in het rooster. Voor de positie worden X en Y waarden gebruikt.\nEen nieuw stuk wordt boven het rooster getoond, maar niet als er te weinig voor is door al gestapelde blokken. In dat geval is het spel afgelopen.\nDe speler kan de stukken verplaatsen naar links en rechts, maar niet als het een stuk dat al gestapeld is overlapt. Een stuk kan ook niet buiten het rooster verplaatst worden.\nAls er wat tijd is verlopen, verplaatst het stuk één rij blokken naar beneden. Dit gebeurt alleen als de nieuwe positie van het stuk niet overlapt met al gestapelde blokken en niet buiten het rooster valt.\nAls knop z of x wordt ingedrukt, draait het stuk tegen de klok in of met de klok mee. Maar niet als het stuk dan overlapt met al gestapelde blokken of buiten het rooster valt.\nAls de val knop c wordt ingedrukt, gaat het stuk sneller naar beneden, totdat het landt op al geplaatste stukken.\nAls het stuk is geland, wordt een nieuw stuk gemaakt boven het rooster.\nDe 7 verschillende stukken worden in een willekeurige volgorde aangeboden.\nProgrammeren Voor het programmeren zelf heb je alleen een editor zoals bijvoorbeeld Visual Studio Code nodig. Maar om het programma uit te voeren, heb je het Löve2D programma nodig. Deze kun je downloaden vanaf de site https://love2d.org/.\nAls je Löve2D hebt geïnstalleerd, open je een terminal of cmd op Windows en zou je love.exe moeten kunnen starten.\nBij het starten van het script is het belangrijk om te onthouden dat je de directory meegeeft aan Love en niet main.lua.\nDus:\nlove.exe blocks/ Hierbij bevat blocks het bestand main.lua waarin we de code schrijven van de volgende hoofdstukken.\nHet venster tekenen We beginnen in een lege conf.lua met:\nfunction love.conf(t) t.window.width = 20 * 14 t.window.height = 20 * 25 end conf.lua\nen een lege main.lua.\nAls je nu love.exe blocks/ uitvoert, krijg je een leeg rechthoekig scherm.\nHet rooster tekenen Voor ieder blok in het speelveld wordt een vierkant getekend.\nZet de volgende code in main.lua:\nfunction love.draw() for y = 1, 18 do for x = 1, 10 do local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end end end main.lua Het rooster inkleuren De achtergrondkleur en de kleur van een leeg vak worden ingesteld.\nVoeg functie love.load() toe aan main.lua, boven functie love.draw() die er al in staat:\nfunction love.load() love.graphics.setBackgroundColor(255, 255, 255) end main.lua\nPas nu functie love.draw() aan:\nfunction love.draw() for y = 1, 18 do for x = 1, 10 do -- voeg toe: love.graphics.setColor(.87, .87, .87) -- local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end end end main.lua De gevallen blokken bewaren Het rooster voor de gevallen blokken is gemaakt en elk blok wordt als ' ' (spatie) gezet wat betekend dat het vak leeg is.\nWe gaan de breedte en hoogte van het rooster gebruiken om de blokken te tekenen, dus we zetten de waarden 10 en 18 in variabelen.\nPas de functies aan met:\nfunction love.load() love.graphics.setBackgroundColor(255, 255, 255) -- voeg onderstaande toe: gridXCount = 10 gridYCount = 18 inert = {} for y = 1, gridYCount do inert[y] = {} for x = 1, gridXCount do inert[y][x] = \u0026#39; \u0026#39; end end -- end function love.draw() -- vervang: for y = 1, 18 do for x = 1, 10 do -- door: for y = 1, gridYCount do for x = 1, gridXCount do -- end main.lua\nDe kleur van de blokken De kleur van de blokken die we gaan tekenen wordt bepaald door het type.\nOm dit testen, zetten we verschillende typen blokken in het rooster.\nDe types geven we aan met een letter: i, j, l, o.. etc. Vervolgens koppelen we een kleur aan elk type.\nBijvoorbeeld:\ni = {.47, .76, .94}, Maak de volgende aanpassingen:\nfunction love.load() -- voeg toe: inert[18][1] = \u0026#39;i\u0026#39; inert[17][2] = \u0026#39;j\u0026#39; inert[16][3] = \u0026#39;l\u0026#39; inert[15][4] = \u0026#39;o\u0026#39; inert[14][5] = \u0026#39;s\u0026#39; inert[13][6] = \u0026#39;t\u0026#39; inert[12][7] = \u0026#39;z\u0026#39; -- end function love.draw() for y = 1, gridYCount do for x = 1, gridXCount do -- vervang: love.graphics.setColor(.87, .87, .87) -- door dit: local colors = { [\u0026#39; \u0026#39;] = {.87, .87, .87}, i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, } local block = inert[y][x] local color = colors[block] love.graphics.setColor(color) -- tot hier toe. local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) -- end end end main.lua De stukken opslaan Een puzzelstuk bestaat uit verschillende blokken. We slaan de variaties van puzzelstuk op als een nieuw raster. In dit raster kunnen we ook de gedraaide versies van het puzzelstuk bewaren.\n{ {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, } Elk puzzelstuk kan 4 varianten hebben, want hij kan 4 kanten op gedraaid zijn. We slaan dus 4 varianten op voor elk puzzelstuk. In het geval van de rechte lijn zijn dit er eigenlijk maar 2. Deze vorm is namelijk symmetrisch over 1 as. De kubus heeft maar 1 variant. Deze is namelijk symmetrisch over 2 assen. De rechte lijn ziet er als volgt uit:\n{ { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, } Dit zijn alle puzzelstukken; voeg deze toe aan functie love.load():\nfunction love.load() love.graphics.setBackgroundColor(255, 255, 255) pieceStructures = { { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;s\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;s\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;z\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;z\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, } main.lua\nHet vallende stuk opslaan Er kan altijd maar een puzzelstuk tegelijkertijd vallen. We kunnen dit puzzelstuk opslaan met de variabelen pieceType en pieceRotation. pieceType bevat welk stuk het is (lijn, blokje, etc). pieceRotation bevat hoe het stuk gedraaid is.\nfunction love.load() -- voeg toe aan het einde van de functie: pieceType = 1 pieceRotation = 1 -- end main.lua\nHet stuk tekenen Elk puzzelstuk wordt getekend door langs elk vakje in het rooster te gaan en de blokken een voor een in te kleuren.\nDe kleur is afhankelijk van het type blok.\nfunction love.draw() -- voeg dit hele stuk code toe onderaan deze functie for y = 1, 4 do for x = 1, 4 do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then local colors = { i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, } local color = colors[block] love.graphics.setColor(color) local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end end end -- end main.lua\nEn verwijder dit stuk uit functie love.load():\ninert[18][1] = \u0026#39;i\u0026#39; inert[17][2] = \u0026#39;j\u0026#39; inert[16][3] = \u0026#39;l\u0026#39; inert[15][4] = \u0026#39;o\u0026#39; inert[14][5] = \u0026#39;s\u0026#39; inert[13][6] = \u0026#39;t\u0026#39; inert[12][7] = \u0026#39;z\u0026#39; main.lua\nCode vereenvoudigen De code voor het tekenen van een stilstaand blok lijkt erg op de code voor het tekenen van een vallend blok. We voegen daarom de functie drawBlock toe en verplaatsen de code in de twee for-loops er naartoe.\nVervang alle code in love.draw() met deze code:\nfunction love.draw() local function drawBlock(block, x, y) local colors = { [\u0026#39; \u0026#39;] = {.87, .87, .87}, i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, } local color = colors[block] love.graphics.setColor(color) local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end for y = 1, gridYCount do for x = 1, gridXCount do drawBlock(inert[y][x], x, y) end end for y = 1, 4 do for x = 1, 4 do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x, y) end end end end main.lua\nHet stuk draaien Wanneer we op de x-toets drukken willen wat dat het stuk draait.\npieceRotation bevat een getal dat de draaiing aangeeft. 1 is geen draaiing, 2 is 90° met de klok mee en 3 is 180°.\nAls het rotation getal hoger is dan de verschillende draai posities (4, 2 of 1). Dan wordt het getal terug gezet naar 1.\nAls we op z-toets drukken willen we dat het het stuk de andere kant op draait. Dit doen we door de waarde in pieceRotation met 1 te verlagen.\nAls het getal lager wordt dan 0. Zetten we het weer terug naar 1.\nVoeg dit stuk code toe onderaan het bestand:\nfunction love.keypressed(key) if key == \u0026#39;x\u0026#39; then pieceRotation = pieceRotation + 1 if pieceRotation \u0026gt; #pieceStructures[pieceType] then pieceRotation = 1 end elseif key == \u0026#39;z\u0026#39; then pieceRotation = pieceRotation - 1 if pieceRotation \u0026lt; 1 then pieceRotation = #pieceStructures[pieceType] end end end main.lua\nDe stukken testen We willen graag de code testen. Daarom voegen we toe dat we het puzzelstuk kunnen veranderen met de omhoog en omlaag pijltjestoetsen.\nDe tijdelijke code onderaan functie love.keypressed(key):\nfunction love.keypressed(key) -- vervang laatste twee \u0026#34;end\u0026#34; regels met onderstaande tijdelijke code: elseif key == \u0026#39;down\u0026#39; then pieceType = pieceType + 1 if pieceType \u0026gt; #pieceStructures then pieceType = 1 end pieceRotation = 1 elseif key == \u0026#39;up\u0026#39; then pieceType = pieceType - 1 if pieceType \u0026lt; 1 then pieceType = #pieceStructures end pieceRotation = 1 end -- end main.lua\nAls je hebt gezien dat de stukken veranderen, kun je de net toegevoegde code weer verwijderen.\nDe positie van het vallende stuk bijhouden We bewaren de positie van het vallende puzzelstuk op in het rooster en we tekenen het puzzelstuk op die positie.\nfunction love.load() -- voeg deze regels toe onderaan deze functie pieceX = 3 pieceY = 0 -- end En het tekenen van het blok op de juiste positie:\nfunction love.draw() -- vervang: drawBlock(block, x, y) -- met: drawBlock(block, x + pieceX, y + pieceY) -- end main.lua\nHet stuk verplaatsen We gaan nu de linker en rechter pijltjestoetsen gebruiken om het stuk te verplaatsen.\nVoeg de volgende regels toe onderaan love.keypressed(key):\nfunction love.keypressed(key) -- vervang de een na laatste \u0026#34;end\u0026#34; met:  elseif key == \u0026#39;left\u0026#39; then pieceX = pieceX - 1 elseif key == \u0026#39;right\u0026#39; then pieceX = pieceX + 1 end -- end main.lua\nTimer We willen dat elke 0.5 seconden het puzzelstuk valt.\nWe maken daarom een timer variabele, die we steeds met dt (delta time: de tijd die verstreken is) verhogen.\nAls de waarde van timer gelijk aan 0.5 of hoger is, zetten we het terug naar 0.\nfunction love.load() -- onderaan deze functie: timer = 0 -- end En een nieuwe functie onderaan het bestand:\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 -- tijdelijk; kijk naar de console/cmd window voor een tick elke halve seconde print(\u0026#39;tick\u0026#39;) -- end end main.lua\nNa het testen mag je print('tick') weer weghalen.\nStukken vallen We gebruiken de timer om het stuk elke 0.5 seconden verder naar beneden te laten vallen.\nDe waarde van pieceY wordt met 1 verhoogd om het stuk 1 regel lager te tekenen:\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 -- voeg toe: pieceY = pieceY + 1 -- end end main.lua\nLinker, rechter en onderrand van het rooster We willen voorkomen dat de puzzelstukken links of rechts van het scherm af kunnen bewegen. Daarom checken we altijd eerst of alle blokken nog wel in het speelveld zijn.\nWe willen deze check vaker uitvoeren, daarom stoppen we het in een functie. Dan kunnen we het makkelijk herbruiken. De functie heeft de positie en rotatie nodig. De functie geeft true of false terug om aan te geven of we mogen bewegen of draaien.\nWe noemen de functie: canpieceMove(testX, testY, testRotation). Voor nu zal de functie alleen true teruggeven, dan kunnen we namelijk de functie in de rest van de code verwerken.\nWe passen de code aan zodat de check functie eerst wordt uitgevoerd, voordat we bewegen of draaien.\nfunction love.load() -- voeg aan het einde van de functie toe: function canPieceMove(testX, testY, testRotation) return true end -- end function love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 -- vervang: pieceY = pieceY + 1 -- door: local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY end -- end end function love.keypressed(key) elseif key == \u0026#39;left\u0026#39; then -- vervang: pieceX = pieceX - 1 -- door: local testX = pieceX - 1 if canPieceMove(testX, pieceY, pieceRotation) then pieceX = testX end -- elseif key == \u0026#39;right\u0026#39; then -- vervang: pieceX = pieceX + 1 -- door:  local testX = pieceX + 1 if canPieceMove(testX, pieceY, pieceRotation) then pieceX = testX end -- end end main.lua\nLinks We beginnen met links checken. Als het blok niet leeg is, en de x positie lager is dan 1, geeft de functie false terug.\nfunction love.load() -- vervang functie canPieceMove in zijn geheel door: function canPieceMove(testX, testY, testRotation) for y = 1, 4 do for x = 1, 4 do if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and (testX + x) \u0026lt; 1 then return false end end end return true end -- end main.lua\nCode vereenvoudigen Het aantal blokken van elk puzzelstuk op de X en Y worden herbruikt uit het tekenen. We stoppen deze waardes in variabelen.\nfunction love.load() -- vervang functie canPieceMove weer, maar nu in zijn geheel door: pieceXCount = 4 pieceYCount = 4 function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and (testX + x) \u0026lt; 1 then return false end end end return true end -- end function love.draw() -- vervang: for y = 1, 4 do for x = 1, 4 do -- door:  for y = 1, pieceYCount do for x = 1, pieceXCount do -- local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x + pieceX, y + pieceY) end end end end main.lua\nRechts We gaan nu rechts checken. Als het blok niet leeg is, en de x positie groter is dan het grid, geeft de functie false terug.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do -- vervang if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and (testX + x) \u0026lt; 1 then return false end -- door: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ((testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount) then return false end -- end end return true end end main.lua\nOnderkant Het puzzelstuk moet stoppen als het de onderkant aanraak. Als de onderkant van het puzzelstuk lager is dan de onderkant van het veld geeft de functie false terug.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do -- vervang: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ((testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount) then return false end -- door: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount ) then return false end -- end end return true end end main.lua\nControle op botsingen Als er al een ander puzzelstuk is, kan het puzzelstuk daar niet naartoe bewegen. Daarom checken we of er al een blok is op die plek. Als dat zo is, geeft de functie ook false terug.\nWe testen dit door zelf een blokje op het rooster te zetten.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and -- vervang:  ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount ) -- door: ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount or inert[testY + y][testX + x] ~= \u0026#39; \u0026#39; ) --  then return false end end end return true end -- tijdelijk, om toegevoegde voorwaarde te testen inert[8][5] = \u0026#39;z\u0026#39; -- end main.lua\nAls het stuk valt, wordt het geblokkeerd door het blok. Schuif het stuk eens naar links of rechts. Wat gebeurt er?\nVerwijder na het testen de tijdelijke code.\nCode vereenvoudigen De posities van de blokken die we testen kunnen we herbruiken. We stoppen deze in variabelen.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do -- vervang: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount or inert[testY + y][testX + x] ~= \u0026#39; \u0026#39; ) then return false end -- door:  local testBlockX = testX + x local testBlockY = testY + y if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ( testBlockX \u0026lt; 1 or testBlockX \u0026gt; gridXCount or testBlockY \u0026gt; gridYCount or inert[testBlockY][testBlockX] ~= \u0026#39; \u0026#39; ) then return false end -- end end return true end end main.lua\nSneller vallen Als de speler c indrukt laten we het puzzelstuk snel vallen. Zolang c is ingedrukt verhogen we de Y positie met 1 totdat het puzzelstuk iets raakt.\nfunction love.keypressed(key) -- voeg elseif key == \u0026#39;c\u0026#39; then while canPieceMove(pieceX, pieceY + 1, pieceRotation) do pieceY = pieceY + 1 end -- toe voor de één na laatste \u0026#34;end\u0026#34; end end main.lua\nEen stuk terugzetten Als de timer tikt, en het puzzelstuk niet verder kan bewegen, resetten we de positie en rotatie en type.\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 local testY = pieceY + 1 -- vervang: if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY end -- door: if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 end -- end end main.lua\nCode vereenvoudigen We resetten het puzzelstuk vaker, dus we stoppen de code in een functie om her te gebruiken.\nfunction love.load() -- voeg toe aan einde van functie  function newPiece() pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 end newPiece() --  end function love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else -- vervang: pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 -- door: newPiece() -- end end end main.lua\nEen reeks met volgende stukken We maken nu een sequence (volgorde) waarin de puzzelstukken gaan vallen. We slaan deze op als een tabel met getallen die aangeven welk puzzelstuk het is.\nWe stoppen alle verschillende nummers/puzzelstuk types in de tabel op een willekeurige positie.\nWe testen dit door een reeks te maken en te printen als je op s drukt\nfunction love.load() -- voeg toe aan einde van functie  function newSequence() sequence = {} for pieceTypeIndex = 1, #pieceStructures do local position = love.math.random(#sequence + 1) table.insert( sequence, position, pieceTypeIndex ) end end newSequence() -- end function love.keypressed(key) -- tijdelijke code elseif key == \u0026#39;s\u0026#39; then newSequence() print(table.concat(sequence, \u0026#39;, \u0026#39;)) -- end end main.lua\nResultaat van drukken op knop s in tijdelijke code:\n3, 2, 4, 1, 7, 5, 6\nVerwijder de tijdelijke code na het testen.\nEen nieuw stuk uit de reeks Wanneer er een nieuw puzzelstuk wordt gemaakt, halen we de vorige uit de reeks en herbruiken we het.\nAls de reeks leeg is, is maken we een nieuwe.\nWe verplaatsen de newPiece functie naar onder de newSequence functie.\nfunction love.load() -- vervang: function newPiece() pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 end -- door: function newPiece() pieceX = 3 pieceY = 0 pieceRotation = 1 pieceType = table.remove(sequence) if #sequence == 0 then newSequence() end end -- newPiece() end main.lua\nGevallen stukken bewaren Als een stuk is gevallen, worden ze apart gezet en bewaard.\nElk blok in het stuk wordt bekeken en als het niet leeg is, wordt het blok als bezet gezet.\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else -- voeg toe for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then inert[pieceY + y][pieceX + x] = block end end end -- newPiece() end end end main.lua\nEen nieuw stuk direct na landing vorige Als een stuk is gevallen, wordt de timer direct opnieuw ingesteld, zodat een volgende stuk direct wordt gemaakt.\nfunction love.load() -- vervang: pieceY = 0 timer = 0 pieceXCount = 4 -- door:  pieceY = 0 timer = 0 timerLimit = 0.5 pieceXCount = 4 --  end function love.update(dt) -- vervang: timer = timer + dt if timer \u0026gt;= 0.5 then -- door: timer = timer + dt if timer \u0026gt;= timerLimit then --  end function love.keypressed(key) elseif key == \u0026#39;c\u0026#39; then -- vervang: while canPieceMove(pieceX, pieceY + 1, pieceRotation) do pieceY = pieceY + 1 end -- door:  while canPieceMove(pieceX, pieceY + 1, pieceRotation) do pieceY = pieceY + 1 timer = timerLimit end -- end end main.lua\nVolle rijen vinden Elke rij wordt gecontroleerd. Als er geen legen blokken in de rij zijn, is de rij compleet.\nOm te controleren of het werkt worden complete rijen geprint naar de console.\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= timerLimit then timer = 0 local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then inert[pieceY + y][pieceX + x] = block end end end -- voeg toe:  for y = 1, gridYCount do local complete = true for x = 1, gridXCount do if inert[y][x] == \u0026#39; \u0026#39; then complete = false break end end -- tijdelijke code if complete then print(\u0026#39;Complete row: \u0026#39;..y) end -- end --  newPiece() end end end main.lua\nVolle rijen verwijderen Als een rij compleet is,\nIf the row is complete, the rows from the complete row to the row second from the top are looped through.\nEach block in the row is looped through and set to the value of the block above it. Because there is nothing above the top row it doesn\u0026rsquo;t need to be looped through.\nThe top row is then set to all empty blocks.\nDe volledige code tot op dit punt:\nfunction love.update(dt) for y = 1, gridYCount do local complete = true for x = 1, gridXCount do if inert[y][x] == \u0026#39; \u0026#39; then complete = false break end end -- vervang: if complete then -- tijdelijke code print(\u0026#39;Complete row: \u0026#39;..y) end -- door: if complete then for removeY = y, 2, -1 do for removeX = 1, gridXCount do inert[removeY][removeX] = inert[removeY - 1][removeX] end end for removeX = 1, gridXCount do inert[1][removeX] = \u0026#39; \u0026#39; end end -- end end main.lua\nGame over Als een nieuw stuk meteen niet meer verplaatst kan worden omdat er andere blokken in de weg staan, is het spel over.\nlove.load wordt aangeroepen om het spel opnieuw te starten.\nfunction love.update(dt) -- voeg toe aan het einde van deze functie if not canPieceMove(pieceX, pieceY, pieceRotation) then love.load() end -- end end end main.lua\nHet rooster verplaatsen in het window Tot nu toe is het rooster aan de linker boven kant van het venster getekend. We gaan het nu in het midden een stukje van de bovenrand van het venster zetten.\nfunction love.draw() -- vervang: for y = 1, gridYCount do for x = 1, gridXCount do drawBlock(inert[y][x], x, y) end end for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x + pieceX, y + pieceY) end end end -- door:  local offsetX = 2 local offsetY = 5 for y = 1, gridYCount do for x = 1, gridXCount do drawBlock(inert[y][x], x + offsetX, y + offsetY) end end for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x + pieceX + offsetX, y + pieceY + offsetY) end end end -- end main.lua\nHet volgende stuk Het volgende stuk uit de reeks dat gaat vallen, wordt boven het rooster getekend.\nfunction love.draw() local function drawBlock(block, x, y) local colors = { [\u0026#39; \u0026#39;] = {.87, .87, .87}, i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, -- voeg toe: preview = {.75, .75, .75}, -- } -- voeg toe aan het eind van de functie for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[sequence[#sequence]][1][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(\u0026#39;preview\u0026#39;, x + 5, y + 1) end end end -- end main.lua\nHet spel herstarten Als het spel is afgelopen, wordt het herstart. Daarvoor moeten wat variabelen opnieuw worden ingesteld.\nDe code hierovor zetten we in een functie.\nfunction love.load() -- voeg toe aan het einde van de functie function reset() inert = {} for y = 1, gridYCount do inert[y] = {} for x = 1, gridXCount do inert[y][x] = \u0026#39; \u0026#39; end end newSequence() newPiece() timer = 0 end reset() -- end function love.update(dt) -- vervang: if not canPieceMove(pieceX, pieceY, pieceRotation) then love.load() end -- met: if not canPieceMove(pieceX, pieceY, pieceRotation) then reset() end -- end end end main.lua\nVeel plezier met spelen!\nBron Deze instructie is een vertaling van de Engelstalige tutorial Blocks: A tutorial for Lua and LÖVE 11 van simple.game.tutorials@gmail.com.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"January 20, 2023","permalink":"/instructies/love2d-blocks/","title":"Löve2d - Blocks"},{"categories":null,"contents":"Een Raspberry Pi is een mini-computer waar je allerlei leuke dingen mee kunt doen. Je kan de Raspberry Pi als computer gebruiken. Daarnaast kun je er ook allerlei apparaatjes en elektronische schakelingen aan koppelen.\nWe gaan met bewegingssensoren, afstandssensoren en een stappenmotor aan de slag.\nDe Raspberry Pi aansluiten Zoals hierboven genoemd is een Raspberry Pi een mini-computer, waar je net als een gewone computer een scherm, toetsenbord en muis op moet aansluiten. Via de volgende stappen bereiden we de Raspberry Pi voor op gebruik:\n In de doos van de Raspberry Pi zit een HDMI-kabel die je op het scherm aansluit en op aansluiting 1. Op USB aansluitingen 2 en 3 sluit je het toetsenbord en de muis aan. Tenslotte pak je de voeding uit de doos en sluit je deze aan op aansluiting 4 en in het stopcontact.  Zodra je de stroom hebt aangesloten, begint de Raspberry Pi op te starten. Als het scherm aanstaat, kan je zien hoe de computer opstart.\nDe software De Raspberry Pi\u0026rsquo;s die we gebruiken zijn al wat ouder en daardoor niet zo snel. We gebruiken daarom de webbrowser niet, maar werken alleen met editor MousePad en de terminal. Deze zijn te zien op de volgende afbeelding:\nMet MousePad maken we de *.py bestanden met daarin de code. Vervolgens voeren we die uit in de terminal met het commando:\nsudo python3 \u0026lt;scriptnaam\u0026gt;.py Een led aansturen We gaan beginnen met het aanzetten van een led lampje met de Raspberry Pi. Hiervoor hebben we nodig:\n Een led lampje Een weerstandje (330 ohms) Een paar draadjes Een breadboard  \rWe gaan nu eerst de draadjes aansluiten, hoe dat moet is te zien op de afbeelding hieronder. We verbinden de 3.3 volt aansluiting op de Raspberry Pi met de onderste rij op het breadboard. We verbinden de GROUND met de rij erboven op het breadboard. Daarna pluggen we de weerstand en het ledje in zoals het op de afbeelding staat. Als laatste verbinden we de weerstand en het ledje met de rijen op het breadboard, en het bruine draadje met de controller pin op de Raspberry Pi.   De pins op de afbeelding zijn hetzelfde als op jouw Raspberry Pi, je kan dus tellen waar de draadjes horen te zitten!\nHet led lampje gaat nu nog niet branden, dat komt omdat het circuit nog niet compleet is. We hebben net de led aangesloten op de GND en op de controller pin met het bruine draadje. Om het circuit compleet te maken en het ledje aan te laten gaan moeten we de controller pin aanzetten. De pin die wij hebben gebruikt heet pin 18. We moeten dus met code pin 18 gaan aanzetten. Dit dit we in Python als volgt:\nfrom gpiozero import LED led = LED(18) while True: led.on() De bovenstaande code begint met het importeren van de code (gpiozero) om de pin te besturen. Hierna zeggen we dat er een ledje zit op pin 18 met de regel code: LED(18). Daarna zetten we deze led aan. Start het script met:\npython3 script.py Het ledje zou nu moeten aangaan.  \nWe kunnen het ledje laten knipperen door ons script te vervangen met het volgende script:\nfrom gpiozero import LED from time import sleep led = LED(18) while True: led.on() sleep(1) led.off() sleep(1) Dit werkt door de led steeds aan- en uit te zetten. Tussendoor pauzeren we het programma met sleep(1). Door het getal hier aan te passen kan je de led sneller of langzamer laten knipperen. Probeer bijvoorbeeld sleep(5) uit!\nEen led met een schakelaar De volgende stap is het toevoegen van een echte knop om de led mee te bedienen. Hiervoor moeten we eerst het onderstaande circuit nabouwen. Dit circuit is al wat lastiger, vraag daarom gerust om hulp als je deze nodig hebt! \nDe knop is aangesloten op pin 2 (met het gele draadje op de afbeelding). Als je de knop indrukt is het circuit compleet en staat er spanning op pin 2. Dit kunnen wij uitlezen met Python:\nfrom gpiozero import Button button = Button(2) while True: if button.is_pressed: print(\u0026#34;Button is pressed\u0026#34;) else: print(\u0026#34;Button is not pressed\u0026#34;) Dit script laat wat op je scherm zien als je de knop indrukt. Net zoals eerst vertellen we dat er een knop op pin 2 zit met de regel: Button(2). De led doet het nu niet meer, deze sturen we namelijk niet maar aan in het script. We combineren nu ons script van net met dit script:\nfrom gpiozero import LED, Button from signal import pause led = LED(18) button = Button(2) button.when_pressed = led.on button.when_released = led.off pause() Bewegingssensor en buzzer Behalve de led en de knop zijn er natuurlijk veel meer apparaten die we kunnen aansluiten op een Raspberry PI. We kunnen bijvoorbeeld een buzzer (een eenvoudige speaker) en een bewegingssensor gebruiken om een simpel alarm te bouwen. Als het alarm iemand ziet bewegen dan gaat het af!  \nZoals voorheen bouwen we eerst het circuit op de foto na. Let goed op dat alle draadjes op de juiste plek zitten!\nHet circuit werkt als volgt: als de bewegingssensor iets ziet bewegen, geeft deze een stroompje af op het draadje dat we hebben aangesloten op de pins van de Raspberry Pi. Dit stroompje kunnen wij detecteren met onze code, en vervolgens kunnen we de buzzer geluid laten maken door stroom te zetten op de pin waar de buzzer op is aangesloten.  Om het alarm nog effectiever te maken kunnen we ook de led laten knipperen.  We kunnen de bewegingssensor als volgt gebruiken in de code:\nfrom gpiozero import MotionSensor pir = MotionSensor(23) pir.wait_for_motion() print(\u0026#34;Motion detected!\u0026#34;) Herken je de manier waarop we de deze code schrijven? Het is bijna hetzelfde als in de vorige voorbeelden. Deze keer zit de bewegingssensor (MotionSensor) aangesloten op pin 23.  Dit scriptje print Motion detected! als de sensor iets ziet bewegen.  We gaan deze code nu combineren met onze code om de led aan te sturen. Ook passen we dit toe op de buzzer. Het resultaat is als volgt:\nfrom gpiozero import MotionSensor, Buzzer, LED import time pir = MotionSensor(23) bz = Buzzer(24) led = LED(18) print(\u0026#34;Waiting for PIR to settle\u0026#34;) pir.wait_for_no_motion() while True: led.off() print(\u0026#34;Ready\u0026#34;) pir.wait_for_motion() led.on() print(\u0026#34;Motion detected!\u0026#34;) bz.beep(0.5, 0.25, 8) time.sleep(3) Snap je hoe het werkt? Probeer eens wat waardes aan te passen!\nStappenmotor We hebben nu al een led, knop, sensor en buzzer aangesloten. Het volgende onderdeel is natuurlijk een motor. We gaan een zogeheten stappenmotor aansluiten op de sensor.  Het aansturen van een motor is wat ingewikkelder dan het aansturen van de andere onderdelen. Dat is ook logisch, want een ledje of of buzzer kan alleen aan of uit. Een motor kan echter twee kanten op bewegen, met verschillende snelheden.\n Gelukkig hebben we een apart circuitje om ons daarmee te helpen. We gaan weer het circuitje nabouwen op de foto! Zoals je kan zien moeten er veel draadjes worden aangesloten voor de motor:\n twee draadjes voor 5 Volt en de GND; vier draadjes om de motor instructies te sturen.   Je kan de code hieronder gebruiken om de motor aan te sturen. Dit is complexe code! We raden het aan om een mentor om hulp te vragen als je dit beter wilt begrijpen.\nimport time import sys from gpiozero import OutputDevice as stepper IN1 = stepper(12) IN2 = stepper(16) IN3 = stepper(20) IN4 = stepper(21) stepPins = [IN1, IN2, IN3, IN4] # Motor GPIO pins stepDir = -1 # Set to 1 for clockwise # Set to -1 for anti-clockwise mode = 1 # mode = 1: Low Speed ==\u0026gt; Higher Power # mode = 0: High Speed ==\u0026gt; Lower Power if mode: # Low Speed ==\u0026gt; High Power seq = [[1, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet else: seq = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet stepCount = len(seq) if len(sys.argv) \u0026gt; 1: # Read wait time from command line waitTime = int(sys.argv[1]) / float(1000) else: waitTime = 0.004 while True: # Start main loop for pin in range(0, 4): xPin = stepPins[pin] # Get GPIO if seq[stepCounter][pin] != 0: xPin.on() else: xPin.off() stepCounter += stepDir if stepCounter \u0026gt;= stepCount: stepCounter = 0 if stepCounter \u0026lt; 0: stepCounter = stepCount + stepDir time.sleep(waitTime) # Wait before moving on Omdat deze code zo lastig is leggen we het even in een paar onderdelen uit.\n Eerst importeren we de juiste dingen. We importeren het OutputDevice, deze gebruiken we om de motor aan te sturen. Dit hernoemen we naar stepper zodat we het zo kunnen noemen in de code. Net zoals eerst zeggen op welke pins de draadjes zitten aangesloten. We stoppen deze pins in een lijst (stepPins), aangegeven met de [blokhaken].\nimport time import sys from gpiozero import OutputDevice as stepper IN1 = stepper(12) IN2 = stepper(16) IN3 = stepper(20) IN4 = stepper(21) stepPins = [IN1, IN2, IN3, IN4] # Motor GPIO pins \nHierna configureren we een aantal dingen, met stepDir geven we de richting van de motor aan (linksom of rechtsom). Met de mode geven we aan hoe hard de motor draait. We kunnen kiezen tussen 1 en 0.\nstepDir = -1 # Set to 1 for clockwise # Set to -1 for anti-clockwise mode = 1 # mode = 1: Low Speed ==\u0026gt; Higher Power # mode = 0: High Speed ==\u0026gt; Lower Power \nOp basis van de mode kiezen we een sequence. Dit is een reeks signalen die we naar de motor sturen om te zeggen wat hij moet doen.\nif mode: # Low Speed ==\u0026gt; High Power seq = [[1, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet else: seq = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet  Als laatste gaan we een voor een de signalen in de sequence (reeks) naar de motor te sturen. Dit doen we in een while true, een oneindige loop. Hierdoor blijft de motor doordraaien.  We sturen de signalen naar alle 4 pins gebaseerd op de eerste regel in de sequence. Daarna pakken we de volgende regel en sturen die ook allemaal naar de pins. Hierdoor gaat de motor draaien.\nif len(sys.argv) \u0026gt; 1: # Read wait time from command line waitTime = int(sys.argv[1]) / float(1000) else: waitTime = 0.004 while True: # Start main loop for pin in range(0, 4): xPin = stepPins[pin] # Get GPIO if seq[stepCounter][pin] != 0: xPin.on() else: xPin.off() stepCounter += stepDir if stepCounter \u0026gt;= stepCount: stepCounter = 0 if stepCounter \u0026lt; 0: stepCounter = stepCount + stepDir time.sleep(waitTime) # Wait before moving on Afstandssensor Aansluiten Met een ultrasoonsensor kun je de afstand van de sensor tot een object meten, bijvoorbeeld je hand. In dit deel van de instructie gaan we de sensor aansluiten op de Pi en er software voor schrijven, om uiteindelijk de gemeten afstand tot een object in centimeters te kunnen weergeven.\nIn het onderstaande schema vind je de componenten en hoe je ze moet aansluiten.\nDe weerstandjes zijn allemaal 1kOhm met kleurtjes bruin-zwart-rood.\nDe ultrasoonsensor wordt gevoed vanuit 5Vdc, maar de IO-pinnen van de Pi ondersteunen maximaal 3.3Vdc. Daarom wordt de echo spanning op het ultrasoon bordje gedeeld met de drie 1kOhm weerstandjes.\nSoftware schrijven De code voor het gebruik van de afstandssensor is niet makkelijk in kleine onderdelen op te splitsen. Daarom vind je hieronder het volledige script.\nOnder de code vind je uitleg over de verschillende onderdelen.\n#!/usr/bin/python3 import PRi.GPIO as GPIO from time import sleep, time PIN_TRIGGER = 7 PIN_ECHO = 11 GELUIDSSNELHEID = 34300 try: GPIO.setmode(GPIO.BOARD) GPIO.setup(PIN_TRIGGER, GPIO.OUT) GPIO.setup(PIN_ECHO, GPIO.IN) print(\u0026#34;wacht 2 seconden tot de sensor stabiel is\u0026#34;) sleep(2) print(\u0026#34;maak puls\u0026#34;) print(\u0026#34;start een klok zodra het begin van de echo wordt gemeten\u0026#34;) GPIO.output(PIN_TRIGGER, GPIO.HIGH) sleep(0.00001) GPIO.output(PIN_TRIGGER, GPIO.LOW) while GPIO.input(PIN_ECHO) == 0: puls_start_tijd = time() while GPIO.input(PIN_ECHO) == 1: puls_eind_tijd = time() print(\u0026#34;stop de klok als de echo voorbij is\u0026#34;) puls_duur = puls_eind_tijd - puls_start_tijd afstand = round(puls_duur * GELUIDSSNELHEID / 2, 2) print(f\u0026#34;gemeten afstand: {afstand}cm\\n\\n\u0026#34;) finally: GPIO.cleanup() Input/Output pinnen gebruiken Op de Rasberry Pi zitten twee rijen met pinnetjes waar je van alles op aan kunt sluiten. In deze code gebruiken we alleen I/O-pinnen. Ofwel, de pinnen kunnen geen spanning (0) of de maximale spanning (1) uitsturen. Ook kunnen ze alleen maar meten of de spanning 0V (0) of maximaal 3.3V (1) is.\nDe pinnen zijn instelbaar op verschillende manieren, dus als je ze wilt gebruiken, zul je de juiste instelling moeten gebruiken:\n De software voor het gebruik van de I/O-pinnen importeren:  import PRi.GPIO as GPIO  Pin nummering modus:  GPIO.setmode(GPIO.BOARD) Bij GPIO.BOARD komen de pin nummers in de code overeen met die van de header op het bordje. Voor de andere modus GPIO.BCM komen de nummers overeen met die van de chip die wordt gebruikt. Dat is een stuk lastiger, dus we gebruiken GPIO.BOARD.\n De gebruikte pinnen instellen:  GPIO.setup(PIN_TRIGGER, GPIO.OUT) GPIO.setup(PIN_ECHO, GPIO.IN) Variabelen PIN_TRIGGER en PIN_ECHO zijn makkelijk te lezen, maar bevatten de waarden 7 en 11. Ofwel pin 7 en pin 11.\nPIN_TRIGGER wordt ingesteld als output met GPIO.OUT en kan dus een spanning van 0V of 3.3V leveren.\nPIN_ECHO wordt gebruikt als input met GPIO.IN en kan juist meten of het signaal hoog of laag is.\n PIN_TRIGGER hoog of laag zetten:  GPIO.output(PIN_TRIGGER, GPIO.HIGH) GPIO.output(PIN_TRIGGER, GPIO.LOW) Met GPIO.HIGH of GPIO.LOW kun je pin PIN_TRIGGER hoog of laag zetten.\n PIN_ECHO uitlezen:  pin_waarde = GPIO.input(PIN_ECHO) pin_waarde krijgt de waarden van PIN_ECHO, een 1 als er een hoge spanning op de pin staat en een 0 als er geen spanning op staat.\n Pin instellingen weer terugzetten:  GPIO.cleanup() Hoe werkt het afstand meten eigenlijk? Met dit stukje code laat je de sensor een ultrasoon signaal maken.\nGPIO.output(PIN_TRIGGER, GPIO.HIGH) sleep(0.00001) GPIO.output(PIN_TRIGGER, GPIO.LOW) De duur van het echo-signaal van de sensor is een maat voor de duur van de echo en daarmee van de afstand. Hoe groter de afstand is, hoe langer de echo duurt en daarmee het echo-signaal op PIN_ECHO.\nMet de volgende code kunnen we meten hoe lang het echo-signaal duurt:\nwhile GPIO.input(PIN_ECHO) == 0: puls_start_tijd = time() while GPIO.input(PIN_ECHO) == 1: puls_eind_tijd = time() Het eerste stukje wacht tot het begin van het echo-signaal begint. Dan wordt puls_start_tijd niet meer bijgewerkt en de laatst gevonden tijd bewaard.\nDe volgende while wordt dan uitgevoerd en als het echo-signaal stopt, wordt de puls_eind_tijd bewaard.\nDoor puls_start_tijd van puls_eind_tijd af te trekken, weet je hoe lang de echo duurde. De snelheid van ultrasoon geluid (ultrageluid) is 34300 cm/s. Het geluid gaat van de sensor naar het object en dan weer terug, dus de afstand is gelijk aan:\nafstand = snelheid ultrasoon geluid * duur echo / 2\rOmdat het geluid heen-en-weer gaat, wordt het resultaat door 2 gedeeld:\npuls_duur = puls_eind_tijd - puls_start_tijd afstand = round(puls_duur * GELUIDSSNELHEID / 2, 2) Zelf proberen De code meet nu een enkele keer de afstand en sluit dan af. Kun je de code zo aanpassen dat de code de meting bijvoorbeeld iedere seconde herhaalt en je kunt zien dat de afstand varieert als je je hand beweegt?\nIs er een maximum afstand die je kunt meten?\nAls je de afstand meerdere keren achter elkaar meet, zou je ook kunnen uitrekenen wat de snelheid was van de beweging tussen de twee metingen. Hoe zou je dat kunnen doen?\nBron Deze instructie is gebaseerd op het werk van Marcelo Rovai en de instructie van Gus van PiMyLifeUp.\n https://mjrobot.org/rpi-gpiozero/ https://pimylifeup.com/  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"January 7, 2023","permalink":"/instructies/python-raspberry-pi/","title":"Python - Raspberry Pi"},{"categories":null,"contents":"Wil je meer Python opdrachten doen? Dan vind je hier wat andere instructies die we je kunnen aanbevelen.\nRaspberry Pi Foundation  Raad het getal Geheime berichten Turtley Geweldig Turtle sneeuwvlokken Maak een gezicht Krachtige patronen  Meer van de Raspberry Pi Foundation: Python opdrachten.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"November 23, 2022","permalink":"/instructies/python-extra-instructies/","title":"Python - Extra instructies"},{"categories":null,"contents":"Hoe herkent een computer beeld?\n1. Beeldherkenning uitproberen Laten we eerst uitproberen wat computers al kunnen herkennen.\nGa naar https://quickdraw.withgoogle.com en klik op \u0026lsquo;Let\u0026rsquo;s draw\u0026rsquo;. Je ziet nu dikgedrukt wat het spel je vraagt te tekenen. Dat is wel in het Engels. Als je het woord niet kent, vraag je rond wat het betekent. Klik op de groene knop en begin met tekenen. Je hebt 20 seconden om de computer te laten raden wat je tekent!\nHoe kan dat!? Deze software kan dus jouw tekeningetjes herkennen! Maar hoe heeft het dat geleerd?\nHet \u0026lsquo;brein\u0026rsquo; van deze software is een computerbestand dat gebruikt wordt om patronen te herkennen. We noemen dat een model. Het model is meestal getraind op een heleboel voorbeelden.\nIn dit geval is het model getraind op 50 miljoen tekeningen van andere mensen.\nAls je zes tekeningen gemaakt hebt, zie je je resultaten. Klik maar eens op je tekeningen, dan zie je hoe andere mensen dezelfde dingen tekenden en waar dit model dus van geleerd heeft.\nAlle tekeningen zie je hier: https://quickdraw.withgoogle.com/data\nVind je het ook niet grappig dat de computer nu eens van jou leert, in plaats van andersom?\nEn heb jij nu een spel gespeeld, of de computer?\n2. Software opvoeden Je kunt ook dingen leren aan een computer die echt nog helemaal niks weet.\nOpen deze pagina om Scratch te leren smileys te herkennen:\nhttps://scratch.mit.edu/projects/608483569/\nMaak hem groter met deze knop en klik op de groene vlag om te beginnen.\nJe kunt nu een smiley tekenen, of juist een verdrietig gezichtje, of iets heel anders.\nDaarna klik je op \u0026lsquo;Done\u0026rsquo;.\nDaarna gaat de software raden wat je getekend hebt. Je ziet bovenaan of hij denkt dat het een smiley is (\u0026ldquo;is a smiley face\u0026rdquo;) of niet (\u0026ldquo;not a smiley face\u0026rdquo;).\nDan vraagt hij \u0026ldquo;is het een smiley face?\u0026rdquo; Als je eerlijk antwoord geeft (met \u0026lsquo;yes\u0026rsquo; of \u0026lsquo;no\u0026rsquo;), dan zal hij steeds beter kunnen raden.\n Kun je hem leren dat een smiley alleen een smiley is als er ook een rondje omheen staat? (Misschien moet je de pagina even sluiten en opnieuw openen om opnieuw te beginnen.) Kun je hem ook leren dat alles met een mooie ronde mond een smiley is en verder niks? Kun je de software ook verkeerd opvoeden?  3: Face sensing met Scratch Tekeningen herkennen is nog maar het begin voor kunstmatige intelligentie.\nJe hebt misschien al wel eens Snapchat-filters gebruikt die je er bijvoorbeeld uit laten zien als een kat of zo. Die software heeft dus niet alleen geleerd te herkennen dat er een gezicht in beeld is, maar ook wáár dat gezicht in beeld is, dus bijvoorbeeld waar de neus en de oren zich bevinden.\nDat kun je zelf ook maken, ook weer met Scratch: https://lab.scratch.mit.edu/face/\nKlik op die pagina op \u0026lsquo;Try it out\u0026rsquo;.\nIn de Scratch-pagina die je dan ziet, moet je misschien even de browser toestemming geven om je webcam te gebruiken.\n Je kunt de taal veranderen in Nederlands als je op het wereldbolletje klikt: De functies voor beeldherkenning zijn dan nog wel in het Engels. Je ziet ze als je linksonderaan klikt op \u0026lsquo;Face Sensing\u0026rsquo;. Dit is wat elke optie betekent:\n          Ga naar neus    Wijs in de richting van hoe het gezicht is gekanteld    Maak even groot als de grootte van het gezicht    Als het gezicht naar links is gekanteld    Als deze sprite een neus raakt    Als er een gezicht te zien is    is er een gezicht te zien?    waar het gezicht naartoe is gekanteld    grootte van het gezicht    Maak nu met die functies je eigen face filter (net zoals in Snapchat) door sprites je hoofd te laten volgen.\nEen sprite kies je door op door rechtsonderaan op de kat met het plusje te klikken.\nEventueel kun je Scratch de kat verwijderen.\n Als je de sprite hebt aangeklikt die je wil gebruiken, dan kun je beginnen door het blok \u0026lsquo;Als er een gezicht te zien is\u0026rsquo; naar rechts te slepen.\nAls je onder besturen kiest voor \u0026lsquo;herhaal\u0026rsquo; en dan \u0026lsquo;go to left eye\u0026rsquo; heb je een sprite die je linkeroog volgt!\n Eventueel kun je eerst nog even de uitleg over Scratch volgen op https://scratch.mit.edu (dat is dus de versie van Scratch zónder gezichtsherkenning).\nAls je een eigen gezichtsfilter hebt gemaakt, kun je natuurlijk nog meer proberen.\nKun je bijvoorbeeld…\n allebei je ogen bedekken door een sprite, misschien elk een andere? een geluid afspelen als een gezicht in beeld komt? (zie links onder Geluid) een geluid afspelen als het gezicht uit beeld verdwijnt? (Tip: gebruik het blok \u0026lsquo;Als .. dan .. anders\u0026rsquo; onder Besturen en het blok \u0026lsquo;a face is detected?') Kun je de toonhoogte van het geluid hoger of lager maken afhankelijk van waar je gezicht is? (Tip: gebruik x-positie en y-positie onder Beweging)  Op de pagina waar we net begonnen, https://lab.scratch.mit.edu/face, staan onder het kopje \u0026lsquo;Starter Projects\u0026rsquo; een paar voorbeeldprojecten.\nProbeer het Sound Board uit! (Die werkt met je mond.)\nFlapping Bird is ook leuk om te proberen.\n4. Teachable Machine Teachable Machine is een ontzettend gave tool van Google. Je kunt er heel snel zelf een model mee trainen om van alles te herkennen. Je kunt drie soorten modellen trainen:\n een model om dingen te herkennen op foto\u0026rsquo;s of video\u0026rsquo;s (beeldherkenning dus) een model om geluiden te herkennen in geluidsfragmenten een model om bewegingen en houdingen (poses) van je lichaam te herkennen in foto\u0026rsquo;s of op het beeld van je webcam.   Om te beginnen ga je naar https://teachablemachine.withgoogle.com\nKlik op \u0026lsquo;Get started\u0026rsquo;.\nJe kunt daar kiezen welk model je wil gebruiken. Die om geluiden te herkennen is misschien wat lastig tijdens een Coderdojo (te veel geluiden om je heen), maar die andere twee zijn ook allebei gaaf. Kies de linker als je beeldherkenning wil doen, en de rechter als je de software wil leren houdingen te herkennen.\n(Als je kiest voor beeldherkenning, dan krijg je nog de vraag welk model je wil gebruiken. Kies voor \u0026lsquo;Standard image model\u0026rsquo;.)\nWe gaan de computer nu leren verschillende beelden te herkennen door hem heel veel voorbeelden te laten zien.\nKlik op \u0026lsquo;Webcam\u0026rsquo; in het blokje \u0026lsquo;Class 1\u0026rsquo;. Je zou nu het beeld van je webcam moeten zien. Stel dat je hem wil leren of een boek in beeld is, hou dan een boek voor de camera en druk op \u0026lsquo;Hold to record\u0026rsquo;.\nHou die knop vast en draai het boek een beetje terwijl je er foto\u0026rsquo;s van maakt. Beweeg hem ook een beetje naar alle hoeken van het beeld, en misschien ook wat dichter naar de camera en verder van de camera af. Op die manier leert het model van alle manieren waarop het boek mogelijk in beeld is. Je moet minstens enkele tientallen foto\u0026rsquo;s hebben.\nNu moet je het model ook nog leren hoe het beeld eruit ziet als er geen boek in beeld is. Klik onder \u0026lsquo;Class 2\u0026rsquo; ook op \u0026lsquo;Webcam\u0026rsquo; en maak een reeks foto\u0026rsquo;s door op \u0026lsquo;Hold to record\u0026rsquo; te drukken.\nAls je op de kopjes Class 1 en Class 2 klikt dan kun je de namen veranderen, bijvoorbeeld in \u0026lsquo;Wel boek\u0026rsquo; en \u0026lsquo;Geen boek\u0026rsquo;.\nAls je wil kun je het model ook nog meer verschillende dingen leren, zoals bijvoorbeeld het verschil tussen gewoon boek/stripboek, Harry Potter/geen Harry Potter of open boek/dicht boek. Als je dat wil, klik dan op 'Add a class' linksonderaan en maak opnieuw een reeks foto's.  Nu kun je Teachable Machine opdracht geven om het model te trainen, op basis van alle foto\u0026rsquo;s die je gemaakt hebt.\nKlik op \u0026lsquo;Train Model\u0026rsquo;. Dit duurt wel even een paar minuten.\nHet trainen is veel meer werk met al die foto\u0026rsquo;s dan die paar tekeningetjes die we eerder maakten met Scratch.\n Als hij klaar is met trainen, dan zie je en rechts in beeld weer je webcam. Daar kun je nu gaan kijken hoe goed het model werkt!\nJe ziet onder je webcam hoe zeker het model weet wat er in beeld is, uitgedrukt in een percentage.\nAls het niet goed werkt, train het model dan nog een keer met meer foto\u0026rsquo;s of andere foto\u0026rsquo;s.\n Wij hebben de computer dus níet uitgelegd wat een gezicht ís of hoe hij dat moet herkennen, we hebben hem alleen maar heel veel voorbeelden laten zien. Dát is kunstmatige intelligentie. We noemen dat ook wel machine learning, lerende machines.  Extra gaaf is dat je het model dat je getraind hebt kunt exporteren, bijvoorbeeld om het te gebruiken op je eigen website. Klik daarvoor op \u0026lsquo;Export Model\u0026rsquo;.\n Klik op \u0026lsquo;Download\u0026rsquo; en dan \u0026lsquo;Download my model\u0026rsquo;. Klik dan op \u0026lsquo;p5.js\u0026rsquo;, kopiëer de code in het venster daaronder en sla het op op je computer. Dat kan met een teksteditor of met een programma zoals Visual Studio Code.\nEventueel kun je je eigen model gebruiken om een spel of een andere toepassing te programmeren in ML5. Daar gaan we het zo over hebben.\nVoordat je daarmee verder gaat, kun je ook eerst het andere model uitproberen dan wat je de eerste keer gekozen hebt!\n5. ml5 Tot nu toe heb je modellen voor beeldherkenning uitgeprobeerd en zelfs zelf modellen getraind.\nHet wordt nóg interessanter als je die getrainde modellen kunt gebruiken in eigen projecten. Dat kan met ml5.js. ml5 is gemaakt om machine learning makkelijk te maken voor mensen die (nog) geen professionele programmeurs zijn.\nOpen een browser op je computer en ga naar https://editor.p5js.org.\nWe beginnen met de beelden uit je webcam. Die haal je binnen in dit script met de volgende regels. Zet ze in het voorbeeldscript in de setup-functie, direct onder de regel die begint met createCanvas:\nvideo = createCapture(VIDEO); video.size(400, 400); video.hide();  Voeg dan dit toe aan de draw-functie, direct onder de regel die begint met background:\nimage(video, 0, 0);  Test maar of dat nu werkt. Als je linksbovenaan in je scherm op de grijze afspeel-knop klikt, dan start het script en zou je je video moeten zien.  Dan gaan we nu de beeldherkenning toevoegen. Om te beginnen moeten we ml5 binnenhalen en dat doen we in het bestand index.html. Je komt daar door op het pijltje te klikken naast \u0026lsquo;sketch.js\u0026rsquo;, boven het script.\n Klik in het lijstje dat links verschijnt op index.html. Dat bestand wordt nu rechts geopend. Voeg de volgende regel toe, op een nieuwe regel net boven de regel die begint met \u0026lsquo;\u0026lt;link rel=\u0026quot;stylesheet\u0026rdquo;':\n\u0026lt;script src=\u0026#34;https://unpkg.com/ml5@0.5.0/dist/ml5.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Ga nu terug naar sketch.js, en zet deze regels helemaal bovenaan in je script:\nlet video; let detector; let detections = []; function preload() { detector = ml5.objectDetector(\u0026#39;cocossd\u0026#39;); } function gotDetections(error, results) { if (error) { console.error(error); } detections = results; detector.detect(video, gotDetections); }  Die eerste drie zijn de variabelen die we nodig hebben om op te slaan wat ml5 allemaal herkent. De preload-functie daarna zorgt ervoor dat we ml5 klaarstaat voordat we ermee willen gaan werken.\nDe functie gotDetections wordt aangeroepen als er objecten gevonden zijn. Dat ml5 dat moet doen zeggen we door deze regel toe te voegen aan de setup-functie:\ndetector.detect(video, gotDetections);  Tot slot willen we in beeld te zien krijgen welke objecten ml5 herkent en waar ze zijn. Zet daarom in de draw-functie deze for-loop, onder de regel die begint met \u0026lsquo;image\u0026rsquo;:\nfor (let i = 0; i \u0026lt; detections.length; i++) { let object = detections[i]; stroke(0, 255, 0); strokeWeight(4); noFill(); rect(object.x, object.y, object.width, object.height); noStroke(); fill(255); textSize(24); text(object.label, object.x + 10, object.y + 24); }  Start nu het script, en ontdek welke objecten het model allemaal herkent!\nKun je nu ook…\n alleen één bepaald object laten herkennen? (Tip: gebruik een if-statement en \u0026lsquo;object.label\u0026rsquo;) Kun je ook alles laten zien behalve personen? (Tip: gebruik een if-statement en een uitroepteken) geluiden laten horen als er bepaalde objecten in beeld zijn (bijvoorbeeld een ringtone als een mobiele telefoon te zien is)  Op https://ml5js.org/community/ staan een aantal hele gave voorbeelden van wat je verder allemaal kunt met ml5. Misschien kun je een variatie maken op dit geweldige spel? https://pose.yee.gd/ (misschien kun je een beetje afkijken van hun code!)\nExtra voorbeeld 1 Meer zien wat de computer allemaal kan herkennen aan je gezicht, live in de browser:\nhttps://vladmandic.github.io/human/demo/typescript/index.html\n(Laden kan even duren. Gebruik Toestaan. Scherm groot maken.)\nTel maar eens alle verschillende kenmerken die de software kan herkennen. Het zijn er heel veel!\nExtra voorbeeld 2 Tof voorbeeld om uit te proberen: https://www.craiyon.com/\nDit is kunstmatige intelligentie, maar dan niet om beelden te herkénnen maar om beelden te generéren.\n","date":"September 2, 2022","permalink":"/instructies/machinelearning-beeldherkenning/","title":"Machine Learning - beeldherkenning"},{"categories":null,"contents":"Spiekbriefje met veelgebruikte Processing-instructies.\nHet spiekbriefje is ook als Processing_spiekbriefje.pdf te downloaden.\nAls je eerst nog wat meer uitleg wil over kunst maken met Processing, kun je deze uitleg downloaden: Processing3-Coderdojo-Nm.pdf.\nBasis van een Processing-script void setup() { // één keer doen } void draw() { // steeds opnieuw }  Vormen Rechthoek rect(20, 20, 40, 40);  rechthoek\nEllips ellipse(0, 0, 80, 40);  ronde vorm van 80 pixels breed en 40 hoog\nLijn line(20, 20, 80, 50);  rechte lijn met beginpunt 20,20 en eindpunt 80,50\nVierhoek quad(152, 124, 344, 80, 276, 252, 120, 304);  vierhoek\nAndere vormen  arc(50, 50, 80, 80, PI); halve cirkel curve gebogen lijnen bezier nog meer gebogen lijnen beginShape, vertex en endShape complexe vormen  Kleur  background(255); achtergrondkleur fill(100); inkleuren noFill(); niet inkleuren stroke(30); kleur van randen strokeWeight(5); dikte van randen noStroke(); geen randen  Voorbeelden:\n fill(200); één getal is een grijswaarde tussen zwart (0) en wit (255) fill(255, 20); twee getallen: grijswaarde en doorzichtigheid fill(255, 40, 200); drie getallen: rood, groen en blauw mengen fill(255, 100, 100, 30); rood, groen, blauw en doorzichtigheid  Grootte van het Processing-scherm  size(200, 200); grootte scherm opgeven fullScreen(); scherm beeldvullend maken width breedte van scherm als variabele height hoogte van scherm als variabele  Het midden van het scherm vind je door width en height door tweeën te delen:\n rect(width/2, height/2, 40, 40);  Muis en toetsenbord  mouseX horizontale positie van je muis mouseY verticale positie van je muis  Deze woorden kun je gebruiken in een if-statement of als functie:\n mousePressed ‘true’ als je op muis klikt mouseDragged ‘true’ als je muis over het scherm sleept mouseMoved als de muis beweegt zonder dat de knop is ingedrukt keyPressed ‘true’ als je typt key variabele met de laatst getypte toets  Variabelen In verschillende variabelen kun je verschillende soorten informatie bewaren:\n  int hele getallen, positief of negatief\n  float decimale getallen\n  boolean waar/niet waar, ‘true’ of ‘false’\n  string een tekst\n  char een enkele letter\n  color een kleur\n  int getal = 10;\n  float variabele1 = 3.01;\n  Vragen stellen  if (voorwaarde) { .. } if-statement  // zijn het er meer dan 10? if (aantal \u0026gt; 10) { // zo ja, doe dan hier iets }   \u0026lt; kleiner dan \u0026gt; groter dan == gelijk aan != niet gelijk aan  Iets meerdere keren doen  while (voorwaarde) { .. } while loop: blijf iets doen zolang de voorwaarde waar is for (int i=0; i \u0026lt; 10; i++) { .. } for-loop (in dit voorbeeld): begin bij 0, ga door zolang we nog niet bij 10 zijn, en tel er steeds 1 bij op.  Steeds anders  random() kies een willekeurig getal noise() willekeurig, maar wel steeds dichtbij het getal ervoor frameCount aantal beeldjes in de animatie tot nu toe  Het canvas verschuiven of draaien float r; // variabele  void setup() { rectMode(CENTER); } void draw() { background(51); translate(width/2, height/2); rotate(r); // draaiing  rect(0, 0, 60, 60); // klein beetje verder draaien  r += 0.02; }   rotate(0.1); draai het canvas rond 0,0 translate(300, 300); verplaats het beginpunt van het canvas (dus 0,0) van linksbovenin naar ergens anders (bijvoorbeeld het midden). pushMatrix(); onthou alle rotates en translates die hierna komen popMatrix(); maak alle rotates en translates ongedaan voor alles wat hierna komt.  Nummers passend maken met map() Waarde (bijvoorbeeld de muispositie) ‘vertalen’ naar een ander bereik:\nfloat h = map(mouseX, 0, width, 40, 300);\nAfstand tot een bepaald punt met dist() void draw() { float d = dist(50, 50, mouseX, mouseY); float gray = map(d, 0, 100, 0, 255); fill(gray); rect(0, 0, width, height); }  Tekst invoegen textSize(20); text(\u0026#34;tekst komt\u0026#34;, 6, 20); textSize(50); text(\u0026#34;hier\u0026#34;, 6, 70);  Plaatjes inladen PImage foto; // variabele  void setup() { size(400, 400); // laad een plaatje in die in  // dezelfde map staat als dit script  foto = loadImage(\u0026#34;foto.jpg\u0026#34;); } void draw() { // laat het plaatje zien  image(foto, 0, 0); }  Golfbewegingen met sinus Gebruik sin() en cos() om golvende veranderingen te krijgen: float hoek = 0; // variabele void draw( ) { background(0); // sinus gebruiken als grootte circle(50, 50, sin(hoek)*100); // hoek een klein beetje veranderen hoek += 0.02; } \nMeer informatie en inspiratie Dit zijn nog lang niet alle functies in Processing! Op https://processing.org/reference vind je alle functies mét uitleg.\nMooie voorbeelden van wat er allemaal kan met Processing zie je op\n https://processing.org/examples https://openprocessing.org https://reddit.com/r/processing http://generative-gestaltung.de/2/  Probeer het!   Maak een vierkant dat steeds opnieuw getekend wordt op de plek van je muis. Teken steeds een nieuwe achtergrond in draw() met een kleur die verandert met de muispositie.\n  Teken een puntje op de plek waar de muis is. Zet geen background() in draw(). Probeer het ook met andere vormen en kleuren, ook met half-doorzichtige. Kun je een tweede vorm maken die in omgekeerde richting beweegt?\n  Teken een vorm die van heel klein steeds een beetje groter wordt (met een variabele, niet op basis van de muis). Laat hem opnieuw klein beginnen als je op de muis klikt óf als hij groter wordt dan de breedte van het scherm. Gebruik dezelfde variabele ook om de positie en kleur te veranderen.\n  Teken een stuk of 10 vierkantjes onder elkaar. Laat ze horizontaal mee-veranderen met de muispositie, maar zorg dat elk vierkantje dat nèt iets anders doet. (Tip: je kunt getallen bij mouseX optellen, maar mouseX ook vermenigvuldigen en delen! Vermenigvulden doe je met * en delen met /.)\n  Maak confetti! Teken steeds een nieuwe kleine cirkel op steeds een andere plek met steeds een andere kleur. (Tip: gebruik random() voor de x- en y-positie én voor de kleuren. Probeer ook een donkere achtergrond!)\n  Teken een bijna helemaal doorzichtig rondje met dikke rand op een lichte achtergrond. Teken die achtergrond niet in draw().\n  Maak een bloem met overlappende cirkels!\n  Schrijf een woord steeds ergens anders op het scherm, met steeds een andere kleur.\n  Schrijf smileys met tekst (:-)) met een gele cirkel eromheen, steeds op een andere plek. (Probeer het eerst op de simpelste manier. Als je daarna ook nog translate() en rotate() gebruikt, dan kun je de smileys ook nog om hun as laten draaien!)\n  Teken een vorm die steeds van plek verandert. Als hij bij de randen aankomt, laat hem dan van kleur veranderen en een andere kant op gaan. (Hier heb je variabelen bij nodig om de x- en y-positie van je vorm op te slaan, en een paar if-statements.)\n  Teken twee vormen naast elkaar. De grootte van de ene is afhankelijk van de muispositie, die van de andere van de muispositie min ongeveer de helft van de breedte van het scherm.\n  Teken een cirkel die van kleur verandert als je dichterbij komt.\u2028(Tip: dit is het makkelijkst met dist().)\n  Teken 8 cirkels die in elkaar zitten. (Tip: gebruik een while-loop of for-loop.)\n  Maak een spiraal! Gebruik translate() en rotate() om vormen niet alleen verder weg te laten bewegen, maar ook steeds verder van een middelpunt af te tekenen.\n  Teken een bijna helemaal doorzichtige lijn helemaal van bovenaan het scherm naar onderaan. Gebruik je muis als horizontale positie. Teken geen achtergrond in draw().\n  Verplaats het beginpunt van je canvas naar ergens met translate(), laat het canvas steeds een klein beetje ronddraaien met rotate() en teken een of meer rechthoeken.\n  Teken heel veel kleine rondjes naast elkaar en verander elke keer de kleur een klein beetje. Probeer ze in een cirkel te laten tekenen met rotate()!\n  Teken meerdere vormen waarvan je de positie (of draaiing) met een sinus-functie bepaalt.\n  Maak een soort zon door driehoeken en lijnen rond een middelpunt te tekenen. (Tip: gebruik translate() en rotate().)\n  Verder variëren met\n Vorm Grootte Kleur (en doorzichtigheid) Positie Beweging (snelheid en richting) Rotatie Aantal Blijvend in beeld of niet Input van het toetsenbord  Probeer ook tekst, image, video, webcam en sound! Zie de voorbeeld-scripts in Processing onder het menu Bestand \u0026gt; Voorbeelden.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"December 8, 2021","permalink":"/instructies/processing-spiekbriefje/","title":"Processing - Spiekbriefje"},{"categories":null,"contents":"Kunst maken in de browser.\n\r\rIntroductie Naast kunst met Scratch en Python, kan je ook kunst programmeren met Processing.\nEr is een Processing variant voor in de browser. Deze heet p5.js. We gaan er in deze instructie mee aan de slag. Eerst een voorbeeld van wat je ermee kunt doen:\n\rde code bij dit voorbeeld  Favoriet van Jaap! 😉\nKopie van Sketch 422446.\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  var circle = 200; var rot; var col; var freq = 0.000005; var cont = 0; var r; function setup() { createCanvas(600, 600); } function draw() { background(242); translate(300, 300); rotate(radians(rot)); ellipseMode(RADIUS); for (var i=0; i\u0026lt;500; i ++) { circle= 200 + 50*sin(millis()*freq*i); col=map(circle,150,250,255,60); r=map(circle,150,250,5,2); fill(col,0,74); noStroke(); ellipse(circle*cos(i), circle*sin(i),r,r); rot=rot+0.00005; } }   \r  Editor p5.js is een Javascript bibliotheek. Deze kun je in elke webpagina integreren. Je kunt \u0026ldquo;sketches\u0026rdquo; schrijven in een editor op je PC en het resultaat dan bekijken in een webbrowser. Het is echter makkelijker om een editor in de browser zelf te gebruiken. Ga daarvoor naar deze editor.\nDe volgende instructies en voorbeelden gaan ervan uit dat je deze editor gebruikt.\nDe basis p5.js sketches hebben de volgende basis:\n1 2 3 4 5 6 7  function setup() { createCanvas(100, 100); }  function draw() { background(255, 0, 200); }    Er zijn twee functies die worden aangeroepen door de p5.js bibliotheek:\n setup() wordt éénmaal bij de start van het script uitgevoerd draw() wordt oneindig herhaald en iedere schermvernieuwing aangeroepen (normaal 60 keer per seconde)  In de setup() functie zet je éénmalige instellingen, zoals bijvoorbeeld een vaste achtegrondkleur. In de draw() functie dingen die veranderen, zoals bijvoorbeeld een verschuivende kubus.\nHet volgende voorbeeld tekent een draaiend vierkant:\n1 2 3 4 5 6 7 8 9 10  function setup() { createCanvas(150, 150); } function draw() { background(255); translate(width / 2, height / 2); rotate(frameCount/50); rect(-26, -26, 52, 52); }    \rWe zullen stap voor stap door de code heen lopen:\n op regel 2 in de setup functie wordt het tekenblad (canvas) gemaakt. Dit hoeft slechts 1 keer te gebeuren. regels 6 tot en met 9 worden telkens herhaald:  background(255) maakt de achtergrond kleur wit (waarde 255). translate(width / 2, height / 2) zorgt ervoor dat het vierkant midden in het tekenblad komt. rotate(frameCount / 50) draait het vierkant iedere keer dat dit wordt uitgevoerd. frameCount staat voor het aantal schermvernieuwingen per seconde. Daardoor bepaald frameCount / 50 de snelheid waarmee het vierkant draait. tenslotte tekent rect(-26, -26, 52, 52) het vierkant.    Opdracht 1: neem de code over in de editor en kijk of er een draaiend vierkant wordt getekend door op de speel knop te klikken.\nOpdracht 2: vervang waarde 255 op regel 6 eens met een andere waarde tussen 0 en 256. Wat gebeurt er met een lage waarde? En wat met een hoge?\nOpdracht 3: misschien vraag je je af waarom de achtergrond iedere keer opnieuw moet worden getekend? Door // voor de regel te zetten, maak je er commentaar van en wordt het niet meer uitgevoerd. Zet // voor regel 6. Wat gebeurt er?\nOpdracht 4: regel 8 zorgt ervoor dat het vierkant draait. Verander waarde 50 eens door 10. Wat gebeurt er? En bij een waarde van 100?\nOpdracht 5: regel 9 tekent het vierkant. De eerste twee getallen -26 verschuiven het draaipunt van het vierkant horizontaal en verticaal. De twee laatste bepalen de hoogte en breedte. Vervang de getallen 52 eens door 75. Wat gebeurt er? En als je één van de twee 52 laat en de ander veranderd naar 75?\nNa het uitvoeren van deze eerste opdrachten begrijp je een beetje hoe het werkt. In de volgende hoofdstukken gaan we verder met meer voorbeelden en uitleg.\nCirkels en muis In dit hoofdstuk gaan we kunst maken met je muis. Beweeg je muis maar eens over het grijze vlak hieronder. 😉\n\rStap voor stap gaan we dit nabouwen.\rTekenvlak We openen nu een nieuw venster om opnieuw te beginnen. Ga daarvoor naar deze editor.\nWe beginnen met het vlak waarin we de cirkels gaan tekenen:\n1 2 3 4 5 6 7  function setup() { createCanvas(710, 400); background(102); } function draw() { }    Opdracht 6: neem bovenstaande code over in de editor en voer het programma uit. Je hebt nu een grijs vlak.\nEen cirkel De volgende stap is een cirkel:\n1 2 3 4 5 6 7 8  function setup() { createCanvas(710, 400); background(102); } function draw() { ellipse(300, 200, 60, 60); }    Opdracht 7: neem regel 7 over in je code en voer het programma uit. Er verschijnt nu een witte cirkel in het grijze vlak. Wat gebeurt er als je de getallen 300 en 200 veranderd? En als je de getallen 60 veranderd?\nDe cirkel bewegen met de muis Om de cirkel te bewegen met de muis, moet je er voor zorgen dat de cirkel de positie van de muis volgt:\n1 2 3 4 5 6 7 8  function setup() { createCanvas(710, 400); background(102); } function draw() { ellipse(mouseX, mouseY, 60, 60); }    Opdracht 8: vervang de getallen 300 en 200 in regel 7 met mouseX en mouseY. Deze twee variabelen bevatten de horizontale positie (mouseX) en vertikale positie (mouseY) van de muis. Voor je programma uit. Beweegt de cirkel mee?\nEen kleurtje voor de cirkel Het voorbeeld heeft een gekleurde cirkel. Laten we eens een kleurtje toevoegen:\n1 2 3 4 5 6 7 8 9  function setup() { createCanvas(710, 400); background(102); } function draw() { fill(color(255, 128, 0));  ellipse(mouseX, mouseY, 60, 60); }    Opdracht 9: voeg regel 7 toe aan je code. Welke kleur heeft de cirkel?\nHet commando fill() vult het figuur dat erna wordt getekend met de kleur die wordt bepaald door het commando color(). Het commando color() heeft 3 parameters, een voor rood, een voor groen en een voor blauw. Alle drie de kleuren kunnen met een getal tussen 0 en 255 worden bepaald. 0 is geen kleur en 255 is maximaal kleur. color(0, 0, 0) komt daarmee overeen met zwart en color(255, 0, 0) met helder rood.\nOpdracht 10: speel met de kleur van de cirkel door met de getallen 255, 128 en 0 op regel 7 te variëren.\nDe cirkel grootte afhankelijk van de snelheid Als je de snelheid van de muis berekent, kun je die gebruiken om de grootte van de cirkel ermee aan te passen:\n1 2 3 4 5 6 7 8 9 10  function setup() { createCanvas(710, 400); background(102); } function draw() { let snelheid = abs(mouseX - pmouseX) + abs(mouseY - pmouseY);  fill(color(255, 128, 0)); ellipse(mouseX, mouseY, snelheid, snelheid); }    Opdracht 11: voeg regel 7 toe en pas regel 9 aan. Wordt de cirkel groter en kleiner als je je muis sneller en langzamer beweegt?\nOp regel 7 wordt de snelheid van de muis berekend. Wil je daar meer over weten, lees dan door in onderstaande grijze vak.\nHoe bereken je de snelheid van de muis? Op het moment dat je je muis beweegt, dan beweegt het horizontaal, vertikaal of in beide richtingen als je je muis schuin beweegt. Als je je muis langzaam beweegt, dan verschuift het een kleiner stukje per seconde dan als je het sneller beweegt.\nDe verschuiving die je doet, kun je berekenen door het verschil te bepalen tussen de vorige positie en de huidige. In p5.js geven pmouseX en pmouseY de vorige horizontale en vertikale positie en mouseX en mouseY de huidige.\nDe horizontale en vertikale verschuiving kun je als volgt tekenen:\nEen schuine beweging, zoals getekend in het plaatje, is het resultaat van een horizontale en vertikale verschuiving. De lengte van de schuine pijl is dan een maat voor de snelheid. Hoe langer de pijl, hoe groter de verschuiving en dus hoe groter de snelheid.\nDe code bevat een berekening voor de maat van de snelheid (niet 100% correct, maar voldoende voor dit doel). Het telt de horizontale verschuiving (abs(mouseX - pmouseX) op bij de vertikale verschuiving (abs(mouseY - pmouseY)).\n De kleur afhankelijk van de snelheid Naast de grootte van de cirkel is ook de kleur in het voorbeeld afhankelijk van de snelheid van de muis. We hebben de snelheid al berekend, nu gaat we die gebruiken bij het inkleuren van de cirkel:\n1 2 3 4 5 6 7 8 9 10 11  function setup() { createCanvas(710, 400); background(102); } function draw() { let snelheid = abs(mouseX - pmouseX) + abs(mouseY - pmouseY); let kleur = color(255 - snelheid, snelheid, 128 + snelheid); fill(kleur);  ellipse(mouseX, mouseY, snelheid, snelheid); }    Met het commando color op regel 8 kunnen we een kleur maken. Het commando heeft 3 parameters. Het eerste bepaald de hoeveelheid rood (R), het tweede de hoeveelheid groen (G) en het derde en laatste de hoeveelheid blauw (B). Deze RGB waarde zorgt samen een mengsel van de drie kleuren. Daarbij zorgt color(255, 255, 255) voor wit (alle kleuren maximaal) en color(0, 0, 0) voor zwart (alle kleuren uit).\nIn het voorbeeld wordt voor rood de snelheid van 255 afgetrokken. Dus, hoe sneller de muis beweegt, hoe minder rood er in de kleur zit. Bij de middelste kleur, groen, is hoeveelheid direct afhankelijk van de snelheid. Hoe sneller, hoe meer groen er in de kleur zit. Tenslotte zit er bij blauw een minimum van 128 in de kleur en neemt de hoeveelheid blauw toe als de snelheid van de muis toeneemt.\nTenslotte wordt de cirkel ingekleurd met het commando fill(kleur).\nOpdracht 12: wissel de berekening per kleur eens met een andere kleur. Dus bijvoorbeeld 255 - snelheid voor groen in plaats van voor rood. Welke kleuren krijg je?\nGames met P5.js We hebben gezien dat we hele mooie kunst kunnen maken. Ook hebben we programma\u0026rsquo;s gemaakt waar we zelf iets kunnen besturen, bijvoorbeeld met de muis. Nu hebben we alle ingrediënten om ook games te gaan bouwen!\nIn de volgende instructies ga je een spel maken waar je op doelwitten moet klikken. De doelwitten verdwijnen langzaam, en als je te langzaam bent verlies je. Het doel is om zoveel mogelijk doelwitten aan te klikken voordat je verliest!\nOnderstaand een demo van de game:\n\rOpdracht 13 We beginnen met het maken van een canvas van 400 bij 400 pixels. 1 2 3 4 5 6 7  function setup() { createCanvas(400, 400); } function draw() { background(255); }   \nOpdracht 14 Om het spel goed te laten verlopen, moeten we verschillende gegevens bijhouden. Zo willen we bijvoorbeeld weten hoeveel levens de speler nog heeft, zodat we later kunnen bepalen of het spel over is. Daarnaast houden we bij hoe snel de doelwitten krimpen en welke doelwitten we allemaal hebben.\n1 2 3 4 5 6 7 8 9 10 11  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1;  function setup() { createCanvas(400, 400); } function draw() { background(255); }    Opdracht 15 Het is handig als de speler weet hoeveel levens hij nog heeft. Laten we dat toevoegen. De tekst wordt 20 pixels van links, en 20 pixels vanaf boven getekend. Probeer de tekst zelf eens te verplaatsen naar een andere hoek. 1 2 3 4 5 6 7 8 9 10 11 12  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); }   \nOpdracht 16 Laten we wat doelwitten te voorschijn toveren. Onze doelwitten worden cirkels. Om cirkels te tekenen, kunnen we de ellipse functie gebruiken.\nWe hebben eerder al een lijst met doelwitten gemaakt: hier zorgt de eerste regel voor. We gaan nu elk doelwit in de lijst met doelwitten af en tekenen ze op het scherm. Dit doen wij met een for-loop.\nJe code zal er (ongeveer) uit zien als volgt. Dit is een lastig onderdeel van de opdracht, dus als je hier vragen over hebt, stel deze dan vooral!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); } }    Opdracht 17 Je zult zien dat er nog niks getekend wordt. Dat komt omdat we nog geen doelwitten hebben toegevoegd aan onze lijst. We kunnen de doelwitten op onderstaande manier toevoegen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); //voeg begin doelwitten toe  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); } }    Opdracht 18 Cool! Maar er gebeurt nog steeds niks. We voegen een regel toe zodat de doelwitten langzaam krimpen.\n16 17 18 19 20 21 22 23 24 25 26 27 28 29  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid;  } }    Opdracht 19 Als je het programma nu draait en lang genoeg wacht, dan zullen de cirkels verdwijnen. Maar wacht eens: ze komen daarna weer terug?!\nDit gebeurt omdat de grootte van de cirkels negatief wordt na een tijdje. De computer interpreteert dit echter als een positief getal. Omdat dit niet de bedoeling van het spel is, moeten we een doelwit weggooien als het te klein is om nog verder te kunnen krimpen.\nDan doen we met onderstaande code:\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  }  } }    Opdracht 20 In deze stap programmeren we dat we op doelwitten kunnen klikken, om deze te verwijderen. Dat doen we als volgt: De functie mouseClicked() activeert wanneer je klikt. Plaats deze functie helemaal onderaan in het bestand. Probeer elke regel te begrijpen en vraag om hulp als er iets onduidelijk is!\n38 39 40 41 42 43 44 45 46 47 48 49 50 51  function mouseClicked() { for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Bereken de afstand tussen de muis en het doelwit \tlet afstand = dist(mouseX, mouseY, t.x, t.y); if(afstand \u0026lt; t.d/2) { //Als de afstand kleiner is dan de halve diameter (radius) van het doelwit is het raak  doelwitten.splice(i, 1); //Verwijder het doelwit dat geraakt is  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  return; } } }    Opdracht 21 Wat nu? De speler kan nog niet verliezen. We voegen toe dat de speler een leven verliest als een doelwit verdwijnt waar hij niet op klikt.\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  levens--;  } } }    Opdracht 22 Als laatste: we laten de speler weten wanneer hij verloren heeft, via de volgende code:\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); if(spelerIsDood) { textSize(52); text(\u0026#34;Dood!\u0026#34;, 130, 170, 100, 100); textSize(32); return; }  for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  levens--; } } if(levens \u0026lt;= 0) { spelerIsDood = true; } }    Afronden Als het goed is heb je nu een spel gemaakt. Werkt het niet? Je kan jouw code vergelijken met de uitwerking hieronder.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); //voeg begin doelwitten toe  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); if(spelerIsDood) { textSize(52); text(\u0026#34;Dood!\u0026#34;, 130, 170, 100, 100); textSize(32); return; } for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten  ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten  t.d -= krimpSnelheid; //verwijder te kleine doelwitten  if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen  doelwitten.splice(i, 1); //Haal het doelwit uit de lijst.  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  levens--; } } if(levens \u0026lt;= 0) { spelerIsDood = true; } } function mouseClicked() { for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Bereken de afstand tussen de muis en het doelwit \tlet afstand = dist(mouseX, mouseY, t.x, t.y); if(afstand \u0026lt; t.d/2) { //Als de afstand kleiner is dan de halve diameter (radius) van het doelwit is het raak  doelwitten.splice(i, 1); //Verwijder het doelwit dat geraakt is  doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek.  return; } } }    Verbeter het spel We hebben zojuist een spel gemaakt. Kan jij het spel verbeteren? Probeer de volgende ideeën toe te voegen:\n Geef de doelwitten mooie kleuren. Kan jij de kleur mee laten veranderen met de grootte van de doelwitten? Voeg tekst toe die de huidige score laat zien. Zo kan je aan andere Ninja\u0026rsquo;s laten zien wat je record is. Vind je het spel te makkelijk of te moeilijk? Pas de hoeveelheid doelwitten of de krimpsnelheid aan!  Tot slot De instructie geeft je slechts een introductie van wat er mogelijk is met de p5.js bibliotheek. Naast tekenen kun je ook met geluid werken, of met foto\u0026rsquo;s en filmpjes.\nZie https://p5js.org/examples/ voor een overzicht van voorbeelden.\nEen aantal voorbeelden die we zelf leuk vinden:\n https://p5js.org/examples/math-parametric-equations.html https://p5js.org/examples/math-graphing-2d-equations.html https://p5js.org/examples/math-distance-2d.html https://p5js.org/examples/sound-playback-rate.html (zet je luidsprekers aan!) https://p5js.org/examples/sound-oscillator-frequency.html (zet je luidsprekers aan!)  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 22, 2021","permalink":"/instructies/p5.js-art/","title":"P5.js - Art"},{"categories":null,"contents":"We gaan kunst maken met Python Turtle.\nIntroductie We gebruiken voor deze instructies Thonny, een eenvoudige editor voor Python scripts.\nJe kunt deze hier downloaden en vervolgens installeren.\nIn Thonny kun je op twee manieren code uitvoeren.\n Door de code die je hebt geschreven - je script - uit te voeren in de editor, dit is het bovenste deel van Thonny. Uitvoeren van je script doe je door op de groene startknop te klikken of de F5-toets in te drukken. De eerste keer dat je dit doet vraagt Thonny je om het script op de computer op te slaan. In de shell, het onderste deel van Thonny. Hier kun je je code regel voor regel uitproberen door na het typen van een regel op Enter te drukken. Tip: regels code die je eerder in de shell hebt getypt kun je opnieuw gebruiken door pijltje omhoog te gebruiken.  Mocht je nog geen ervaring hebben met Thonny en Turtle, kijk dan ook eens naar onze Python Turtle instructies.\nJe kunt ook kunst maken met Scratch. Kijk daarvoor naar de Scratch Art instructies.\nIn deze instructie behandelen we kunst met lijnen, cirkels, polygonen (zoals een driehoek en vierkant) en een lissajous.\nLijnen We beginnen eenvoudig met het tekenen van een enkele lijn:\n1 2 3 4 5  from turtle import * forward(100)  done()   Op regel 1 wordt Turtle geladen. Deze regel is nodig om de Turtle commando\u0026rsquo;s te kunnen gebruiken.\nOp de 3e regel wordt met Turtle commando forward een lijn getrokken met lengte 100.\nTenslotte zorgt done op regel 5 er voor dat het scherm waarop getekend is, open blijft.\nOpdracht 1: Verander de lengte eens en kijk wat er gebeurt.\nOpdracht 2: Maak de lengte eens negatief. Waar gaat de lijn heen?\nPolygonen Een andere naam voor een polygoon is een veelhoek. Voorbeelden van eenvoudige veelhoeken zijn een driehoek, vierkant en vijfhoek.\nEen driehoek tekenen Met drie lijnen kun je een driehoek tekenen. Dit kan er als volgt uitzien:\n1 2 3 4 5 6 7 8 9 10  from turtle import * forward(100) right(120) forward(100) right(120) forward(100) right(120)  done()   Het commando right op regels 4, 6 en 8 zorgt ervoor dat de pen naar rechts draait en wel met 120 graden.\nOpdracht 3: Voer regels 3 tot en met 8 eens stap voor stap uit en zie wat elke stap doet.\nTekenen met herhalingen In het vorige voorbeeld zag je 3 keer een herhaling van een forward en right commando. Dit kun je ook met een herhaling beschrijven in Python:\n1 2 3 4 5 6 7  from turtle import * for i in range(3): forward(100) right(120)  done()   Op regel 3 zorgt commando for i in range(3) ervoor dat regels 4 en 5 driemaal herhaald worden.\nOpdracht 4: Verander de range (het getal 3) eens naar 1, 2, 3 of 4? Wat gebeurt er?\nOpdracht 5: Maak de hoek (het getal 120) eens groter of kleiner en kijk wat er gebeurt.\nTekenen met een functie Je hebt over herhalingen geleerd. Je kunt herhalingen nog makkelijker maken door een functie te gebruiken.\nEen functie is een stukje code met een naam. Door die naam kun je de functie overal in je code gebruiken. Verder kun je getallen meegeven om het gedrag van de functie aan te passen.\nHier een voorbeeld van de code voor de functie vorm:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from turtle import * def vorm(x, y, rib, hoeken, rotatie=0): goto(x, y) right(rotatie) pendown() for _ in range(hoeken): forward(rib) right(180 - ((hoeken - 2) * 180 / hoeken)) penup() right(-rotatie)  vorm(0, 0, 100, 4, 45) vorm(30, 300, 80, 5, 60)  done()   Je hoeft niet te weten hoe een functie precies werkt, maar wel hoe je deze moet gebruiken.\nFunctie vorm heeft de volgende parameters:\n x: de horizontale plek in het plaatje. 0 is in het midden. - getallen zijn naar links en + getallen naar rechts. y: de verticale plek in het plaatje. 0 is in het midden. - getallen zijn naar beneden en + getallen naar boven. rib: een vierkant bestaat uit vier lijnen. Deze lijnen heten ribben. Parameter rib is een getal groter dan 0 dat bepaalt hoe lang elke zijde van de veelhoek is. hoeken: een driehoek heeft 3 hoeken (duh!). Met parameter hoeken kun je aangeven hoeveel hoeken de veelhoek moet hebben. rotatie: meestal wordt een vierkant recht getekend dus de bovenste en onderste rib horizontaal en de linker- en rechterrib verticaal. Met de parameter rotatie kun je het vierkant (of andere veelhoek) kantelen.  Op regels 15 en 16 staan voorbeelden van het gebruik van de functie vorm. De eerste is een vierkant midden in het plaatje. Het tweede een gekantelde vijfhoek boven in het plaatje.\nOpdracht 6: Maak eens een achthoek met een rib van 120.\nOpdracht 7: Herhaal de aanroep van de vorm functie eens een paar keer met iedere keer andere waarden.\nJe kunt de polygonen ook inkleuren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  from turtle import * def vorm(x, y, rib, hoeken, rotatie=0): goto(x, y) right(rotatie) pendown() for _ in range(hoeken): forward(rib) right(180 - ((hoeken - 2) * 180 / hoeken)) penup() right(-rotatie) vorm(0, 0, 120, 8, 45) fillcolor(\u0026#34;red\u0026#34;) begin_fill() vorm(-19, -46, 80, 8, 45) end_fill() goto(-120, -175) color(\u0026#34;white\u0026#34;) write(\u0026#34;STOP\u0026#34;, font=(\u0026#39;Arial\u0026#39;, 36, \u0026#39;bold\u0026#39;)) hideturtle() done()   Voor het inkleuren van de figuur gaat het eigenlijk alleen maar om regels 17, 18 en 20.\nMet fillcolor kies je de kleur. Na begin_fill wordt een volgend figuur dat getekend wordt ingekleurd. Om te voorkomen dat een daarop volgend figuur ook wordt ingekleurd, gebruik je end_fill.\nOpdracht 8: Neem de code over en voer deze uit. Er zit een verrassing in! 😉\nCirkels Naast rechte lijnen, kun je met Turtle ook cirkels tekenen. Daarvoor is het commando circle:\n1 2 3 4 5  from turtle import * circle(100)  done()   Het getal 100 op lijn 3 staat voor de diameter van de cirkel.\nOpdracht 9: Maak de cirkel eens groter.\nAls je cirkels combineert met herhalingen en rotaties, dan kun je mooie figuren als deze maken:\nDe code die hierbij hoort, is:\n1 2 3 4 5 6 7  from turtle import * for i in range(12): circle(100) right(30)  done()   Door met het aantal (getal 12) en de hoek tussen de cirkels (getal 30) te spelen, kun je het figuur er anders uit laten zien.\nOpdracht 10: Als je de hoek kleiner maakt, bijvoorbeeld 20, heb je dan genoeg cirkels om het figuur helemaal rond te maken? Welk getal moet je aanpassen om het figuur weer compleet te krijgen? Moet dit groter of kleiner worden?\nDoor met kleuren te spelen, wordt de figuur nog mooier:\n1 2 3 4 5 6 7 8 9 10 11  from turtle import * kleuren = [\u0026#34;red\u0026#34;, \u0026#34;cyan\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;blue\u0026#34;] bgcolor(\u0026#34;black\u0026#34;)  for i in range(12): color(kleuren[i % 7])  circle(100) right(30) done()   Op regel 3 worden de kleuren die we willen gebruiken in een lijstje gezet. Je kunt niet zomaar elke kleur gebruiken en Python snapt geen Nederlands. Voor een overzicht van de kleuren die mogelijk zijn, kun je even kijken naar onze Python Turtle instructies.\nOp regel 4 maken we de achtergrond zwart. Hierdoor komen de kleuren in het lijstje beter uit.\nOp regel 7 wordt een kleur gekozen uit het lijstje en geactiveerd.\nOpdracht 11: Neem de code over en kies eens wat andere kleuren. Je kunt ook het lijstje korter of langer maken, maar dan moet het getal 7 op regel 7 aangepast worden, zodat het gelijk is aan het aantal kleuren in de lijst.\nLissajous Met lijnen, polygonen en cirkels kun je al mooie plaatjes maken. Met een Lissajous wordt het nóg interessanter.\nMet een wiskundige formule worden twee golven gecombineerd:\nSinus Allereerst tekenen we een sinus-golf:\nDat doe je met deze code:\n1 2 3 4 5 6 7 8 9 10  from turtle import * from math import sin  penup() goto(-400, 0) pendown() for i in range(-400, 400): goto(i, 100 * sin((i + 400) / 50))  done()   Let op: zorg dat je regel 2 overneemt, anders wordt het sinus commando niet herkend.\nHet commando sin zorgt hier voor de golfvorm. Afhankelijk van het getal dat je als parameter mee geeft, gaat de golf sneller of langzamer.\nOpdracht 12: Vervang getal 50 op regel 8 eens door een groter of kleiner getal. Wat gebeurt er?\nOpdracht 13: Vervang getal 100 op regel 8 eens door een groter of kleiner getal. Wat gebeurt er?\nLissajous Als we twee sinussen in één formule combineren, dan kun je een Lissajous tekenen. Kijk eens naar de volgende code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from turtle import * from math import sin a = 4 b = 3 x = 0 y = 0 s = 300  for i in range(1000): goto(s * sin(x/150), s * sin(y/150)) x += a y += b  done()   Op regel 11 zie je de combinatie van twee sinussen in het goto commando. Met dit commando verschuif je de pen over het plaatje. Met de eerste parameter horizontaal en met de tweede verticaal. Door voor beiden een sinus te gebruiken, schuift de pen zowel horizontaal en verticaal.\nOpdracht 14: Neem de code over en voer het uit. Zie je hetzelfde plaatje als hierboven?\nOpdracht 15: Maak de waarde voor s (regel 8) eens kleiner? Wat gebeurt er? En als je het groter maakt?\nOpdracht 16: Variabelen a en b bepalen de vorm van de Lissajous. Probeer eens andere waarden, zoals bijvoorbeeld a = 18 en b = 19. Hoe ziet dat er uit? En als a en b 4 zijn? Of 1 en 2?\nTot slot Zoals je ziet kun je met Python Turtle leuke kunststukjes maken. Gebruik je fantasie, maar vooral: durf te proberen met allerlei getallen en kleuren. Wie weet wat je kunt maken?\nTer voorbereiding van deze instructie hebben we zelf ook wat kunst gemaakt. Probeer ze eens uit:\n art-1.py gekleurde lijnen\n art-2.py gekleurde lijnen\n art-3.py gekleurde lijnen\n art-4.py gekleurde cirkels\n art-5.py gekleurde veelhoeken\n art-6.py gekleurde en gedraaide vierkanten\n art-7.py lissajous\n art-8.py willekeurige gekleurde vijf- en zevenhoeken\n art-9.py willekeurig gekleurde gedraaide negenhoeken\n  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 18, 2021","permalink":"/instructies/python-art/","title":"Python - Art"},{"categories":null,"contents":"We gaan kunst maken met Scratch.\nIntroductie Naast een leuke achtergrond en het bewegen van de kat van Scratch kun je nog veel meer doen. Je kunt Scratch ook laten tekenen.\nHier zie je een paar voorbeelden van wat je met Scratch kunt:\n                  Deze instructie leert je stap-voor-stap vergelijkbare tekeningen te maken.\nBenodigdheden Om de instructie te volgen, heb je naast je computer niets nodig.\nGa naar https://scratch.mit.edu/projects/editor/ om aan de stappen te beginnen.\nDeze instructies gaan er vanuit dat je de pen uitbreiding gebruikt. Deze moet je eerst activeren:\n Open het overzicht met uitbreidingen:  Kies uit het overzicht de pen uitbreiding  Er zijn nu groene pen blokken beschikbaar die verder in de instructies worden gebruikt   Stappen Polygonen Een polygoon is een ander woord voor een veelhoek. Een veelhoek is een vorm in een plat vlak met een aantal hoeken. Een veelhoek met 3 hoeken is een driehoek. Maar ook een achthoek is een veelhoek. In dit hoofdstuk gaan we veelhoeken tekenen.\nDriehoek Een driehoek is een eenvoudige veelhoek. Het bestaat uit 3 hoeken en 3 lijnen. Je kunt deze makkelijk teken met Scratch:\nVoor elke hoek doe je twee dingen:\n neem 100 stappen om een lijn te tekenen draai de pen 120°  En dat herhaal je dan 3 keer.\nOpdracht 1: Maak het voorbeeld eens na en experimenteer eens met het aantal stappen of de hoeken.\nVierhoek De vierhoek is nog een eenvoudige veelhoek. Het bestaat uit 4 hoeken en 4 lijnen. Ook deze kun je makkelijk teken met Scratch:\nVoor elke hoek doe je twee dingen:\n neem 100 stappen om een lijn te tekenen draai de pen 90°  En dat herhaal je dan 4 keer.\nOpdracht 2: Neem je code van de driehoek en pas het aan zodat het een vierkant kan maken.\nOpdracht 3: Neem je code van de vierhoek en probeer er eens een vijfhoek van te maken. Wat moet er veranderen?\nMisschien valt het je op, dat de stappen voor de driehoek, vierhoek en vijfhoek erg vergelijkbaar zijn. Het aantal herhalingen is gelijk aan het aantal hoeken en de hoek van de te maken draai wordt wordt steeds groter.\nPolygoon functie Bij de vierhoek en vijfhoek zagen we al dat het tekenen ervan vooral bestaat uit herhaling van stappen. Ook is er eigenlijk maar één getalletje dat veranderd; het aantal hoeken.\nOm verschillende polygonen te tekenen, is het dus handig om één blokje te hebben waarbij je het aantal hoeken kunt opgeven.\nLet op: bij deze stap ga je zelf het blok \u0026ldquo;polygoon\u0026rdquo; samenstellen; deze bestaat nog niet. Om dit te doen ga je naar Mijn blokken \u0026gt; maak een blok. Hierdoor beland je op het volgende scherm:\nVerander hier de naam van het blok van bloknaam naar polygoon.\nSelecteer vervolgens Voeg een invoer toe: getal of tekst.\nNoem deze invoer vervolgens aantal hoeken en klik op OK.\nVanaf nu staat \u0026ldquo;polygoon\u0026rdquo; onder Mijn blokken vermeld.\nDaarnaast kan je de variabele \u0026ldquo;aantal hoeken\u0026rdquo; verkrijgen door deze uit het definieer polygoon blok te slepen.\nLinks staat het nieuwe blok dat polygonen tekent. Rechts staat hoe je het nieuwe blok kunt gebruiken.\nOpdracht 4: Maak het voorbeeld na. Wat wordt er getekend?\nOpdracht 5: Experimenteer eens wat met het aantal hoeken, wat gebeurt er als je een groot aantal hoeken (20?) kiest?\nOpdracht 6: Kun je het volgende figuur maken?\nLissajous Een lissajous is een vorm gemaakt met een wiskundige formule. Het is een combinatie van twee golven.\nDe combinatie van twee golven\nSinusgolf Voordat we de Lissajous maken, beginnen we met een enkele sinusgolf:\nHieronder de code die hiervoor gebruikt is. Het belangrijkste blokje is het groene, met daarin variabelen amplitude, frequentie en x. Dit blokje zorgt voor de golfvorm.\nOpdracht 7: Maak het voorbeeld na. Ziet het er hetzelfde uit als in het plaatje?\nOpdracht 8: Probeer eens wat te varieren met de waarden van variabele amplitude en een frequentie. Wat gebeurd er?\nLissajous functie Hieronder staan een paar voorbeelden van een Lissajous. Met twee getallen (a en b) kan je aanpassen hoe een Lissajous eruit ziet.\na = 1, b = 2\na = 3, b = 4\na = 5, b = 4\nDe code om er een te maken ziet er als volgt uit:\n Eerst wordt de pen gereset. Dan wordt de Lissajous functie aangeroepen met drie waardes: maat, a en b. Daarna wordt er elke keer de X- en Y-positie berekend. Hiermee wordt de vorm getekend.  Het groene blokje dat zorgt voor de golfvorm, wordt nu twee keer wordt gebruikt in het blauwe \u0026lsquo;ga naar\u0026rsquo; blok.\nOpdracht 9: Maak het voorbeeld na. Kun je de waarden a en b van de drie voorbeelden gebruiken? Zijn de getekende plaatjes dan hetzelfde als de drie voorbeelden?\nOpdracht 10: Probeer eens rare getallen uit voor maar, a en b en kijk wat er gebeurd.\nOpdracht 11: Maak de lissajous kleurrijk, zoals als opdracht 6.\nConclusie Je hebt nu een indruk gekregen van hoe je met Scratch kunt tekenen. Eerst door veelhoeken of polygonen te tekenen en te herhalen en vervolgens door een Lissajous te maken.\nVervolg Heb je de smaak te pakken gekregen van het maken van kunst met Scratch? Kijk dan ook naar deze links:\n Scratch art voorbeelden: https://scratch.mit.edu/search/projects?q=art Scratch kunst voorbeelden: https://scratch.mit.edu/search/projects?q=kunst  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 13, 2021","permalink":"/instructies/scratch-art/","title":"Scratch - Art"},{"categories":null,"contents":"Alles wat je moet weten om gave dingen te maken\nWat is de Arduino? De Arduino is een microcontroller, wat betekent dat het een heel simpele computer is. Je kunt er sensoren op aansluiten om van alles waar te nemen in de omgeving, en er ook allerlei soorten ‘outputs’ mee aansturen zoals motoren en lampen.\nEr bestaan verschillende soorten Arduino’s en veel vergelijkbare microcontrollers, maar de Arduino Uno die je hierboven ziet is het bekendst. Op de Arduino zie je nummers en markeringen staan die aangeven wat je erop kunt aansluiten. ‘3.3V’ en ‘5V’ zijn de pinnen waar je stroom met die voltages uit kunt halen. Je zou ze kunnen zien als de plus van een batterij. De min van het Arduinobordje vind je bij ‘GND’.\nVerder zie je 14 digitale pins en 6 analoge pins, die we allemaal kunnen gebruiken als inputs én als outputs.\nDe software installeren We hebben de Arduino-software nodig om het Arduino-bordje te kunnen programmeren. Om de software te downloaden ga je naar arduino.cc/download.\nKies je besturingssysteem (Windows, Linux of Mac) in het dondergroene vlak met de titel ‘Download options’. (Heb je Windows? Kies dan de bovenste optie.) In het volgende scherm kun je klikken op ‘Just download’. Als het bestand gedownload is, kun je het Arduino-programma installeren en openen.\nJe eerste Arduino-programma De stukjes software die we maken voor de Arduino noemen we schetsen (in het Engels ‘sketches’) of gewoon programma’s. Schetsen zijn tekstbestandjes waar instructies voor het Arduino-bordje in staan. Programmeurs noemen zulke instructies ook wel ‘code’. Je gaat nu je eerste Arduino-programma maken door een bestaand voorbeeld te openen en aan te passen.\nOpen het menu Bestand, dan Voorbeelden, Basics en klik dan op Blink. De schets dat zich nu opent in een nieuw venster gaan we uploaden naar de Arduino.\nSluit het Arduino-bordje aan op je computer met een USB-kabel.\nKlik op het tweede icoontje van links:\nHet Arduino-programma zal de schets nu op de chip van de Arduino gaan zetten.\nMogelijk krijg je de eerste keer een venster te zien waarin je moet aangeven waar de computer de Arduino kan vinden. Kies daar voor een adres met ‘usb’, ‘serial’ of ‘COM’ erin, en niet voor ‘bluetooth’.\nAls je linksonder in het scherm ‘Uploaden voltooid’ ziet, dan is het gelukt en is er nu op de Arduino een LED-lampje aan het knipperen!\nAls je een foutmelding krijgt, bekijk dan de pagina ‘Problemen oplossen’ achteraan deze handleiding.\nOefening  Kun je het LED-lampje sneller laten knipperen?\nLet op: als je iets in de schets verandert, moet je hem opnieuw uploaden. Kun je de LED in verschillende patronen laten knipperen?\nKun je bijvoorbeeld SOS knipperen?  Hoe zit een Arduino-programma in elkaar? Belangrijk om door te hebben: bijna alle Arduino-schetsen hebben drie onderdelen.\nIn het eerste deel, helemaal bovenaan in de schets, worden vaak wat variabelen klaargezet. (Hoe variabelen werken kun je verderop in deze handleiding lezen.)\nIn het geval van Blink staat daar alleen wat commentaar. Alle regels met twee schuine strepen ervoor zijn toelichting. Zulke regels staan er om aan jou uit te leggen hoe het programma werkt. Alle regels tussen /* en */ zijn ook commentaar. (Je herkent commentaar ook aan de grijze kleur van de tekst.)\nHet tweede deel is een functie die ‘setup’ heet. Alles wat daarin staat, wordt één keer uitgevoerd.\nvoid setup() { // alles wat tussen de accolades (de gekrulde haakjes) staat, hoort bij  // setup en wordt in één keer uitgevoerd.  // In Blink wordt bijvoorbeeld het ingebouwde LED-lampje op  // het Arduino-bord aangemeld als output:  pinMode(LED_BUILTIN, OUTPUT); } Het derde deel van de schets is de functie die ‘loop’ heet. Dit deel van het programma wordt steeds weer opnieuw gedaan, voor altijd.\nvoid loop() { digitalWrite(LED_BUILTIN, HIGH); // zet de LED aan (HIGH is het voltage niveau)  delay(1000); // wacht een seconde  digitalWrite(LED_BUILTIN, LOW); // zet de LED uit (bij LOW is de spanning uit)  delay(1000); // wacht een seconde } De ingebouwde LED is op de Arduino Uno aangesloten op pin 13. ‘LED_BUILTIN’ is een woord dat 2 Arduino herkent, maar je zou in plaats daarvan ook ‘13’ kunnen schrijven.  In Blink bijvoorbeeld wordt in loop() het ingebouwde LED-lampje aangezet 2 (‘HIGH’), dan wordt er een seconde gewacht (duizend milliseconden), dan wordt de LED weer uitgezet (‘LOW’), dan wordt er weer een seconde gewacht, en dan begint loop() weer opnieuw.\nHoe een breadboard werkt Om sensors en andere componenten te verbinden met de Arduino (of met elkaar), is het vaak handig om een breadboard te gebruiken.\nDe gaatjes op het breadboard zijn binnenin het plastic bordje met metalen strips met elkaar verbonden. De gaatjes in het midden zijn verbonden in kolommen van vijf (zoals die in het groene kader hiernaast).\nDe letters en cijfers op het breadboard gebruiken we meestal niet. Die vijf gaatjes zijn alleen met elkaar verbonden, dus niet met gaatjes ernaast of met gaatjes aan de overkant van de kloof in het midden.\nDe horizontale rijen bovenaan en onderaan, met de rode en blauwe lijnen ernaast, gebruiken we om meerdere onderdelen van stroom te voorzien. Rood is plus en blauw (of zwart) is min, net zoals batterijen een plus en een min hebben. Die gaatjes zijn alleen verbonden met de andere gaatjes in dezelfde horizontale rij, dus niet niet met de gaatjes erboven of eronder.\nHet is daarom verstandig om je altijd aan de juiste kleuren te houden: de rode rij op het breadboard voor plus en de blauwe rij voor min. Gebruik ook zoveel mogelijk rode draadjes om componenten met de positieve kant te verbinden, en zwarte of blauwe draadjes voor de verbinding met de negatieve kant.\nDigitale sensors: een knop Een Arduino programmeren om lampjes te laten knipperen is leuk, maar eigenlijk willen we dat hij ook kan reageren op zijn omgeving. Laten we dat nu proberen.\nVerbind eerst een drukknop met de Arduino zoals op de tekening:\n Zet de knop op het breadboard met twee pootjes aan elke kant van de gleuf in het midden (als het zo dadelijk niet werkt, moet je de knop misschien een kwartslag draaien). Verbind één kant van de knop met één van de gaatjes van de Arduino waar GND naast staat. De andere kant van de knop verbind je met het gaatje waar ‘2’ bij staat (niet ‘A2’).  Open nu de schets die bij deze schakeling hoort, via het menu Bestand \u0026gt; Voorbeelden \u0026gt; Digital \u0026gt; DigitalInputPullup.\nUpload de schets naar de Arduino.\nProbeer de knop maar. Als het goed is, heb je nu je eerste werkende digitale sensor! Als je op de knop drukt, gaat de LED aan. Dit is dus al meteen een combinatie van input en output.\nHoe werkt het? In het programma zie je dat in de functie setup() pin nummer 2 als een ingang wordt ‘opengezet’:\npinMode(2, INPUT_PULLUP); Op die pin heb je de knop aangesloten, en dankzij deze regel in de schets weet de Arduino dat ook.\nVervolgens wordt pin nummer 13 als een uitgang gedefiniëerd:\npinMode(13, OUTPUT); De ingebouwde LED op de Arduino is verbonden met pin 13, en dankzij deze regel weet de Arduino dat we die willen gaan gebruiken.\nNu gaan we in de gaten houden of de knop wordt ingedrukt. Dat doen we met de functie digitalRead():\nint sensorVal = digitalRead(2); Als je op de knopt drukt die is verbonden met pin 2 van de Arduino, levert digitalRead hier een 0 op. Als je de knop loslaat, wordt dat een 1. Die waarde wordt vervolgens bewaard in een variabele die ‘sensorVal’ heet (meer uitleg over variabelen lees je verderop).\nDaarom is een knop een voorbeeld van een digitale sensor: er zijn maar twee mogelijkheden. Andere voorbeelden van digitale sensoren zijn bewegingsensors (zoals PIR-sensors die automatisch het licht aandoen in WC’s) en ‘oogjes’ zoals bovenaan roltrappen. Dit alles staat in de functie loop(), wat betekent dat digitalRead() steeds opnieuw wordt uitgevoerd en de knop dus continu in de gaten wordt gehouden. ‘sensorVal’ bevat steeds de huidige stand van de knop, 1 of 0, aan of uit.\nOm iets te doen met de informatie die de sensor doorgeeft, staat in de schets vervolgens een if-statement. Hoe dat werkt, lees je hierna\nIf-statements Om de Arduino iets te laten doen als er iets verandert, moeten we hem leren om vragen te stellen. Een vraag in Arduino ziet er zo uit:\nif (sensorWaarde \u0026gt; 30) { // doe hier iets } Dit heet een if-statement. Je laat Arduino vragen: is de knop ingedrukt? Of, zoals in het voorbeeld hierboven: is het getal dat de sensor teruggeeft groter dan 30? Als het antwoord op zo’n vraag ‘ja’ is, dan voert Arduino de code uit die tussen de gekrulde haken staat.\nIn de DigitalInputPullup-schets van zojuist ziet dat er zo uit:\nif (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } Door hoe we de knop hebben aangesloten, betekent ‘HIGH’ in dit geval dat de knop niet wordt ingedrukt. Hier wordt eerst gevraagd: wordt de knop ingedrukt? Als dat niet zo is, dan zetten we het LEDje uit, en anders zetten we het aan. Dit is dus een uitbreiding op het if-statement: met ‘else’ kunnen we instructies toevoegen voor het geval het antwoord op de vraag ‘nee’ is.\nInterpunctie Merk op dat elke haakje openen een haakje sluiten nodig heeft, dus ‘(’ en ‘)’, en ‘{’ en ‘}’. Elk commando zoals digitalWrite() moet eindigen op een puntkomma. Programmeertalen zijn heel gevoelig op dit soort dingen en zullen niet meewerken als je dit soort dingen verkeerd doet. Als je toch foutmeldingen krijgt, kijk dan naar de paragraaf ‘Problemen met de code’ aan het eind van deze handleiding.\nOefening Nu gaat de LED aan als je de knop indrukt. Kun je de code zo aanpassen dat de LED juist uitgaat als je de knop indrukt?\nZien wat er gebeurt: de seriële monitor Stel je voor dat er iets misgaat, bijvoorbeeld dat er níet een LEDje gaat branden als je op de knop drukt. Dan zou het handig zijn als de Arduino zelf kon vertellen of hij ten minste ziet dat de knop wordt ingedrukt, want dat zou ons helpen te ontdekken wat het probleem is. Gelukkig kan de Arduino dat.\nWe kunnen een communicatieverbinding opzetten tussen de computer en het Arduino-bordje. Dat doen we door deze regel in setup() te zetten (in de DigitalInputPullup-schets staat dit er al):\nSerial.begin(9600); In loop() zetten we direct onder de regel waar we de sensor uitlezen deze regels:\nSerial.print(\u0026#34;sensor = \u0026#34;); Serial.println(sensorValue); Open vervolgens de seriële monitor door te klikken op het vergrootglasicoontje rechtsbovenaan in het venster.\nAls de schets van de knop (DigitalInputPullup) nog steeds op de chip van de Arduino staat, dan zou je nu in de seriële monitor moeten kunnen zien of de knop wordt ingedrukt. Als je niks ziet veranderen, dan weet je dus dat de knop het niet doet of niet goed is verbonden met pin 2.\nDe seriële verbinding is vaak enorm handig om te kijken of Arduino doet wat wij in gedachte hadden, en zo niet, waar het probleem dan zit.\nWe kunnen de verbinding ook gebruiken om sensordata uit de Arduino te gebruiken in andere software op de computer, bijvoorbeeld om interactieve animaties of muziek te maken.\nDie 9600 is de baud rate, de snelheid waarmee de computer en de Arduino met elkaar praten. Sommige schetsen gebruiken andere waardes zoals 115200. De baud rate in de seriële monitor moet overeen komen met die in de schets, anders zie je rare tekens of gewoon niets.  Analoge sensors De knop die we tot nu toe gebruikt hebben, is een soort digitale sensor. Zulke sensoren kennen alleen 1 en 0, oftewel aan en uit, LOW en HIGH.\nEr zijn ook een heleboel analoge sensoren, die tussenwaardes kunnen geven. Een voorbeeld daarvan is een lichtsensor, die kan laten weten of het donker is of juist heel erg licht, maar die ook alle gradaties ertussenin kan meten.\nEen ander voorbeeld van een analoge sensor is de potmeter of potentiometer. Dat is een draaiknop die je het beste kent als volumeknop op versterkers. In Arduino kun je heel precies de positie zien van de draaiknop.\nSluit de potmeter aan zoals op de afbeelding: de middelste pin op de analoge poort A0, en de buitenste pinnen op 5V en GND.\nOpen vervolgens dit programma: Bestand \u0026gt; Voorbeelden \u0026gt; 03. Analog \u0026gt; AnalogInput.\nUpload de schets naar de Arduino. Als het goed is kun je nu de LED sneller en langzamer laten knipperen door aan de knop te draaien!\nOok leuk: probeer de waardes die van de potmeter komen te bekijken met de seriële plotter. Hoe dat moet, wordt onthuld op de volgende pagina.\nOefening Sluit een kleine speaker of ‘buzzer’ aan op GND en pin 13 (via het breadboard). Dat is dus op dezelfde pin als de interne LED van de Arduino. Hoor je een verschil als je aan de knop draait?\nSeriële plotter Om analoge waarden goed te kunnen laten zien, heeft de Arduino-software een geweldige feature in huis.\nOpen het menu Hulpmiddelen en klik op Seriële plotter (sluit eerst de seriële monitor als dat venster nog openstaat). De sneltoets-combinatie voor de seriële plotter is shift+command+L.\nOpen de schets AnalogReadSerial via het menu Bestand \u0026gt; Voorbeelden \u0026gt; 01. Basics \u0026gt; AnalogReadSerial, en upload het naar de Arduino.\nJe zou in het venster van de seriële plotter nu een grafiek moeten zien van de veranderingen in de positie van de potmeter! (Of de resultaten van een andere analoge sensor, zoals bijvoorbeeld de lichtsensor.)\nMeerdere sensoren Als je de resultaten van meerdere sensoren in de seriële plotter wil zien, dan moet je zorgen dat die waardes gescheiden door tabs worden doorgestuurd:\nSerial.print(sensor1); // waarde van de eerste sensor Serial.print(\u0026#34;,\\t\u0026#34;); // waardes gescheiden door komma en tab Serial.print(sensor2); // waarde van de tweede sensor Serial.println(); // witregel Het helpt om verder geen print()’s in je programma te hebben die tekst schrijven naar de seriele verbinding (zoals je soms wel doet om feedback van je schets te zien in de seriële monitor). Als je zulke print()’s met tekst wel hebt in je schets, misschien moet je ze dan even tijdelijk uitschakelen door er met // commentaar van te maken.\nUltrasone afstandssensor Als je wil weten hoe ver iets of iemand is (bij je robot of kunstwerk vandaan bijvoorbeeld), dan is een ultrasone afstandssensor geweldig. Er zitten twee ronde dingen op, een speaker en een microfoon. De sensor werkt door met de speaker een ultrasoon geluid te maken, en vervolgens met de microfoon te meten hoe lang het duurt voordat de echo van dat geluid terugkomt. Door die tijd te delen door snelheid van het geluid, kan de Arduino uitrekenen hoe ver weg iets is.\n343 meter per seconde; de gevonden tijd wordt ook nog door 2 gedeeld, omdat het geluid twee keer de 6 afstand heeft afgelegd als de echo wordt opgevangen.\nJe sluit de sensor zo aan op de Arduino, eventueel via een breadboard:\n de pin op de sensor waar VCC bij staat naar 5V op de Arduino, GND op de sensor naar GND op de Arduino, Trigger naar digitale pin 12 van de Arduino, Echo naar pin 11 van de Arduino.  Je kunt code voor dit type sensor overal online vinden, maar de NewPing-library is erg makkelijk te gebruiken. Die moet je dan wel even installeren—als je nog niet weet hoe dat moet, kijk dan even op de pagina ‘Libraries installeren’ verderop.\nIn het voorbeeldprogramma NewPingExample (zie Bestand \u0026gt; Voorbeelden \u0026gt; NewPing) kun je zelf de maximale afstand instellen die je wil meten. Een meter of vier à vijf is wel het maximaal haalbare met deze sensor.\nMeer informatie over de NewPing-library vind je hier: https://bitbucket.org/teckel12/arduino-new-ping\nUpload de code naar de Arduino, en open de seriële monitor om de afstand te zien die de sensor meet.\nUltrasone afstandssensors meten de afstand tot objecten in een smalle strook van 15 graden. Als je een breder gebied wil scannen, dan zou je meerdere ultrasone sensors naast elkaar kunnen zetten, of een enkele sensor op een motortje kunnen zetten om een draaiende radar te maken. Een meer complete oplossing is beeldherkenning, maar dat is ook een stuk ingewikkelder. Als je alleen maar wil weten óf iemand in de buurt is (en niet per se hoe ver weg ze zijn), gebruik dan een PIR-sensor.  Variabelen Variabelen zijn woorden of letters waarmee we Arduino iets kunnen laten onthouden. Dat is belangrijk als we Arduino bijvoorbeeld willen laten bijhouden hoe vaak iets is gebeurd.\nEen variabele definiëren ziet er zo uit:\nint aantal = 100; Door ‘int’ ervoor te zetten zeggen we: de variabele is een heel getal, dus geen decimaal. Dan geven we de variabele zijn naam. In dit geval is dat ‘aantal’, maar het zou net zo goed ‘x’ mogen zijn, of ‘sensorWaarde’. Meestal kiezen we een naam die goed duidelijk maakt wat voor informatie we willen opslaan in die variabele. Vervolgens vertellen we de variabele wat zijn beginwaarde wordt—in dit geval 100. Tot slot wordt de regel afgesloten met een puntkomma, net als alle commando\u0026rsquo;s in Arduino.\nAndere typen variabelen zijn bijvoorbeeld float (dat is wel een decimaal getal) en bool (alleen ‘true’ of 8 ‘false’). Je vindt alle typen op https://www.arduino.cc/reference/en/ onder ‘Data Types’.\nAls je een variabele eenmaal op die manier gedefiniëerd hebt, dan kun je met die variabele gaan rekenen. Als we dit doen…\naantal = aantal + 100; … dan heeft ‘aantal’ nu een waarde van 200.\nOefening Met variabelen kun je bijvoorbeeld ook bijhouden hoe vaak een knop is ingedrukt. Je kunt daarvoor de schets DigitalInputPullup gebruiken (zie eventueel de pagina over digitale sensors). Probeer het eerst zelf, en lees eventueel daarna de oplossing.\n mogelijke oplossing Voeg een variabele toe bovenaan in de schets (dus nog boven setup()). Tel vervolgens steeds 1 bij op, op 9 de plek waar de schets iets doet op het moment dat de knop wordt ingedrukt. Verplaats de Serial.println naar diezelfde plek om in plaats van ‘sensorVal’ de waarde van jouw variabele naar de seriële monitor te schrijven. Als je onder die regel ook nog ‘delay(500);’ toevoegt, dan wacht de Arduino een halve seconde voordat hij verdergaat. Op die manier telt hij steeds maar één druk op de knip in plaats van dat hij doortelt zolang als de knop is ingedrukt :-)  Inputs en outputs combineren Vaak willen we met de Arduino meerdere inputs en outputs tegelijk gebruiken én ze laten samenwerken. Je kunt bijvoorbeeld een potentiometer gebruiken om de snelheid van een motor te veranderen, of een lichtsensor gebruiken om de toonhoogte van een buzzer te verhogen of te verlagen. Hier lees je hoe dat moet.\nStap 1 Als je twee componenten met elkaar wil laten samenwerken, laat ze dan altijd eerst apart werken. Als er dan later iets niet werkt, weet je dat het in ieder geval niet ligt aan de individuele componenten en dat maakt het zoeken naar een oplossing veel makkelijker. Dus bijvoorbeeld:\n Sluit de potmeter aan op de Arduino Upload het programma voor de potmeter naar de Arduino, en zorg dat je de waarden van de potmeter te zien krijgt in de seriële monitor. Sluit vervolgens de buzzer aan (laat de potmeter aangesloten!). Zet de software voor de buzzer op de Arduino (laat het venster met de code met de potmeter openstaan), en ga pas verder als je de buzzer hoort.  Stap 2 Nu heb je dus twee werkende programma’s, en die kun je gaan combineren tot één programma. Zet ze naast elkaar, zodat je beide vensters op je beeldscherm hebt.\nDigitalInputPullup void setup() { Serial.begin(9600); pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); } void loop() { int sensorVal = digitalRead(2); if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } } Sweep #include \u0026lt;Servo.h\u0026gt;Servo myservo; void setup() { myservo.attach(9); } void loop() { myservo.write(10); delay(1000); myservo.write(160); delay(1000); } In Arduino-schetsen mogen setup() en loop() maar één keer voorkomen. We kunnen de schetsen dus niet combineren door ze simpelweg de ene onder de andere te plakken.\nKopiëer daarom de inhoud van de ene setup() naar de andere. Let op dat je geen accolades (gekrulde haken) meekopiëert. Let ook goed op dat je geen code boven of onder de accolades van setup() plaatst—de code hoort tussen { en } want anders werkt het niet.\nDoe hetzelfde voor loop() en eventuele regels die nog bóven setup staan.\nVoor de afgebeelde schetsen ziet dat er zo uit:\nGecombineerd #include \u0026lt;Servo.h\u0026gt;Servo myservo; void setup() { Serial.begin(9600); pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); myservo.attach(9); } void loop() { int sensorVal = digitalRead(2); if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } myservo.write(10); delay(1000); myservo.write(160); delay(1000); } Stap 3 Laat je nieuwe schets controleren door Arduino. Gebruik daarvoor het eerste icoontje, links bovenaan. Als je linksonderin ziet ‘Compileren voltooid’ dan heb je het samenvoegen goed gedaan! Als je een foutmelding krijgt, los het probleem dan op. Gebruik eventueel de checklist aan het eind van deze handleiding. Sla je gecombineerde schets op op je computer, via Bestand \u0026gt; ‘Opslaan als…’.\nSoms wil je twee schetsen combineren die allebei dezelfde pin in gebruik hebben. Als je die schetsen samenvoegt, zul je dus voor één van die twee inputs of outputs een andere pin moeten gebruiken en dat onderdeel dan dus ook op die andere pin op de Arduino moeten aansluiten.  Stap 4 Nu heb je een schets die met twee componenten werkt. Als je hem uploadt naar de Arduino, dan zouden dus beide onderdelen het moeten doen.\nMaar je wil natuurlijk dat beide componenten sámenwerken! Het makkelijkste is een if-statement gebruiken (zie de pagina daarover). Een andere mogelijkheid is de sensor-data direct gebruiken voor een output; je zou bijvoorbeeld waardes uit een lichtsensor direct kunnen gebruiken als de graden voor een servo-motor.\nIn Arduino-schetsen wordt vaak gebruik gemaakt van de functie delay(). Dat levert echter nogal eens problemen op als je de Arduino twee of meer dingen tegelijk willen laten doen. De oplossing daarvoor is een timer zetten; hoe dat moet, lees je op de pagina’s verderop over timers en millis().  Bestaande code gebruiken Wat je óók kunt doen, is code van anderen gebruiken. Stel dat je een kleurensensor wil gebruiken samen met een paar LED-lampjes, dan kun je bij Google iets intypen als ‘Arduino kleurensensor LEDs’. Je vindt ongetwijfeld een heleboel handleidingen die laten zien welke onderdelen ze gebruikten en hoe, inclusief de nodige code.\nAls je zulke code overneemt, lees die code dan in ieder geval goed door en probeer te begrijpen wat elk stukje doet. Als de code niet werkt, gebruik dan de checklist aan het eind van deze handleiding om het probleem op te lossen.\nDingen laten bewegen met servo-motors De simpelste manier om met de Arduino iets te laten bewegen (robotjes, plotters, bloempotten die naar het licht draaien) is een servo. Er zijn twee soorten: servo’s die draaien tussen 0 en 180 graden, en servo’s die door kunnen blijven draaien.\nZulke ‘continuous’ servo’s vertalen de richting die je ze opgeeft in een draairichting en snelheid. ‘0’ is 10 bijvoorbeeld volle snelheid naar links, ‘90’ is stilstaan en ‘110’ betekent ‘draai langzaam naar rechts’. Als je bij zo’n servo toch wil weten hoe ver hij is gedraaid, heb je een ‘rotary encoder’ of ‘encoder wheel’ nodig.\nDe meeste kleine servo-motors hebben drie draadjes:\n bruin is ground, dus min rood is voltage, dus plus geel is de pin waarop de Arduino de servo aanstuurt.  Sluit de servo aan, met de gele draad op pin 9. Als je deze schets uploadt, gaat het motortje heen en weer draaien: Bestand \u0026gt; Voorbeelden \u0026gt; Servo \u0026gt; Sweep\nZoals je ziet in de code, wordt de servo naar een bepaalde plek gestuurd met de functie myservo.write(). In de schets gebeurt dat in een for-loop om hem stapsgewijs heen en weer te laten draaien, maar je kunt de servo bijvoorbeeld ook naar de middenpositie sturen met het commando\nGrotere servo’s De servo zoals op de foto is klein en niet erg sterk. Er zijn ook (veel) sterkere servo’s. Die kun je ook met de Arduino aansturen, maar om ze van stroom te voorzien is een externe batterij nodig:\nOefening Stuur de servo een paar keer naar verschillende standen, en laat hem tussendoor een seconde wachten. Hint: de for-loops heb je hiervoor niet nodig, want aan een paar myservo.write’s en delay()’s heb je genoeg.\nTot slot Je kunt met de Arduino ontelbaar veel combinaties maken met verschillende inputs en outputs. Je kunt bijvoorbeeld een MP3-speler geluiden laten horen als een bewegingssensor beweging detecteert, of LED-strips van kleur laten veranderen op basis van een hartslag die je meet met een hartslagsensor.\nWat je kunt maken met elektronica wordt praktisch nergens meer door beperkt. Onderdelen zijn ontzettend goedkoop geworden, en de informatie over hoe je ze moet aansluiten en kunt gebruiken is altijd online te vinden. Zoek bijvoorbeeld op Google naar ‘Arduino planten vochtsensor’ en je vindt duizenden handleidingen die niet alleen laten zien hoe je zo’n sensor aansluit op je Arduino, maar die ook de nodige code delen.\nEen paar sites zijn met name aan te raden voor inspiratie en praktische informatie:\n Instructables: https://www.instructables.com/circuits/arduino/projects/ Arduino: https://blog.arduino.cc/ en https://www.arduino.cc/reference/en/ Hackster.io: https://www.hackster.io/arduino  Het belangrijkste is dat je ziet dat iedereen kan programmeren en toffe dingen kan maken met elektronica. Niemand kan of weet alles meteen, maar met oefening en gewoon blijven proberen kom je heel ver. Er is ontzettend veel mogelijk, en jij hoort bij de mensen die gave dingen kunnen maken.\nExtra Problemen oplossen Problemen met verbinding Dit is een lijst van mogelijke oplossingen als je er niet in slaagt om code te uploaden naar de Arduino. Als de eerste oplossing niet helpt, probeer dan de volgende oplossingen, in de volgorde waarop ze genoemd worden.\n Selecteer de juiste poort. Als je een foutmelding krijgt bij het uploaden, dan is het meestal omdat de computer niet weet op welke USB-poort de Arduino te vinden is:\nJe kunt dat oplossen door de juiste poort te selecteren in het menu Hulpmiddelen onder ‘Poort’. Soms staat er al bij waar de Arduino is verbonden, maar de kans bestaat dat je zelf moet raden. Het zou een adres moeten zijn met ‘usb’ erin, ‘serial’ of ‘COM’. Zorg dat onder ‘Board’ de juiste Arduino is geselecteerd (meestal Arduino Uno). Zit de USB-kabel er aan beide kanten goed in? Probeer eens een andere USB-poort (en dan weer stap 1). Herstart de Arduino-software. Probeer het uploaden zonder dat er iets met de Arduino verbonden is. (Als dit helpt dan is er ergens kortsluiting óf is er iets verbonden met de verkeerde pin.) Herstart de computer (en zie dan weer stap 1). Als je computer de Arduino niet kan vinden onder ‘Poort’, dan kan het nodig zijn om een driver installeren. Voer de instructies uit op https://www.arduino.cc/en/ Guide/DriverInstallation (en doe dan weer stap 1). Probeer een andere Arduino  Problemen met de code De foutmeldingen die Arduino geeft onderin beeld zijn vaak behoorlijk helder. Probeer ze te begrijpen zodat je sneller een probleem kunt opsporen en oplossen.\n Waar zit de fout? Vind de regel die rood is gemaakt. De fout kan ook direct boven die regel zitten. De meest voorkomende fout is dat een functie of commando niet goed afgesloten wordt. Staat er een ‘}’ te veel of te weinig? Zorg dat er voor elke ‘(’ een ‘)’ is en voor elke ‘{’ ook een afsluitende ‘}’ en dat elk commando wordt afgesloten met een puntkomma. Staat alle code wel echt ín setup() of loop()? Dus binnen de gekrulde haken van een van beide functies? Als je schets een library aanroept die niet gevonden kan worden, dan krijg je de foutmelding ‘No such file or directory’. Installeer in dat geval alsnog de bijbehorende library; zie daarvoor de pagina ‘Libraries installeren’ in deze handleiding. Zoek online naar oplossingen voor de foutmelding die je krijgt. Zoek naar ‘Arduino “exacte foutmelding tussen aanhalingstekens”’. Gebruik een heel andere schets. Probeer een van de voorbeeldschetsen in Arduino en pas die aan, of probeer online code te vinden die doet wat jij wil.  Geen foutmelding, maar toch niet de werking die je verwacht?  Check of de componenten echt met de juiste pinnen zijn verbonden en dat dat ook de pinnen zijn die genoemd worden in de code. Bij gebruik van een breadboard: zitten de componenten écht op het goede rijtje? Gebruik Serial.println()’s om te weten wat de Arduino aan het doen is (zie de uitleg daarover op de pagina over de seriële plotter). Probeer een ander exemplaar van het onderdeel dat je probeert aan te sluiten, om te zien of dat misschien het probeem is. Probeer eventueel ook andere draadjes of zelfs een ander breadboard.  Libraries installeren Je hoeft lang niet alles helemaal zelf te programmeren. Er is al heel veel software geschreven door mensen die hun werk graag met je delen (dat heet open-source software en het is geweldig!).\nAls zulke software uitgebreider is dan een enkele schets, dan heet zo’n software-pakketje een bibliotheek, of library. Het Arduino-programma heeft een aantal libraries al voor-geïnstalleerd, maar soms zul je dat zelf moeten doen.\nStel dat je een infrarood-sensor wil uitproberen om met een afstandsbediening je Arduino-project te kunnen bedienen. Dat wordt je makkelijk gemaakt door een library die IRremote heet.\nGa naar het menu Hulpmiddelen \u0026gt; Bibliotheken beheren. Zoek op ‘IRremote’ in het zoekvenster, en dan staat hij waarschijnlijk als tweede in de lijst resultaten.\nKlik op ‘Installeren’ en dan ‘sluiten’.\nAls je een library geïnstalleerd hebt, kun je via Bestand \u0026gt; Voorbeelden de voorbeeldschetsen openen die bij de library horen. Met die schetsen kun je snel leren hoe je de library kunt gebruiken in je eigen project.\nIn het geval van IRremote: Bestand \u0026gt; Voorbeelden \u0026gt; IRremote \u0026gt; IR receiveDemo. Meer uitleg over 12 afstandsbedieningen en hoe je de library gebruikt vind je hier: https://www.circuitbasics.com/arduino-ir-remote-receiver-tutorial/\nNiet álle bibliotheken kun je op deze manier installeren. Soms moet je een map met bestanden downloaden en die dan handmatig toevoegen aan de map waar Arduino de bibliotheken bewaart. De locatie van die map vind je via het menu Arduino \u0026gt; Preferences.  Een timer voor Arduino-programma’s: millis() Als je Arduino twee dingen tegelijk wil laten doen, zoals een lampje laten knipperen en ondertussen in de gaten houden of een knop wordt ingedrukt, dan is het belangrijk om géén delay() te gebruiken. De functie delay() zorgt ervoor dat de de Arduino een tijdje wacht, en ondertussen staat alles stil. Als hij bijvoorbeeld wacht tot de LED weer aan of uitgezet kan worden, kan hij dus niet tegelijk in de gaten houden of de knop wordt ingedrukt.\nOm zoiets wel tegelijk te kunnen doen, laten we Arduino een soort stopwatch gebruiken. Die stopwatch heet millis(). Met die functie kunnen we in de gaten houden hoe lang onze schets al loopt, en op gezette tijden iets doen.\nHieronder zie je bijvoorbeeld een schets die elke drie seconden een LED aan- of uitzet, zónder in de tussentijd alles te blokkeren met delay().\nIn het Engels heet deze oplossing ook ‘non-blocking code’, code die niet blokkeert. Er is een handige library voor, die arduino-timer heet. Daarmee kun je meerdere ‘stopwatches’ in één schets hebben. Als je hem installeert (zie ‘Libraries installeren’), zie je de mogelijkheden in de bijbehorende voorbeeldschetsen.\n// Begintijd is het aantal milliseconden sinds het script begon. int begintijd = millis(); void setup() { pinMode(LED_BUILTIN, OUTPUT); // Het ingebouwde LEDje op de Arduino activeren } void loop() { if ((millis() - begintijd) \u0026gt; 3000) { // Zijn er al 3 seconden verstreken?  // Zo ja, doe dan dit:  // verander de LED naar aan of uit  // (het uitroepteken betekent \u0026#39;maak er van wat hij nu NIET is\u0026#39;)  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN) ); // reset de stopwatch: verander begintijd naar het aantal milliseconden NU  begintijd = millis(); } // Nu kunnen we hier andere dingen doen, zoals motortjes laten draaien, of in  // de gaten houden of knoppen worden ingedrukt, zónder te wachten op delays. } Wat je kunt meten en doen met Arduino    Inputs Outputs     Afstandssensor Licht: lampen, lasers, LEDs, EL wire, glasvezel   Accelerometer Geluid: speakers, transducers, versterkers, MP3-spelers\nEr zijn er verschillende, maar deze is goedkoop en gemakkelijk aan te sluiten: https://wiki.dfrobot.com/DFPlayer_Mini_SKU_DFR0299   Gyroscoop Motoren: servo’s, heel precieze stappenmotoren, hele snelle DCmotoren, heel sterke gear motors, trilmotors, lineaire actuatoren, ventilatoren.   Kompas Solenoids   Temperatuur Elektromagneten, ferrofluids   Relatieve luchtvochtigheid Video (animaties, video’s, VR/AR)   Vochtsensor (planten water geven!) LCD-display (zoals in snoepautomaten)   Barometer Pomp (bijv. om het te laten regenen of een beeld te laten huilen)   Lichtsensor Metaal dat van vorm verandert   Kleurensensor Warmte- en koel-elementen   Draaiknoppen en lineaire potmeters (zoals de schuiven op mengpanelen) Rookmachine   Microfoons (of andere audio-signalen) Website of sociale media (automatisch informatie posten op basis van sensorgegevens)   Aanraking    Schakelaars    Keyboard en muis    Vingerafdruk    Camera’s    Bewegingssensor    Infrarood-ontvanger (je project besturen met afstandsbediening!)    Hartslag\nSommige hartslagsensors werken amper. Deze is wat duurder, maar geeft wel redelijk goede meetresultaten: https://www.kiwi-electronics.nl/pim-438    Rook    Gas    Straling    Vlammendetector    Magneetvelden    Trilling    Buigsensor    Stroming    Hersenactiviteit     Dit is zeker geen complete lijst, maar je ziet vast zo al dat de mogelijkheden eindeloos zijn. Welke combinaties van inputs en outputs lijken jou interessant?\nLicentie Deze handleiding is geschreven door Jaap Meijers (instructeur/beheerder van het Hacklab van de Koninklijke Academie van Beeldende Kunsten in Den Haag en mentor van CoderDojo Nijmegen) en gepubliceerd in mei 2021 onder de Creative Commons Attribution 4.0 Internationallicentie. Dat betekent dat je deze handleiding vrij mag verspreiden en aanpassen, mits je de bron vermeldt en verwijst naar de licentie.\nDe broncode voor deze instructie vind je hier https://github.com/coderdojonijmegen/arduino-snelle-introductie.\nVerantwoording foto’s  Arduino met relais en lamp: Adilson Thomsen/FilipeFlop/Wikimedia Breadboard: Victoria.nunez2/Wikimedia LDR: Arnau 944/Wikimedia Potmeter: Iainf/Wikimedia Piezo buzzer: Adafruit/Flickr Ultrasone afstandssensor: Nowforever/Wikimedia Microservo: eigen foto Arduino met bloemen: madshobye/Instructables.com Diagram IR-remote bij ‘Libraries installeren’: Benne de Bakker/makerguides.com Stopwatch: Matthew/Flickr Losse onderdelen: Robin Glauser/Unsplash Diagrammen met potmeter, ultrasone afstandssensor en servo: Fritzing.org Alle screenshots van Arduino IDE, diagram bij ‘Digitale sensors’ en de foto van Arduino-bord bij ‘Wat is de Arduino’: Arduino.cc ","date":"June 27, 2021","permalink":"/instructies/arduino-snelle-introductie/","title":"Arduino - een snelle introductie"},{"categories":null,"contents":"We gaan een chat programma maken!\nBenodigdheden Voordat we aan de slag kunnen, moeten we eerst een paar dingen regelen. We hebben een checklist gemaakt van alles wat je nodig hebt, daaronder volgt per stap de uitleg.\nChecklist  De skeleton app Een tekst editor Een web browser Een web server De chat server URL De developers tools  De skeleton app Klik hier om de skeleton app te downloaden. Pak dit bestand uit naar een map, bijvoorbeeld op je bureaublad.\nDit zijn de bestanden die je nodig hebt om te beginnen: een html file, een css file en een javascript file. Elk bestand heeft z\u0026rsquo;n eigen hoofdstuk, waarin je dat bestand gaat bewerken en je eigen dingen toe voegt.\nAls je ergens een foutje maakt, kun je de bestanden altijd opnieuw uitpakken.\nEen tekst editor Als je nog geen tekst editor hebt, adviseren wij Visual Studio Code.\nDownload, installeer en open VS Code. In VS Code klik je op \u0026ldquo;Open Folder\u0026rdquo;, selecteer dan de map waar je de skeleton app hebt uitgepakt.\nAndere tekst editors zijn ook prima, als je aan iets anders gewend bent. Bijvoorbeeld: Notepad++ of Sublime Text.\nEen web browser In alle voorbeelden gebruiken wij Google Chrome. Andere browsers, zoals Firefox of Edge, zijn ook prima, mogelijk zien de app en developers tools er dan wel anders uit dan in Chrome.\nControleer ook of je de nieuwste versie hebt van de browser, om zeker te weten dat de app goed werkt.\nEen web server Om je app te zien, moet je een web server hebben die naar je map verwijst. Daarnaast zijn er een paar instellingen belangrijk.\nWij adviseren Web Server for Chrome. Installeer de web server en open de app. Je zie dan een instellingen pagina. Selecteer hier de uitgepakte map en stel de server in zoals op deze afbeelding:\nLet op: De CORS headers zijn heel belangrijk om de chat werkend te krijgen.\nDe chat server URL Als het goed is, hebben de mentoren je een link gegeven van de chat server. Dit is belangrijk om te kunnen praten met de andere ninja\u0026rsquo;s in de groep.\nZoek de volgende regel in je index.html bestand, en plak de chat server url tussen de haakjes:\n\u0026lt;script\u0026gt; var serverIpAdresEnPoort = \u0026#34;https://chat.coderdojo-nijmegen.nl\u0026#34;; \u0026lt;/script\u0026gt;  De developers tools Als het goed is, heb je nu alles om je app te bouwen. Open de link van je web server in Chrome, als het goed is zie je dan drie gekleurde balken.\nKlik met je rechter muisknop op èèn van die balken en klik op \u0026ldquo;Inspect Element\u0026rdquo;. Hiermee open je de developers tools van Chrome, waar je kan sleutelen aan alle onderdelen van de app.\nVoor de chat app is het fijn om de developers tools rechts van je scherm te zetten met deze knop, rechts van je tools. Sleep de rand van de tools dan zo, dat het ongeveer de helft van je scherm in beslag neemt.\nStructuur (HTML) Deze instructies bestaan uit drie hoofdstukken:\n Structuur (HTML) - hier gaan we de app onderdelen in elkaar zetten. Stijl (CSS) - hier gaan we veranderen hoe de onderdelen eruit zien. Scripts (Javascript) - hier gaan we veranderen hoe de app werkt.  Bij elk hoofdstuk hoort een bestand. Voor dit hoofdstuk werken we in de index.html.\nHTML: blokjes en tekst In het begin zul je nog niet alles snappen wat in de bestanden staat. Dat is okè! Laten we eerst rond kijken en dan gaan we onze eigen onderdelen toevoegen:\n Open de app en de developers tools (zie Benodigdheden). Klik op de Inspect Element knop (zie afbeelding), zodat deze blauw wordt.\n Beweeg de muis over de groene, gele en grijze balken in de app.  Je ziet de \u0026lsquo;div\u0026rsquo; elementen in de Developers Tools oplichten. Dat zijn de \u0026lsquo;blokjes\u0026rsquo; waarmee je begint. Een paar dingen moet je weten over die blokjes:\n Een blok begint met \u0026lt;div\u0026gt; en eindigt met \u0026lt;/div\u0026gt;. Met class=\u0026rdquo;\u0026quot; krijgt het blokje een class naam. De class wordt in de CSS (hoofdstuk 2) gebruikt om te bepalen hoe het eruit ziet. De class wordt ook in de Javascript (hoofdstuk 3) gebruikt om te bepalen hoe het werkt. Blokjes kunnen in elkaar en blokjes kunnen naast elkaar.  HTML tekst In de HTML kun je tekst typen. Afhankelijk van waar je die tekst typt, komt het ergens anders op het scherm (of misschien zelfs helemaal niet).\n Zoek de div blokjes op in de index.html, het zijn er vier. De \u0026lsquo;container\u0026rsquo; class zorgt ervoor dat de blokjes die er in zitten onder elkaar komen. In de container zie je drie andere divs. Kun je raden waar die voor zijn? Schrijf wat tekst, bijvoorbeeld \u0026ldquo;Hallo wereld!\u0026rdquo;, in het blokje met de class \u0026lsquo;midden\u0026rsquo;. Ververs je pagina. Staat je tekst in het middelste blokje? Zo niet, dan is er misschien iets mis gegaan. Probeer ook tekst te typen in de boven en onder blokjes. Verschijnt die tekst ook op de juiste plek in je scherm? Wat gebeurt er als je tekst typt in de container, maar buiten de boven/midden/onder blokjes? Wat gebeurt er als je tekst typt buiten de container (maar wel in de \u0026lt;body\u0026gt;)?  Chat berichten Nu dat je snapt hoe de HTML blokjes werken, kun je je eigen blokjes toe voegen.\nVoeg deze code in, in het blokje \u0026ldquo;midden\u0026rdquo;:\n\u0026lt;div class=\u0026#34;berichten\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Ververs de pagina. Als het goed is, verschijnen nu de chat berichten op je scherm! Zo makkelijk kan het zijn om onderdelen toe te voegen.\nBerichten typen We willen natuurlijk ook berichten kunnen sturen.\nVoeg deze code in, in het blokje \u0026ldquo;onder\u0026rdquo;:\n\u0026lt;div class=\u0026#34;berichtInput\u0026#34;\u0026gt;Type hier...\u0026lt;/div\u0026gt; Als het goed is, zie je \u0026ldquo;Type hier\u0026hellip;\u0026quot; op je scherm, maar als je daar klikt, kun je nog niet typen. Dat komt, omdat div daar niet voor is gemaakt. Verander het woord div in textarea, en ineens ziet het er heel anders uit:\n\u0026lt;textarea class=\u0026#34;berichtInput\u0026#34; placeholder=\u0026#34;Type hier...\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; Je kunt nu tekst typen. Als je op enter drukt, wordt je bericht verstuurd!\nMeer onderdelen Laten we nog wat meer onderdelen toevoegen. Kopieer deze blokjes en plak ze in de boven/midden/onder blokjes. Je mag zelf bepalen waar deze blokjes in je app komen en in welke volgorde. Je kan ook ons voorbeeld onderin deze pagina na maken.\nTips:\n Probeer niet alles tegelijk te doen. Plak een blokje in de index.html, sla op en ververs de pagina in chrome. Staat een blokje niet op de plek die je had verwacht? Gebruik de Inspect Element knop om te ontdekken wat er mis is gegaan! De boven/midden/onder classes heb elk hun eigen manier van blokjes plaatsen. Hier gaan we in het volgende hoofdstuk verder op in. Verander teksten en de type blokjes, je kan er vanalles van maken. Zolang de \u0026lsquo;class\u0026rsquo; klopt, zou het moeten blijven werken.  De blokjes \u0026lt;h1\u0026gt;Ninja chat\u0026lt;/h1\u0026gt; Met h1 plaats je een titel, de letters zijn dan groter en dikker. Het heeft verder geen speciale effecten, dus h1 is net als een div. Probeer ook h2 en h3 voor verschillende grooottes.\n\u0026lt;div\u0026gt;Naam: \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;naamInput\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Een input is een speciaal soort blokje, waar je iets kan typen of aanklikken. Een input hoeft niet afgesloten te worden, want er kan nooit html in een input staan. Met type=\u0026quot;text\u0026rdquo; wordt gezegd dat je tekst kan typen. De class \u0026lsquo;naamInput\u0026rsquo; is voor het invoeren van je naam. We hebben de input in een div blokje geplaatst, zodat de tekst \u0026ldquo;Naam\u0026rdquo; er mooi bij komt te staan. Verander de standaard naam in je eigen naam, omdat bij de berichten terug te zien.\n\u0026lt;div\u0026gt;Kanaal: \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;kanaalInput\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Ook dit is een input, nu met type \u0026lsquo;number\u0026rsquo;, zodat je alleen een getal kan invullen. Elk bericht hoort bij een kanaal en je kanaal is standaard \u0026lsquo;1\u0026rsquo;.\n\u0026lt;button class=\u0026#34;stuurBericht\u0026#34;\u0026gt;Stuur bericht\u0026lt;/button\u0026gt; Button is Engels voor het woord \u0026lsquo;knop\u0026rsquo;. Tot nu toe stuurde je berichten door op \u0026lsquo;enter\u0026rsquo; te drukken, nu kan het ook door op deze knop te klikken.\n\u0026lt;div class=\u0026#34;deelnemers\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Deze div is nog leeg, het doet niets totdat er op de deelnemers knop wordt gedrukt. Maar die knop heb je nog niet, dus die volgt nu:\n\u0026lt;button class=\u0026#34;bekijkDeelnemers\u0026#34;\u0026gt;Bekijk deelnemers\u0026lt;/button\u0026gt; Je krijgt dus een knop waarmee je deelnemers kan bekijken, zodra daar op wordt geklikt wordt de \u0026lsquo;deelnemers\u0026rsquo; div gevuld met de namen van de andere ninja\u0026rsquo;s en mentoren. Deze knop mag ook in de \u0026lsquo;deelnemers\u0026rsquo; div staan, zodat de namen en de knop mooi bij elkaar staan.\nHTML in berichten Wat de ninja-chat zo bijzonder maakt, is dat je HTML in je berichten kan gebruiken. Type maar eens als bericht in de chat:\n\u0026lt;h1\u0026gt;Hallo wereld!\u0026lt;h1\u0026gt; Zoals eerder gezegd, is h1 een blokje zoals de div. Maar niet elke HTML code is een eigen blokje. Je kan ook HTML gebruiken om een woord of meerdere woorden op te maken. Type dit als bericht in de chat:\nHier is woord \u0026lt;strong\u0026gt;dikgedrukt\u0026lt;/strong\u0026gt; en twee woorden \u0026lt;em\u0026gt;schuin gedrukt\u0026lt;/em\u0026gt;!\nProbeer ook andere HTML code die je hebt geleerd in je berichten. Alles mag!\nAfbeeldingen Het mooiste HTML blokje hebben we bewaard voor het laatst: je kan plaatjes zien in je app!\n\u0026lt;img src=\u0026#34;coderdojo.png\u0026#34;\u0026gt; Het plaatje is erg groot, eigenlijk te groot om mooi in de app te passen. Dit is makkelijk op te lossen door een width (= breedte) en een height (= hoogte) bij te voegen:\n\u0026lt;img src=\u0026#34;coderdojo.png\u0026#34; width=\u0026#34;32\u0026#34; height=\u0026#34;32\u0026#34;\u0026gt; Net als een input blokje, hoeft de img niet afgesloten te worden. De link voor het plaatje schrijf je in src=\u0026rdquo;\u0026quot;. We gebruiken nu de bijgesloten coderdojo.png als voorbeeld, maar het kan elk plaatje zijn wat je maar wilt.\nZo kies je je eigen plaatjes:\n Zoek op internet een plaatje dat je in de app wilt hebben. Klik met rechtermuisknop op het plaatje en selecteer \u0026ldquo;afbeeldingsadres kopiëren\u0026rdquo;. Type een nieuw img blok in je index.html en ze je cursor in de aanhalingstekens van de src. Gebruik rechtermuisknop en klik op plakken, of type CTRL-V om te plakken. Sla op en bekijk je plaatje in de app.  Tip: Op deze manier kun je ook plaatjes in je chat berichten plaatsen.\nStijl (CSS) Je weet nu hoe je HTML blokjes kan plaatsen en je weet hoe je die een class naam kan geven. Die class namen gaan we nu gebruiken om ze te stylen: je kan helemaal veranderen hoe ze eruit zien!\nVoor dit hoofdstuk werk je voornamelijk in het bestand basic-chat.css.\nKleuren en lettertypes Laten we eerst kleuren aanpassen:\n Zoek het div blokje \u0026lsquo;midden\u0026rsquo; in de Developers Tools, gebruik eventueel Inspect Element op de gele achtergrond. Rechts zie je een tabblad \u0026ldquo;Styles\u0026rdquo;, hier staan alle CSS regels voor dit blokje. Schrik niet, het zijn er veel! Zoek de regel background-color: lightyellow (TODO: screenshot met een pijl ofzo). Klik op het woord lightyellow en druk op backspace. De browser toont al een lijst van kleuren, klik of type cadetblue. Zie hoe de kleur van het midden blok is veranderd! Verander van andere blokjes ook de background-color. Probeer verschillende kleuren uit.  De kleuren die je nu in stelt worden nog niet opgeslagen. De volgende keer dat je refresht is alles weer terug naar hoe het was.\nStyling opslaan Dit is hoe je je kleuren kan opslaan:\n Noteer of kopieer de naam van de kleur die je wilt opslaan. Je kunt ook een kleur kiezen op deze website: csscolornames.com Open de basic-chat.css. Zoek de regel .midden {, hier staan de stijl regels voor het midden blok. Verander de background-color in een kleur naar keuze en sla het bestand op. Refresh je browser en zie de kleur die je hebt gekozen in het midden blok.  Op deze manier kun je alle achtergrond kleuren instellen die je wilt. Zoek de andere onderdelen van je app op in het CSS bestand en geef ze een kleur die je leuk vindt.\nTekst Je kunt ook teksten er anders uit laten zien. Voeg deze regels eens toe, bijvoorbeeld bij .bericht:\ncolor: yellow; font-family: \u0026#39;Indie Flower\u0026#39;, cursive; color verandert de kleur van de tekst. Je kunt dezelfde kleuren gebruiken als voor background-color.\nfont-family verandert het lettertype. Kun je ontdekken welk lettertype nog meer wordt gebruikt in de app?\nProbeer deze kleuren eens na te maken. Tip: Geef de titel een nieuwe class naam en gebruik die class naam om in de CSS het lettertype in te stellen.\nVormen en randen Alles op het scherm kunnen we groter of kleiner maken. Probeer dit eens uit:\n Klik op één van de berichten, met Inspect Element. Bij de styles zie je onder andere padding, border en margin. Verander de getallen één voor één en kijk wat er gebeurt: maak ze 40px, of 1px, of 0. Je ziet ook border-radius, verander daarvan ook het getal. Verander de kleur van \u0026lsquo;border\u0026rsquo; (border is Engels voor \u0026lsquo;rand\u0026rsquo;). Verander bij de border het woord \u0026lsquo;solid\u0026rsquo; in \u0026lsquo;dotted\u0026rsquo; en kijk wat er gebeurt.  Het is makkelijker om te zien wat het doet, dan om het uit te leggen. In het kort:\n 10px betekent 10 pixels. Een pixels is een punt op je scherm. border is de rand van een blokje. Het is een lijn of stippels, heeft een kleur en een dikte. padding is hoeveel ruimte er IN het blokje is, voordat de tekst begint. margin is hoeveel ruimte er OM het blokje heen is. border-radius is om te rand rond te maken.  Tip: Probeer eens een blokje helemaal rond te maken met border-radius.\nMeer CSS Met CSS kun je van elk blokje zeggen hoe het eruit moet zien. Als je het leuk vindt, kun je in de basic-chat.css nog andere blokjes aanpassen met de border en padding enzo. Je kunt ook kijken welke CSS opdrachten er nog meer in staan. We hebben zoveel mogelijk in het bestand beschreven wat we doen, als je twijfelt kun je altijd nog op internet zoeken. Succes!\nStyling in berichten Je kunt ook CSS in je berichten gebruiken! Schrijf bijvoorbeeld eens:\nHier is een stukje tekst \u0026lt;span style=\u0026#34;color:blue;\u0026#34;\u0026gt;blauw\u0026lt;/span\u0026gt; Met style=\u0026rdquo;\u0026quot; kun je CSS in een HTML blokje stoppen. Dat werkt dan alleen voor dat ene blokje, maar dat is perfect voor in berichten. Probeer ook eens de andere CSS commando\u0026rsquo;s die je hebt geleerd, zoals border en font-family.\nTip: als je meerdere CSS commando\u0026rsquo;s in één blokje wilt, zet je er een ; tussen. Bijvoorbeeld:\n\u0026lt;span style=\u0026#34;color:white;background-color:black\u0026#34;\u0026gt;Dit bericht is zwart/wit.\u0026lt;/span\u0026gt; Scripts (JavaScript) Nu dat je een complete app hebt en zelf heb bepaald hoe het eruit ziet, gaan we een kijkje onder de motorkap nemen: hoe worden de berichten verstuurd en ontvangen?\nVoor dit hoofdstuk werk je in het bestand basic-chat.js.\nJavascript: de basis Javascript is de programmeertaal van het web. Alle HTML blokjes die je nu in je app hebt, kun je met Javascript aan sturen. Je kunt ook berichten sturen naar de server en ontvangen van de server. Daar gaan we mee aan de slag.\n Klik bovenin de Developers Tools op het tabblad \u0026ldquo;Console\u0026rdquo;. Je ziet een groot vlak en misschien een paar berichten. Onder de berichten, zie je een blauwe \u0026gt;, klik daar naast zodat je kan typen. Type de onderstaande berichten. Druk na elk bericht op enter en zie wat er gebeurt:  console.log(\u0026#34;Hallo console!\u0026#34;) socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo websocket!\u0026#34;)  Je hebt nu een berichtje in de console én je hebt een berichtje via de chat verstuurd! Allebei kunnen ze heel handig zijn! Laten we zien wat we nog meer kunnen met Javascript.\nAls je iets wilt weten van je app, kun je een commando geven dat iets terug geeft om te onthouden. Type eens:\n$(\u0026#34;.naamInput\u0026#34;).val()  Je ziet je naam nu terug in de console! Deze commando ziet er misschien gek uit, dit is wat er gebeurt:\n $(\u0026quot;.naamInput\u0026rdquo;) zoekt de blokjes op met de class \u0026lsquo;naamInput\u0026rsquo;. .val() vraagt om de tekst die staat ingevuld bij het eerst gevonden blokje.  Kun je op die manier ook het kanaal op vragen? Of een bericht in de chat?\nVariabelen Met variabelen (var) kan de browser dingen onthouden:\nvar naam = $(\u0026#34;.naamInput\u0026#34;).val() socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo, mijn naam is \u0026#34; + naam)  Je hebt nu een bericht verstuurd met je naam er in! Kun je hetzelfde doen met je kanaal?\nBerekeningen Computers zijn ook heel goed in rekenen. Het woord computer is zelfs Engels voor \u0026ldquo;berekenaar\u0026rdquo;! Type het volgende maar eens om uit te proberen:\nvar kanaal = $(\u0026#34;.kanaalInput\u0026#34;).val() kanaal + 2  Dit gaat nog niet goed: het getal 2 is achter het kanaal nummer geplaatst. Dat komt omdat javascript niet gelijk snapt dat het een getal is:\nparseInt(kanaal) + 2  Nu zie je je kanaal, met twee erbij opgeteld. Om de oefening af te maken, laten we de server vertellen dat we een nieuw kanaal willen:\nsocket.emit(\u0026#34;zetKanaal\u0026#34;, parseInt(kanaal) + 2)  Functies en parameters Je hebt al verschillende commando\u0026rsquo;s aangeroepen, zoals socket.emit en parseInt, maar je kan ook je eigen commando\u0026rsquo;s maken. Dat noemen we functions. Type dit eens in je console:\nfunction hallo(naam) { socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo \u0026#34; + naam + \u0026#34;!\u0026#34;) }  Er gebeurt nog niets. Dat komt omdat je de function eerst moet aanroepen, voordat er iets gebeurt:\nhallo(\u0026#34;ninjas\u0026#34;) hallo(\u0026#34;ikzelf\u0026#34;) hallo(\u0026#34;javascript\u0026#34;)  Je kan de functie zo vaak aanroepen als je maar wilt.\nJe eigen bot Je weet nu al veel over hoe je commando\u0026rsquo;s geeft en maakt in Javascript. Met functions kun je ook reageren op dingen die gebeuren. Zo kun je een function schrijven die reageert op berichten in de chat:\nfunction hoiDoei(bericht) { if (bericht.tekst == \u0026#34;hoi\u0026#34;) { socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;doei\u0026#34;) } }  Het woord if is Engels voor \u0026lsquo;als\u0026rsquo;. Er staat dus: als het bericht \u0026ldquo;hoi\u0026rdquo; is, zeg dan \u0026ldquo;doei\u0026rdquo;. Maar hoe ontvangen we berichten?\nsocket.on(\u0026#34;krijgBericht\u0026#34;, hoiDoei)  Elke keer als er een bericht binnen komt, wordt de commando hoiDoei aangeroepen. Type maar eens het woord \u0026ldquo;hoi\u0026rdquo; in de chat!\nNog veel meer Met HTML, CSS en Javascript kun je hele programma\u0026rsquo;s bouwen, zoals je ziet. Er valt nog ontzettend veel te leren! De eerst volgende stap is om de basic-chat.js te lezen en je kan dat bestand ook aanpassen, om andere dingen te doen: automatisch van kanaal wisselen bij een bericht, je naam veranderen via een bericht, enzovoorts. Je kunt ook altijd op internet zoeken naar wat je nog meer kan met HTML, CSS en Javascript, de website https://www.w3schools.com/ is een leuke plek om te beginnen. Heel veel plezier en heel veel succes!\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"May 24, 2021","permalink":"/instructies/javascript-ninja-chat/","title":"Javascript - Ninja-Chat"},{"categories":null,"contents":"We gaan programmeren met PHP.\nIntroductie De meestgebruikte programmeertaal voor websites is PHP. Het is een heel handige taal waarmee je een eigen slimme website kunt bouwen.\nJe gaat nu leren hoe PHP werkt, en dat doe je door een online vriendenboek te maken. Je leert informatie op te slaan, hoe je uitrekend hoeveel dagen oud je vrienden zijn, en hoe je een plaatje maakt met hun lievelingskleur.\nBenodigdheden Als je websites wil bouwen met PHP, heb je een plek nodig waar je software kunt schrijven. We gebruiken nu CodeAnywhere. Daar kun je oefenen met PHP, en zie je ook meteen hoe het resultaat eruitziet.\nAls je je niet eerder hebt aangemeld, ga dan naar https://codeanywhere.com/signup. Vul je mailadres in, een wachtwoord, kruis het hokje aan, en klik op \u0026lsquo;register\u0026rsquo;. Open het mailtje dat CodeAnywhere je gestuurd heeft om op de link te klikken. Ga door naar de editor: https://codeanywhere.com/editor.\nIn het scherm dat je daar ziet, vul je eerst je naam in. Bij \u0026lsquo;Search stack\u0026rsquo; vul je PHP7 in, en dan klik je op PHP 7 in de lijst daaronder. Klik onderaan op \u0026lsquo;create\u0026rsquo; en wacht af.\nStappen Je eerste webpagina Als het goed is, zie je nu een omgeving waarin je kunt beginnen aan het maken van je eigen website.\nMaak de eerste pagina aan door in het menu bovenaan te klikken op File, en dan \u0026lsquo;New File\u0026rsquo;. Nu kun je in het grote zwarte vlak in het midden beginnen met je eerste webpagina.\nEen webpagina ziet er in het begin altijd zo uit als hieronder. Kopiëer en plak dit voorbeeld in het zwarte vlak:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welkom\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In het blokje \u0026lsquo;head\u0026rsquo; staat informatie over je site, zoals de titel. In het blok daaronder, de body, staat alles dat te zien is op de pagina, zoals de kop, tekst en plaatjes.\nDeze indeling met \u0026lt;\u0026gt;-tekens noemen we HTML. Dat is de taal waarmee je opgeeft wat waar op de pagina komt te staan en hoe het eruit ziet.\n\u0026lt;h1\u0026gt; is bijvoorbeeld een HTML-code waarmee je opgeeft dat het een dikgedrukte kop bovenaan de tekst is.\nBewaar je pagina door in het File-menu op \u0026lsquo;Save\u0026rsquo; te klikken. Klik in het venster dat je dan ziet op \u0026lsquo;file name\u0026rsquo; en vul daar in: index.php Klik daaronder op je naam en dan onderaan het venster op \u0026lsquo;Save\u0026rsquo;.\nNu kun je je webpagina bekijken. Klik op de \u0026lsquo;play\u0026rsquo;-knop bovenaan:\nPHP mee laten doen Je website is nu nog heel eenvoudig - en niet zo slim. Hij laat alleen zien wat jij hebt ingetypt.\nJe kunt je webpagina er ook steeds anders uit laten zien, door PHP te gebruiken. De programmacodes van PHP kun je gewoon tussen de HTML-code zetten.\nVoeg deze regel toe aan je webpagina, direct onder de regel met :\n\u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hallo wereld\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;  Zo dus:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welkom\u0026lt;/h1\u0026gt; \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hallo wereld\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Je laat weten waar de PHP-code begint met .  is HTML en geeft aan waar een nieuwe alinea begint. Zoals de meeste codes in HTML sluit je die ook weer af, met . En klik weer op \u0026lsquo;play\u0026rsquo;.\nHet enige dat je PHP nu laat doen, is iets laten zien in de browser (het programma waarmee je de website bekijkt). Gelukkig kun je met PHP nog veel slimmere dingen maken, en dat gaan we nu doen.\nWebsites slimmer maken Eén van de manieren waarop je een webpagina wat slimmer kunt maken, is door PHP een beetje te laten meedenken.\nJe kunt bijvoorbeeld steeds iets anders laten zien op basis van het adres (de url) dat een bezoeker intypt om bij jouw webpagina te komen.\nVerander de PHP-regel uit het vorige voorbeeld zodat dit er komt te staan:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;?php echo \u0026#39;Hallo \u0026#39; . $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#39;!\u0026#39;; ?\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Let erop dat je ook de -codes uit het vorige voorbeeld weghaalt. Let ook op dat de H1-kop pas afsluit ná de PHP-code. De PHP code moet dus tussen  en  staan.\nPHP zegt nu met het commando echo \u0026lsquo;Hallo\u0026rsquo; tegen een naam die in het webadres van je pagina wordt genoemd. We laten dat zo zien.\nSla je pagina op (via File en Save) en druk weer op \u0026lsquo;play\u0026rsquo;.\nJe ziet nu dat de kop van de pagina is veranderd in \u0026lsquo;Hallo !\u0026rsquo;. Meer niet, want we hebben nog geen naam genoemd in het webadres.\nTik in de adresbalk achter het adres van je site ?naam= en dan je naam. Het zou er ongeveer zo uit moeten zien:\nhttp://jaap-jaap433627.codeanyapp.com/?naam=Steven\nof zo:\nhttp://jaap-jaap433627.codeanyapp.com/index.php?naam=Steven\nDruk op enter om de pagina opnieuw te laden. Probeer het daarna nog een paar keer met een andere naam in het adres.\nFormulieren Wat je nu zou kunnen doen, is een persoonlijke pagina maken voor elk van je vrienden en familieleden. Door een formulier op die pagina te zetten, kunnen zij meer informatie over zichzelf invullen. Zo maak je je eigen online vriendenboek.\nMaak dit formulier:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;?php echo \u0026#39;Hallo \u0026#39; . $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#39;!\u0026#39;; ?\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;resultaten.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt; Je voornaam: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;naam\u0026#34; value=\u0026#34;\u0026lt;?php echo $_REQUEST[\u0026#34;naam\u0026#34;]; ?\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Hoe oud ben je? \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;leeftijd\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Opsturen\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Vul hier je eigen naam in. [bij de titel]\n[als we de naam al weten, dan vult PHP die hier alvast in]\nVoeg zelf nog twee vragen toe voor het vriendenboek: hoe lang ze zijn (in centimeters) en nog iets, zoals bijvoorbeeld wat hun favoriete film is. Let erop dat je elk input-veld een unieke \u0026lsquo;name\u0026rsquo; geeft, dus bijvoorbeeld \u0026lsquo;name=\u0026quot;lengte\u0026rdquo;\u0026rsquo;.\nResultaten van het formulier In de code kun je zien dat het formulier de ingevulde informatie doorgeeft aan een andere pagina die resultaten.php heet. Die pagina gaan we nu aanmaken.\nGa bij CodeAnywhere naar File en klik op \u0026lsquo;New file\u0026rsquo;.\nMaak een pagina die ongeveer lijkt op die hieronder. Denk eraan dat je het antwoord op je zelfbedachte vraag ook nog moet opvangen.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Resultaten\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Hoi \u0026lt;?=$_REQUEST[\u0026#34;naam\u0026#34;]?\u0026gt;, je bent dus \u0026lt;?=$_REQUEST[\u0026#34;leeftijd\u0026#34;]?\u0026gt; jaar oud en \u0026lt;?=$_REQUEST[\u0026#34;lengte\u0026#34;]?\u0026gt; centimeter lang.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [dit is een iets andere manier om PHP even snel iets in te laten vullen]\nSla je nieuwe pagina op (File, en dan Save) en vul bij \u0026lsquo;file name\u0026rsquo; in resultaten.php Klik daaronder op je naam en klik onderaan op Save. Klik weer op \u0026lsquo;play\u0026rsquo;. Rekenen met PHP De informatie die iemand invult, wordt door PHP opgeslagen in variabelen. Variabel betekent dat iets steeds anders kan zijn. In dit geval kan de variabele \u0026lsquo;leeftijd\u0026rsquo; 4 zijn of 12, maar ook 125 of zelfs een woord zoals \u0026lsquo;slagroomtaart\u0026rsquo;.\nJe kunt ook rekenen met die variabelen.\nDus stel dat iemand heeft ingevuld dat ze 12 is, dan kunnen we uitrekenen wat haar geboortejaar is.\nVoeg deze regels toe aan resultaten.php:\n\u0026lt;?php $leeftijd = $_REQUEST[\u0026#34;leeftijd\u0026#34;]; $jaar = 2018; echo \u0026#34;\u0026lt;p\u0026gt;Dat betekent dat je geboren bent in \u0026#34;; echo $jaar - $leeftijd; echo \u0026#34;.\u0026lt;/p\u0026gt;\u0026#34;; ?\u0026gt;  En bekijken het resultaat door deze pagina op te slaan en je eerste pagina weer te starten.\nVoeg nu zelf de code toe om met PHP te laten zien hoeveel centimeter deze vriend of vriendin langer of korter is dan jij bent. Informatie bewaren: cookies Informatie verzamelen met formuleren en die gegevens opslaan in variabelen is leuk, maar het probleem is dat die informatie weg is als je de browser sluit of naar een andere website gaat. Je bezoeker zal dus elke keer dat hij of zij terugkomt opnieuw het formulier moeten invullen.\nWe kunnen dat voorkomen door de informatie op te slaan in cookies (het Engelse woord voor koekjes).\nZet deze code bovenaan in resultaten.php:\n\u0026lt;?php $_COOKIE[\u0026#39;bezoek\u0026#39;]++; setcookie(\u0026#39;bezoek\u0026#39;, $_COOKIE[\u0026#39;bezoek\u0026#39;]); ?\u0026gt;  Het werkt alleen als je deze code vóór  zet, dus dat er niks voor de code naar de browser wordt gestuurd om te laten zien. Zet nu deze regel onderaan de pagina, net boven : \u0026lt;small\u0026gt; Je hebt deze pagina nu \u0026lt;?=$_COOKIE[\u0026#39;bezoek\u0026#39;]?\u0026gt; keer bekeken. \u0026lt;/small\u0026gt; \n[de -code maakt de tekst iets kleiner dan de rest]\nVernieuw de pagina een paar keer en je zult zien dat de informatie uit de cookie steeds opnieuw wordt bijgewerkt en onthouden.\nZoals het er nu staat, wordt de cookie ook weer weggegooid als de bezoeker de browser afsluit. Als je wil dat hij of zij de informatie nog wat langer zal kunnen zien, dan moet je de cookie zo opslaan: setcookie(\u0026#39;bezoek\u0026#39;, $_COOKIE[\u0026#39;bezoek\u0026#39;], time() + 600000); \nOp die manier blijft de informatie bewaard tot 600.000 seconden na nu, oftewel een week.\nInformatie bewaren: tekstbestandjes Als we echt een vriendenboek willen maken, dan moet de site informatie kunnen opslaan, zodat jij de informatie van je vrienden ook kunt lezen.\nProgrammeurs die websites bouwen, gebruiken meestal een database om informatie te bewaren, maar je kunt daar ook een simpel tekstbestandje voor gebruiken.\nDat werkt als volgt. In resultaten.php, onder de regel met setcookie, zetten we de antwoorden uit het formulier achter elkaar en zetten we die in een tekstbestandje:\n$tekstbestandje = \u0026#39;/tmp/vrienden.txt\u0026#39;; $antwoorden = $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#34;;\u0026#34; . $_REQUEST[\u0026#34;leeftijd\u0026#34;] . \u0026#34;;\u0026#34; . $_REQUEST[\u0026#34;lengte\u0026#34;] . \u0026#34;\\n\u0026#34;; file_put_contents($tekstbestandje, $antwoorden, FILE_APPEND);  [Met de punt (.) plakken we in PHP variabelen en tekst aan elkaar. De \\n op het eind zorgt ervoor dat er na deze rij een nieuwe regel komt.]\n[FILE_APPEND zorgt ervoor dat we steeds een nieuwe regel toevoegen aan het tekstbestandje, in plaats van dat de antwoorden het enige zijn dat erin komt te staan]\nVoeg je eigen variabelen toe aan $antwoorden (die van de extra vragen die je in het formulier hebt gezet). Zorg er wel voor dat er steeds weer een puntkomma tussen komt te staan, want zo houden we de variabelen uit elkaar.\nTekstbestand lezen Nu gaan we een pagina maken waar je ziet wie jouw vragenlijst hebben ingevuld.\nGa bij CodeAnywhere naar File en klik op \u0026lsquo;New file\u0026rsquo;. Zet deze code erin om het tekstbestand te lezen en te laten zien wat erin staat:\n\u0026lt;html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Vrienden\u0026lt;/h1\u0026gt; \u0026lt;?php $tekstbestand = fopen(\u0026#34;/tmp/vrienden.txt\u0026#34;, \u0026#34;r\u0026#34;); while( ! feof($tekstbestand) ) { $vriend = explode(\u0026#34;;\u0026#34;, fgets($tekstbestand)); echo $vriend[0] . \u0026#34; is \u0026#34; . $vriend[1] . \u0026#34; jaar en $vriend[2] cm lang.\u0026lt;br\u0026gt;\u0026#34;; } fclose($tekstbestand); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  [Het uitroepteken betekent \u0026lsquo;niet\u0026rsquo;, feof betekent \u0026lsquo;het eind van het bestand\u0026rsquo; en fgets betekent \u0026lsquo;haal een nieuwe regel van het bestand op\u0026rsquo;. Hier staat dus: laat een nieuwe regel zien zolang we nog niet onderaan het tekstbestand zijn.]\n[Met \u0026lsquo;explode\u0026rsquo; hakken we de regel in stukjes. Waar een puntkomma staat begint een nieuwe variabele. $vriend wordt zo een lijst en dat noemen we in PHP een array. De lijst is genummerd en begint bij 0, en daarom vinden we de naam met $vriend[0]. ]\nSla je nieuwe pagina op (File, en dan Save) en vul bij \u0026lsquo;file name\u0026rsquo; in vrienden.php Klik daaronder op je naam en klik onderaan op Save. Klik weer op \u0026lsquo;play\u0026rsquo;.\nGa naar je nieuwste pagina door achter het webadres /vrienden.php te zetten en op enter te drukken.\nHet adres zou er ongeveer zo uit moeten zien:\nhttp://jaap-jaap433627.codeanyapp.com/vrienden.php\nAls je ziet wat je zelf daarstraks hebt ingevuld in het formulier, dan werkt het! Ga terug naar de eerste pagina om het formulier nog een paar keer in te vullen, om alles te testen.\nJaren en dagen Dit deel is nog niet af :(\n[Aantal dagen uitrekenen tot je verjaardag, hoeveel dagen je al leeft, hoeveel Saturnus-jaren je al bent, hoeveel dagen je ouder of jonger bent dan je vriend. \u0026gt; formulier aanpassen zodat we ook de dag van de maand en de maand hebben voor de geboortedatum \u0026gt; Datetime-object maken \u0026gt; link naar info over rekenen met data (zodat we ook leren hoe je documentatie over functies kunt vinden op PHP.org) ]  Hyperlinks Dit deel is nog niet af :(\n[unordered list maken met voor elke vriend een aparte link naar een nieuw bestand, waar we alle info laten zien over die vriend op basis van de meegegeven naam-parameter. Op die pagina moeten we dus met while en if bekijken welke regel van het bestand we moeten gebruiken.]  Plaatjes maken met PHP Dit deel is nog niet af :(\n[plaatje met lievelingskleur genereren \u0026gt; formulier aanpassen zodat we ook de lievelingskleur weten \u0026gt;  To do:  een mail sturen sturen met iemands eigen url (zou je ook kunnen doen als iemand jarig is of een nieuwe entry wordt gedaan) mensen in laten loggen met een wachtwoord tekst aanpassen aan of het ochtend of middag is  Vervolg Meer informatie:\n https://stackoverflow.com/questions/441087/php-exercises https://www.phphulp.nl/php/tutorial/overig/php-beginners-handleiding/575/variabelen/1482/ https://www.phphulp.nl/php/tutorials/php-functies/6/ https://www.w3resource.com/php-exercises/php-basic-exercises.php  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"November 18, 2020","permalink":"/instructies/web-development-php/","title":"Web - Development - Php"},{"categories":null,"contents":"Er zijn een paar verschillende talen die samen voor een belangrijk deel bepalen wat er op websites staat (HTML), hoe ze eruit zien (CSS) en hoe ze werken (JavaScript).\nIntroductie Deze instructies leggen eerst de basisonderdelen van HTML uit, en gaan daarna in op CSS en JavaScript. Afhankelijk je ervaring met deze talen kun je het best bij het begin starten, of ervoor kiezen dit over te slaan. De instructies bestaan uit een deel uitleg met tussendoor opdrachten om te oefenen met alle onderdelen.\nBenodigdheden Voor deze instructies gebruiken we Visual Studio Code (VS Code) om de code te schrijven, en om het resultaat te bekijken. Download en installeer eerst VS Code: Download Visual Studio Code\n Ga nu naar het Extensions menu. Zoek naar de extensie HTML Preview. Installeer de extensie en herstart VS Code.  Om een html-pagina te laten zien in VS Code moet je op het preview icoon klikken, dit bevindt zich rechtsboven in het scherm (let op: het is alleen zichtbaar als je een bestand van het soort .html open hebt, niet bij bijvoorbeeld een .txt bestand):\nJe bent nu klaar om te beginnen met de instructies!\nOnderdelen van een HTML-pagina (basis) Structuur van een pagina Websites worden geschreven in de taal van het internet: HTML. Er zijn veel verschillende \u0026ldquo;woorden\u0026rdquo;, of \u0026ldquo;bouwblokken\u0026rdquo;, in HTML. Een aantal van de meest gebruikte leer je hier kennen.\nEen HTML-pagina heeft een paar standaard onderdelen:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Dit is een kop\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Dit is een alinea.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  HTML onderdelen worden aangegeven met tags: de naam van het onderdeel tussen \u0026lt;\u0026gt; haakjes. De meeste onderdelen hebben een start en een eind tag. De eind tag heeft een forward slash dus / voor de naam, bijvoorbeeld \u0026lt;/html\u0026gt;. Tags worden altijd geschreven met kleine letters.  Opdracht Kopieer en plak de basisonderdelen in een nieuw bestand en sla dit op als html-bestand (bijvoorbeeld ninja.html). Let op: pas nadat je het bestand hebt opgeslagen krijgt de tekst ook verschillende kleuren. Als je deze kleuren niet ziet kan het zijn dat je het bestand als tekst, dus eindigend op .txt hebt opgeslagen. Zet nu ook de preview aan. Het resultaat zou er ongeveer zo uit moeten zien:\nDit is een kop Dit is een alinea.\n De standaard onderdelen  \u0026lt;html\u0026gt;: dit is het hoofdonderdeel van een pagina. Alle andere onderdelen komen binnen de \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;head\u0026gt;: binnen dit onderdeel wordt informatie over de pagina gezet, bijvoorbeeld de titel. \u0026lt;body\u0026gt;: binnen dit onderdeel staat alle tekst die zichtbaar is op de pagina, in het voorbeeld een kop \u0026lt;h1\u0026gt; en een alinea \u0026lt;p\u0026gt;.  Opdracht Voeg eens een alinea met als tekst je naam in de \u0026lt;body\u0026gt; van de pagina toe. Zie je je naam verschijnen?\nKoppen Om verschillende niveau\u0026rsquo;s aan te geven op een pagina kun je koppen gebruiken. Hiervoor zijn de \u0026lt;h1\u0026gt;, \u0026lt;h2\u0026gt;, \u0026lt;h3\u0026gt; (enzovoort) tags. Met deze tags kun je je pagina een duidelijke indeling geven, zoals je kunt zien in het voorbeeld hierboven.\nOpdracht Tot hoe ver gaan de niveau\u0026rsquo;s eigenlijk? Bestaat \u0026lt;h20\u0026gt;?\nOpdracht Maak een pagina die er zo uitziet:\nHeelal Melkwegstelsel Zonnestelsel Aarde  De stijl van tekst Je kunt op een aantal manieren tekst extra benadrukken: door woorden dik te maken, of schuin. Hiervoor kun je bijvoorbeeld de tags \u0026lt;b\u0026gt; (voor dik) en \u0026lt;i\u0026gt; (voor schuin) gebruiken. Een aantal andere tags om extra effect aan je tekst te geven zijn \u0026lt;mark\u0026gt; en \u0026lt;del\u0026gt;. De HTML-code\nDit is \u0026lt;b\u0026gt;dik\u0026lt;/b\u0026gt; wordt dus\nDit is dik  Opdracht Gebruik de onderdelen die hierboven genoemd zijn eens uit en maak deze zin na (zet deze bijvoorbeeld onder de kop Aarde):\nDe dikke gele bij vloog schuin over mijn kop hoofd.  Links Een superbelangrijk onderdeel van webpagina\u0026rsquo;s zijn natuurlijk links die verwijzen naar andere pagina\u0026rsquo;s, op dezelfde site of op een andere. Denk maar eens aan zoekmachines! Voor het maken van een link gebruik je de \u0026lt;a\u0026gt; tag. Het adres van de link, dus waar deze naar verwijst, voeg je toe door het attribuut href in de tag te zetten met als waarde het adres, op deze manier:\n\u0026lt;a href=\u0026#34;https://scratch.mit.edu\u0026#34;\u0026gt;Klik hier!\u0026lt;/a\u0026gt; Opdracht Probeer op deze manier maar eens een link naar je favoriete website te maken. Let op: vergeet niet de aanhalingstekens om het adres van de website.\nZie je de link niet? Dat komt omdat je nog niets hebt toegevoegd om op te klikken! Dit komt tussen de start- en eindtag en mag tekst zijn, maar ook bijvoorbeeld een afbeelding.\nOpdracht Maak op de pagina een link naar je favoriete website met de tekst \u0026ldquo;Mijn favoriete website!\u0026rdquo; (let op: de tekst is dik gedrukt, hoe moest dat ook weer?). Werkt de link? Tip: zet in de link https:// voor de naam van de website.\nPlaatjes Met alleen maar tekst zouden veel websites er maar saai uit zien. Plaatjes kun je toevoegen aan je pagina met de \u0026lt;img\u0026gt; tag. Ook hier heb je weer een attribuut nodig, dat heet src (van source, Engels voor bron):\n\u0026lt;img src=\u0026#34;naam-van-het-plaatje.png\u0026#34;\u0026gt; Opdracht: Pas de link van de vorige opdracht zo aan dat je het CoderDojo logo hieronder gebruikt in plaats van de tekst die er staat. Download Hiervoor het plaatje en sla het op in de map waar ook je html-pagina staat. Werkt de link nu ook weer? Let op: je moet de hele naam van het plaatje gebruiken, in dit geval is het een png-bestand.\nStijl toevoegen met CSS (basis) Zonder stijl heeft tekst op een webpagina een standaardkleur (zwarte letters op een witte achtergrond), standaardgrootte en standaardlettertype. Je kunt eindeloos variëren met stijl, en er zijn verschillende manieren om stijl toe te voegen aan je HTML.\nDe opdrachten in deze instructie beginnen met deze HTML-code:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; Dit is de best gestijlde regel HTML ooit! \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Hoewel, misschien is deze nog wel mooier... \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dit zou er in de preview zo uit moeten zien:\n Dit is de best gestijlde regel HTML ooit!  Hoewel, misschien is deze nog wel mooier...  Stijl toevoegen De makkelijkste manier om stijl toe te voegen aan je HTML is door een style attribuut toe te voegen aan een HTML-element, bijvoorbeeld:\n\u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;Wat zou de kleur van deze tekst zijn?\u0026lt;/p\u0026gt; In dit voorbeeld is color de eigenschap die je wilt instellen, namelijk de kleur van de tekst. De waarde die je de tekst geeft is hier red, dus rood.\nSpelen met kleur De kleur van tekst bepaal je met de eigenschap color: \u0026lt;p style=\u0026quot;color:green\u0026quot;\u0026gt;. Kleuren instellen kan op verschillende manieren, bekijk hiervoor het onderdeel :ref:html-kleuren.\nOpdracht Maak de tekst van de eerste alinea groen, en die van de tweede paars:\nDit is de best gestijlde regel HTML ooit!\nHoewel, misschien is deze nog wel mooier...\n Je kunt niet alleen de kleur van de tekst zelf, maar ook de achtergrond veranderen, dit doe je met de eigenschap background-color: \u0026lt;p style=\u0026quot;background-color:....\u0026quot;\u0026gt;.\nOpdracht Maak de tekst van de eerste alinea rood met een zwarte achtergrond, en die van de wit met een oranje achtergrond:\nDit is de best gestijlde regel HTML ooit!\nHoewel, misschien is deze nog wel mooier...\n Tekstgrootte aanpassen Eén manier om letters van verschillende grootte te maken is door :ref:koppen te gebruiken. Dat is niet altijd handig (waarom is nu niet belangrijk) en het kan ook met de eigenschap font-size. Een voorbeeld:\n\u0026lt;p style=\u0026#34;font-size:25px\u0026#34;\u0026gt;Groot!\u0026lt;/p\u0026gt; geeft dit resultaat\nGroot!\n In dit voorbeeld is px gebruikt om aan te geven hoe groot de tekst moet zijn, dit is de grootte in pixels op het scherm. Je kunt ook procenten gebruiken, waarbij 100% de \u0026ldquo;standaard\u0026rdquo; grootte is: \u0026lt;p style=\u0026quot;font-size:100%\u0026quot;\u0026gt;.\nOpdracht Maak de eerste zin van je pagina zo groot dat ie nog net op één regel past, en de tweede zo klein dat je \u0026rsquo;m nog nét kunt lezen.\nVerschillende soorten letters gebruiken Naast de kleur en de grootte kun je ook nog het soort letters veranderen. Dit doe je met de eigenschap font-family: \u0026lt;style=\u0026quot;font-family:naam,backup-naam\u0026quot;\u0026gt;\nJe ziet dat er naam en backup-naam als waarde staat ingevuld. De soort letter backup-naam is niet verplicht, maar wordt gebruikt als de computer de soort letter naam niet kent. Een voorbeeld:\n\u0026lt;p style=\u0026#34;font-family:broadway,serif\u0026#34;\u0026gt;Broadway is niet zo goed te lezen.\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-family:verdana,sans-serif\u0026#34;\u0026gt;Verdana een stuk beter.\u0026lt;/p\u0026gt; geeft dit resultaat\nBroadway is niet zo goed te lezen.\nVerdana een stuk beter.\n Stijlen combineren Je kun meer dan één eigenschap tegelijk instellen door ze met een punt-komma achter elkaar te zetten, bijvoorbeeld: \u0026lt;p style=\u0026quot;color:red;font-size:20px\u0026quot;\u0026gt;\nOpdracht Combineer nu in de twee zinnen verschillende kleuren, lettergroottes en soorten letters. Leef je uit!\nToegankelijkheid Je hebt nu gezien dat je tekst op je webpagina er op heel veel verschillende manieren kunt laten uitzien. Dat het kán betekent natuurlijk nog niet dat het ook móét! Om te zorgen dat websites ook voor mensen die bijvoorbeeld minder goed zien te gebruiken zijn is het belangrijk (en voor sommige websites verplicht!) om bijvoorbeeld\n de letters groot genoeg te maken de kleur van de letters en die van de achtergrond verschillend genoeg te maken genoeg ruimte tussen regels tekst te laten.  Actie toevoegen met JavaScript (basis) De HTML die je net hebt geleerd is statisch. Om hier acties aan toe te voegen, zoals het klikken van een knop gebruiken we JavaScript (JS). Net zoals HTML kent ook JS veel verschillende \u0026ldquo;woorden\u0026rdquo;. Hier behandelen we er een aantal.\nToevoegen aan een HTML bestand JS wordt voor HTML bestanden geschreven in een speciaal blok:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; JavaScript code hier! \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dit ziet er als volgt uit met code (De code wordt verder toegelicht):\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; const telOp = function(getal1, getal2) { return getal1+getal2; } const resultaat = telOp(1,2); console.log(resultaat); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Functies Een functie in JS ziet er als volgt uit:\nconst telOp = function(getal1, getal2) { return getal1+getal2; }  Hierbij zie je dat function aangeeft dat het een \u0026lsquo;functie\u0026rsquo; is. Vervolgens geven we de parameters op. Bij ons zijn dat getal1 en getal2. Als laatst gebruiken we deze twee variabelen om een optelling te doen. We geven dit getal terug door return te gebruiken.\nAls we dit stukje code als volgt aanroepen:\nconst resultaat = telOp(1,2); console.log(resultaat)  Dan zien we dat er 3 wordt geprint! We slaan hierbij het resultaat op in resultaat en printen die vervolgens met console.log(). Om nu de output te zien van de console.log() functie moeten we de console openen. Je kunt dit doen op verschillende manieren:\nWindows:\n F12 Rechtermuisknop + inspecteer Control+Shift+J  MacOs:\n Command+Option+J  Variabelen Variabelen in JS gebruiken net als andere talen een speciale syntax. In JS kennen we var, const en let. Een goede tip om problemen tegen te gaan is om alleen const en let te gebruiken.\nconst gebruiken we als een variabelen niet meer veranderd, en let als we de variabelen later nog aan willen passen.\nEen variabele resultaat maken doen we als volgt:\nlet resultaat = 6; //Zo  const resultaatConst = 6; //Of zo  In variabelen kunnen we data opslaan, dat is heel handig!\nVoorbeeld 1: Knop Bij een knop gaan we HTML en JS combineren!\nOpdracht Zorg allereest dat je een HTML pagina hebt met een knop.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Wat gebeurt er nu als je op de knop klikt?\nOpdracht Om nu interactie toe te voegen aan de knop gaan we JS en html combineren.\n Op de knop kunnen we de volgende HTML toevoegen: onclick=\u0026rdquo;\u0026quot;. Nu werkt het echter nog niet..! Nu moeten we een JS functie schrijven die de knop aan gaat roepen, weet jij nog waar dit moet staan in het HTML bestand?:  const buttonClicked = function() { alert(\u0026#34;Je hebt op de knop geklikt!\u0026#34;); }   Als laatste gaan we deze twee elementen aan elkaar koppelen door de onclick=\u0026rdquo;\u0026quot; aan te passen (Hier moet je wel de JS nog toevoegen!):  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;buttonClicked()\u0026#34;\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Voorbeeld 2: Een element toevoegen op de pagina We kunnen in JS nog veel meer doen dan interactie toevoegen, bijvoorbeeld aan knoppen. Ook kunnen we HTML toevoegen aan de HTML pagina!\nWe hebben hier een aantal functies voor in JS.\nconst element = document.getElementById(\u0026#34;\u0026lt;id\u0026gt;\u0026#34;); element.insertAdjacentHTML(\u0026#34;afterend\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;My text\u0026lt;/p\u0026gt;\u0026#34;);  Er zijn nog veel meer mogelijkheden, maar dit is een van de simpelste.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; const voegElementToe = function() { const element = document.getElementById(\u0026#34;mijnDivId\u0026#34;); element.insertAdjacentHTML(\u0026#34;afterend\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;My text\u0026lt;/p\u0026gt;\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;voegElementToe()\u0026#34;\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;mijnDivId\u0026#34;\u0026gt; Dit is een div\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Opdracht Kun jij nu met jouw kennis van JS en HTML een element toevoegen als je op een knop klikt?\nVoorbeeld 3: Reageren op berichten van een gebruiker Met de volgende HTML code hebben we een invoer veld waar de gebruiker iets in kan typen:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; #inputId { width: 300px; height: 40px; font-size: xx-large; } .container { display: flex; height: 100vh; justify-content: center; align-items: center; background-color: blue; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; //JavaScript code hier!  \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span\u0026gt; Wat is je naam? \u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;inputId\u0026#34;\u0026gt; \u0026lt;/input\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Als de gebruiker nu iets typt, zie je alleen de tekst staan. Er gebeurt verder nog niet zo veel. Kun jij ervoor zorgen dat de computer terugpraat?\n Voeg een knop toe aan de HTML pagina Als je op de knop klikt, log dan de text die in het input veld staat met console.log. Om de tekst uit het invoer veld te halen kun je gebruik maken van: const input = document.getElementById(\u0026quot;inputId\u0026quot;).value; Kun jij nu de computer Hallo \u0026lt;naam\u0026gt; laten zeggen? Je kan dit doen met de functie alert(), hier moet je nog wel text aan meegeven. Dit is een voorbeeld: alert(\u0026quot;Hoi Kevin!\u0026quot;)  Stijl toevoegen met CSS (vervolg) Maak voor de opdrachten in deze instructie een HTML-bestand met deze inhoud:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; /* hier komt je styling! */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Deze pagina gaan we stylen!\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Dit is een h2 kop\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Dit is ook een h2 kop!\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Wat zullen we met \u0026lt;span\u0026gt;deze\u0026lt;/span\u0026gt; alinea gaan doen?\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Deze alinea wordt nog mooier dan de vorige.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;De vorige alinea\u0026#39;s zijn \u0026lt;span\u0026gt;jaloers\u0026lt;/span\u0026gt; op mij.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Jaloers op mij zul je bedoelen!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tot nu toe heb je stijl toegevoegd door style=\u0026quot;...\u0026quot; te gebruiken in de HTML-onderdelen. Dat heeft voordelen en nadelen. Het is handig dat je meteen kunt zien hoe de inhoud van je webpagina eruit komt te zien. Minder handig is dat je aan ieder stukje HTML op deze manier een stijl moet toevoegen. Dat is én veel werk, én wordt al snel onoverzichtelijk als je veel stijlen hebt.\nHet is daarom gebruikelijk bij webpagina\u0026rsquo;s om de inhoud en stijl op verschillende plekken neer te zetten. Een manier om dit te doen is binnen het \u0026lt;style\u0026gt; onderdeel. De code binnen het \u0026lt;style\u0026gt; onderdeel ziet er wat anders uit dan je tot nu toe gezien hebt. Om tekst rood te maken gebruikte je\n\u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;Dit stukje tekst is rood\u0026lt;/p\u0026gt; Binnen \u0026lt;style\u0026gt; moet je deze code schrijven, een soort regel voor hoe de HTML zich moet gedragen:\np { color: red; } Opdracht Wat denk je dat er gebeurt als je dit stukje code in het \u0026lt;style\u0026gt; onderdeel zet? Probeer het eens. Had je gelijk?\nStijl toevoegen aan sommige, maar niet alle elementen Als je de opdracht van net hebt uitgevoerd, heb je gezien dat alle \u0026lt;p\u0026gt; onderdelen, dus alle alinea\u0026rsquo;s, rode tekst hebben. Dit is dus wat deze code doet:\n de eigenschap kleur krijgt de waarde rood voor alle \u0026lt;p\u0026gt; onderdelen  Maar stel nou dat je alleen bepaalde alinea\u0026rsquo;s rood wilt maken?\nClass Dat kan bijvoorbeeld door het HTML-onderdeel lid te maken van een zogenaamde class:\n\u0026lt;p class=\u0026#34;naamvandeclass\u0026#34;\u0026gt;Welke kleur is dit?\u0026lt;/p\u0026gt; In de CSS maak je een class door een punt aan het begin te gebruiken:\n.naamvandeclass { color: red; }  Opdracht Gebruik een class met de naam \u0026ldquo;rodealinea\u0026rdquo; om de 1e en 4e alinea rood te maken, dus zo:\n  .rodealinea { color: red; }    Deze pagina gaan we stylen! Dit is een h2 kop  Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\n  De vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\n    ID Een andere manier is om een HTML-onderdeel een uniek id te geven:\n\u0026lt;p id=\u0026#34;ikbenuniek\u0026#34;\u0026gt;Welke kleur is dit?\u0026lt;/p\u0026gt; In de CSS verwijs je naar een id door een hashtag aan het begin te gebruiken:\n#ikbenuniek { color: red; } Opdracht Maak de tekst van de eerste h1 kop blauw, en de 1e h2 kop groen (tip: je hebt hiervoor twee id\u0026rsquo;s nodig, \u0026ldquo;ikbenblauw\u0026rdquo; en \u0026ldquo;ikbengroen\u0026rdquo;):\n  .rodealinea { color: red; } #ikbenblauw { color: blue; } #ikbengroen { color: green; }    Deze pagina gaan we stylen! Dit is een h2 kop  Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\n  De vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\n    Samengevat heb je nu gezien dat je stijl kunt geven aan\n alle onderdelen van een bepaalde soort bepaalde onderdelen door ze lid te maken van een class losse onderdelen door ze een (uniek) id te geven  Combineren van stijlen Een grote kracht van CSS is dat je stijlen ook kunt combineren. Zo kun je meerdere eigenschappen tegelijk instellen in een CSS regel:\np { color: red; font-weight: bold; } Opdracht Voeg een tweede eigenschap toe aan de \u0026ldquo;rodealinea\u0026rdquo;, bijvoorbeeld background-color of font-family.\nJe kunt een onderdeel ook lid maken van meer dan één class (in dit voorbeeld heten die \u0026ldquo;rodealinea\u0026rdquo; en \u0026ldquo;box\u0026rdquo;):\n\u0026lt;p class=\u0026#34;rodealinea box\u0026#34; Opdracht Maak een class \u0026ldquo;box\u0026rdquo; die de eigenschap border instelt op 1px solid black, en voeg deze toe aan een van de rode alinea\u0026rsquo;s:\n  .rodealinea { color: red; } #ikbenblauw { color: blue; } #ikbengroen { color: green; } .box { border: 1px solid black; }    Deze pagina gaan we stylen! Dit is een h2 kop  Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\n  De vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\n    Actie toevoegen met JavaScript (vervolg) Nu je de basis van JS hebt gezien, gaan we wat verder met moeilijker onderdelen.\nEen klok maken We gaan een klok maken op een HTML pagina. Je kan de volgende HTML gebruiken:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; body { background: linear-gradient(45deg, #1870ed 0, #f18f88 100%); font-family: \u0026#39;Montserrat\u0026#39;, \u0026#39;sans-serif\u0026#39;; min-height: 100vh; display: flex; align-items: center; justify-content: center; } .clock-container { margin-top: 30px; margin-bottom: 30px; background-color: #080808; border-radius: 5px; padding: 60px 20px; box-shadow: 1px 1px 5px rgba(255, 255, 255, .15), 0 15px 90px 30px rgba(0, 0, 0, .25); display: flex; } .clock-col { text-align: center; margin-right: 40px; margin-left: 40px; min-width: 90px; position: relative; } .clock-col:not(:last-child):before, .clock-col:not(:last-child):after { content: \u0026#34;\u0026#34;; background-color: rgba(201, 166, 166, 0.3); height: 5px; width: 5px; border-radius: 50%; display: block; position: absolute; right: -42px; } .clock-col:not(:last-child):before { top: 35%; } .clock-col:not(:last-child):after { top: 50%; } .clock-timer { color: #fff; font-size: 4.2rem; text-transform: uppercase; } .clock-label { color: rgba(255, 255, 255, .35); text-transform: uppercase; font-size: 0.7rem; margin-top: 10px; } @media (max-width: 825px) { .clock-container { flex-direction: column; padding-top: 40px; padding-bottom: 40px; } .clock-col+.clock-col { margin-top: 20px; } .clock-col:before, .clock-col:after { display: none !important; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;clock-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-hours clock-timer\u0026#34; id=\u0026#34;clock-day\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Dag \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-hours clock-timer\u0026#34; id=\u0026#34;clock-hour\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Uren \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-minutes clock-timer\u0026#34; id=\u0026#34;clock-minute\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Minuten \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-seconds clock-timer\u0026#34; id=\u0026#34;clock-second\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Seconden \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //Hier moet jij je code gaan schrijven voor de clock!  let dagElement = document.getElementById(\u0026#34;clock-day\u0026#34;); let urenElement = document.getElementById(\u0026#34;clock-hour\u0026#34;); let minutenElement = document.getElementById(\u0026#34;clock-minute\u0026#34;); let secondenElement = document.getElementById(\u0026#34;clock-second\u0026#34;); const dagenInText = [\u0026#34;Zo\u0026#34;, \u0026#34;Ma\u0026#34;, \u0026#34;Di\u0026#34;, \u0026#34;Wo\u0026#34;, \u0026#34;Do\u0026#34;, \u0026#34;Vr\u0026#34;, \u0026#34;Za\u0026#34;]; function updateTime() { var today = new Date(); //Dit geeft je een datum terug,  //hier kun je de uren, minuten en seconden van halen.  //Met getHours() krijg je de uren  //Met getMinutes() krijg je de minuten  //Met getSeconds() krijg je de seconden  //De dag hebben wij voor je gedaan!  dagElement.innerText = dagenInText[today.getDay()]; urenElement.innerText = \u0026#34;1\u0026#34;; minutenElement.innerText = \u0026#34;1\u0026#34;; secondenElement.innerText = \u0026#34;1\u0026#34;; } //Dit voert de functie iedere seconde opnieuw uit,  //De tijd gaat natuurlijk met 1 seconde per keer vooruit!  setInterval(updateTime, 1000); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; De klok werkt nu nog niet.. Kan jij dit oplossen? In het \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; blok moet jij de code gaan aanpassen, daarmee kun je de klok weer aanslingeren ;) !\nHet instellen van kleuren op je webpagina Er zijn een een heel aantal manieren om een kleur in te stellen voor onderdelen van je pagina, bijvoorbeeld\n met namen_ \u0026lt;p style=\u0026quot;color:red\u0026quot;\u0026gt; met RGB-waarden_ \u0026lt;p style=\u0026quot;color:rgb(255, 0, 0)\u0026quot;\u0026gt; met HEX-waarden_ \u0026lt;p style=\u0026quot;color:#FF0000\u0026quot;\u0026gt;  Namen Er zijn 140 kleuren die een eigen naam hebben:\nRGB-waarden RGB staat voor Rood Groen Blauw. Dit is ook de volgorde waarmee je ze instelt in de code. De waarde gaat van 0 (helemaal niks van deze kleur) tot 255 (alles van deze kleur). Een paar voorbeelden:\n   RGB code Rood Groen Blauw Kleur     (0, 255, 0) 0 255 0 groen   (255, 0, 255) 255 0 255 magenta   (173, 216, 230) 173 216 230 lichtblauw    HEX-waarden  HEX is een afkorting voor hexadecimaal, wat een manier van tellen is die vaak wordt gebruikt bij computers. In plaats van de 10 cijfers (0 t/m 9) waar we meestal mee tellen tel je hier met 16 \u0026ldquo;cijfers\u0026rdquo;, namelijk 0 t/m 9 en A t/m F. De HEX code voor een kleur is zes cijfers lang: de linker twee bepalen hoeveel rood er in de kleur zit, de middelste twee hoeveel groen en de rechter twee hoeveel blauw. 00 is de laagste waarde (omgerekend 0), FF is de hoogste waarde (omgerekend 255). De zescijferige code staat in de HTML-code na een #.  De kleuren van de RGB-voorbeelden zijn in HEX code\n   HEX code Kleur     00FF00 groen   FF00FF magenta   ADD8E6 lichtblauw    Bronvermelding afbeeldingen  HTML logo by W3C CSS logo by Rudloff JS logo by Omed Habib SVG_Recognized_color_keyword_names by Monaneko  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"October 22, 2020","permalink":"/instructies/web-development/","title":"Web - Development"},{"categories":null,"contents":"Introductie Sluit de Arduino pas aan op de computer met de USB kabel nadat je een circuit hebt gebouwd. Haal de kabel er weer uit voor je iets verandert aan het circuit.\nDe onderdelen De Arduino Uno heeft een aantal verschillende aansluitingen: de voeding (plus en aarde), digitale in- en uitgangen, en analoge in-en uitgangen.  Met de voeding kun je het circuit dat je hebt gebouwd van stroom voorzien. Met de digitale in- en uitgangen kun je aan en uit opdrachten geven, bijvoorbeeld of een LED aan of uit moet staan. Dit zijn aansluitingen 2 t/m 13 Met de analoge ingangen kun je de waarden van bijvoorbeeld licht- of temperatuursensoren meten (die zijn niet beperkt tot 0 (uit) of 1 (aan). Dit zijn aansluitingen A0 t/m A5. Met de analoge uitgangen (dit zijn de digitale aansluitingen die gemerkt zijn met een ~) kun je bijvoorbeeld een LED harder of zachter laten branden.  Je kunt een circuit bouwen op een zogenaamd breadboard. Deze zijn er in allerlei soorten en maten. Op dit schema kun je zien welke gaatjes (elektrisch) met elkaar verbonden zijn. Opdrachten Code uploaden naar de Arduino Als je een stuk code hebt gemaakt in mBlock, klik je met de rechtermuisknop op het Arduino programma. De code die naar de Arduino geupload moet worden komt tevoorschijn. Klik nu op Upload naar Arduino. Voorbeeldopdracht 1: knipperende LED  Maak het volgende circuit (met behulp van een breadboard).  Schakel nu de LED in door de juiste output op HOOG te zetten. mBlock code     Nu wil je dat de LED daarna ook weer uit gaat. mBlock code     Er zit geen tijd tussen het aan- en uitgaan! mBlock code     Nu wil je dit blijven herhalen. mBlock code      Voorbeeldopdracht 2: metronoom (Grove kit)  Sluit het LCD scherm, de variabele weerstand en de buzzer aan op de juiste poorten. Laat de buzzer elke seconde (of zoiets) een geluidje maken. mBlock code     Lees de waarde van de variabele weerstand af om deze vervolgens te kunnen vertalen naar een snelheid voor de metronoom. mBlock code     Combineer nu de buzzer en variabele weerstand! mBlock code      Uitdagingen  Stoplicht met schakelaar Lichtkrant (Grove, met LCD schermpje) Licht- of donkerwijzer (met servo motor) Thermometer (met temperatuursensor)  Bronnen  https://www.arduino.cc/en/Tutorial/BlinkWithoutDelay Project: http://www.makeuseof.com/tag/arduino-traffic-light-controller/ Schakelaar: http://oscarromero-arduino.weebly.com/pull-down-weerstand.html https://github.com/josejuansanchez/37-in-1-arduino-sensor-kit/tree/master/001 https://github.com/Seeed-Studio/Sketchbook_Starter_Kit_for_Arduino http://wiki.seeed.cc/Grove_Starter_kit_for_Arduino_101/ Breadboard Elementen  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.   ","date":"August 29, 2020","permalink":"/instructies/mblock/arduino/","title":"mBlock - Arduino"},{"categories":null,"contents":"Introductie Voor je de mBot aanzet: de mBot eerst op de grond zetten of op de kop leggen!\nHou rekening met de beperkte ruimte: laat het vermogen van de wielen eerst gewoon op 50% staan.\nOok handig om te weten:\n Je kunt de taal instellen via de wereldbol. De volgende instructies gaan uit van Nederlandse blokken. Je vindt de mBot bij Apparaten; bij Sprites staan de afbeeldingen die je op het scherm ziet (in het voorbeeld dus de panda). Net als bij Scratch staan de blokken per soort bij elkaar. Neem even de tijd om te kijken wat voor blokken er in de verschillende menu\u0026rsquo;s staan. Waar vind je bijvoorbeeld de als\u0026hellip; dan\u0026hellip; blokken? Je kunt de mBot live programmeren terwijl deze met de computer verbonden is, of programma\u0026rsquo;s uploaden\u0026gt; naar het geheugen van de mBot. De live manier is makkelijk als je aan het uitproberen bent hoe dingen werken, na uploaden kun je de mBot loskoppelen van de computer.  De mBot met de computer verbinden  Start mBlock. Sluit de mBot aan met de USB-kabel en zet de robot aan. Verwijder bij het tabblad Apparaten eventuele andere robots, klik op toevoegen en kies dan de mBot. Klik nu op verbinden, begin met de Live stand. Test of de verbinding gelukt is, bijvoorbeeld door op dit element te (dubbel)klikken:  Je bent nu klaar om een programma te gaan schrijven!  De input en output van de mBot Voelen (met de sensoren) De mBot heeft een aantal sensoren om z\u0026rsquo;n omgeving te voelen.\n Ultrasoon: dit zijn de twee \u0026lsquo;ogen\u0026rsquo; voorop de mBot. De mBot gebruikt net als een vleermuis echo\u0026rsquo;s om voorwerpen te \u0026lsquo;zien\u0026rsquo;. Het ene oog stuurt een geluidje en het andere oog vangt de echo op. Lijnvolg: voor het voorwiel zitten twee sensoren die het verschil tussen licht en donker kunnen meten. Als de mBot over een lijn rijdt kan hij op deze manier zien of er een bocht aankomt. Lichtsterkte: bovenop (onder het plastic kapje) zit een sensor die meet hoe licht het in de ruimte is.  Doen (met de actuatoren)  Motoren: ieder wiel wordt met een aparte motor bestuurd. LEDs: bovenop (onder het plastic kapje) zitten twee LEDs die je elke kleur kunt maken die je wilt. Buzzer: ook onder het kapje zit een buzzer waarmee je de mBot verschillende hoogte tonen kunt laten maken.  Opdrachten Voorbeeldopdracht 1: een vierkant rijden Aangezien de mBot bij dit programma moet rijden is het verstandig je programma naar de mBot te uploaden en het programma te starten als deze op de grond staat. Je kunt het programma laten starten bij het aanzetten van de mBot; in dit voorbeeld start het programma als de knop bovenop wordt ingedrukt.\n De eerste stap is om de mBot een stuk vooruit te laten rijden. 50% van het vermogen is prima om mee te beginnen. Start het programma door op het zwarte knopje bovenop de mBot te drukken. mBlock code     Nu rijdt de mBot eindeloos door! Zorg dus dat deze na een paar seconden weer stopt met rijden. mBlock code     Laat nu de mBot een bocht maken. Probeer de tijd zo in te stellen dat ie rechtsaf (of linksaf) slaat. mBlock code     Dit stuk code wil je nu een aantal keer herhalen. mBlock code      Voorbeeldopdracht 2: sensorwaarden laten zien Om opdrachten te kunnen programmeren is het vaak handig om te weten wat de sensoren van de mBot meten. Om dit te kunnen zien moet je de gemeten waarde bewaren in een variabele. Kijk bijvoorbeeld wat de lichtsensor meet als je je hand bovenop de mBot houdt, of de ultrasoonsensor als je je hand heen en weer beweegt voor de mBot.\n Maak eerst een variabele aan voor lichtsterkte en/of afstand. Je kunt zelf kiezen of andere sprites deze variabele ook mogen zien en gebruiken. mBlock code     Wijs nu de waarde gemeten door de sensor toe aan deze variabele. Als je nu het programma uitvoert zie je dat linksboven in het scherm de gemeten waarde(n) getoond worden. \u0026ldquo;mBot:\u0026rdquo; voor lichtsterkte geeft aan dat deze variabele alleen voor de mBot beschikbaar is. mBlock code     De LEDs op de mBot kunnen beïnvloeden wat de lichtsensors meten, zet daarom eerst de LEDs uit. mBlock code     Waarschijnlijk wil je de waarde(n) van de sensor(s) meer dan één keer bepalen. Herhaal daarom deze stap. Vaak is het ook verstandig een kleine pauze na iedere herhaling in te bouwen. mBlock code      Voorbeeldopdracht 3: help, een muur! In deze opdracht is het de bedoeling om te voorkomen dat de mBot tegen de muur botst (nadat je \u0026rsquo;m er wel naar toe laat rijden natuurlijk).\n Begin weer met de mBot te laten rijden na het indrukken van de knop. mBlock code     Maak nu een voorwaarde waarbij de mBot bij een afstand van minder dan 20 centimeter stopt met rijden. mBlock code     Gebeurt er nu wat je wil? Zo niet, denk dan eens na waarom niet? Heb je een stukje code vergeten? mBlock code     Sla maar eens flink alarm met licht en geluid om duidelijk te maken dat de mBot bijna gebotst was! Natuurlijk kan dit op veel manieren, de voorbeeldcode is er daar één van. mBlock code      Uitdagingen Hier nog een paar uitdagingen waar je aan kunt werken. Ze beginnen makkelijk en worden steeds moeilijker.\nGa zelf aan de gang! Natuurlijk kun je zelf iets verzinnen voor de mBot, hier zijn wat ideeën voor als je inspiratie nodig hebt:\n Rijd een achtje (of extra moeilijk: een spiraal) Lichten aan in de tunnel Aan de slag als politieauto of ambulance Volg de lijn Ontwijk de voorwerpen Volg een voorwerp  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.   ","date":"August 29, 2020","permalink":"/instructies/mblock/mbot/","title":"mBlock - mBot"},{"categories":null,"contents":"In deze opdracht ga je een figuur uit Scratch laten bewegen met de micro:bit.\nLet op: dit kan op dit moment alleen als je een computer hebt met Windows 10 of Mac OS 10+ en met Bluetooth 4.0.\nVoorbereiding Wat heb je nodig   een micro:bit\n  een USB kabel om de micro:bit aan te sluiten aan de computer\n  een batterij om de micro:bit los van de computer te kunnen gebruiken\n  Scratch 3 en de micro:bit met elkaar verbinden Om de micro:bit met Scratch te verbinden moet je twee dingen doen: een programmaatje installeren op je computer en een bestandje naar de micro:bit kopiëren. Volg de aanwijzingen op de Scratch Link pagina. Misschien handig: helemaal onderaan de pagina kun je de taal op Nederlands zetten.\nHet programma Stap 1: Scratch Ga naar de Scratch website, klik linksonder op het Scratch Extensions icoon\nen kies hier de micro:bit extensie. De micro:bit blokken worden nu onderaan toegevoegd en er wordt verbinding gezocht met de micro:bit, dit ziet er zo uit:\nStap 2: De Scratch kat besturen met de micro:bit Je bent nu klaar om een spelletje te maken met de micro:bit als controller. Je kunt bijvoorbeeld de Scratch kat (of een ander figuur natuurlijk) laten reageren wanneer je op een knopje drukt, of bijvoorbeeld de micro:bit naar een kant kantelt. Probeer deze blokken maar eens en kijk wat er gebeurt:\nDit is natuurlijk nog niet heel spannend, maar je ziet dat er eigenlijk niet echt verschil is of je nou toetsen op je toetsenbord of de micro:bit gebruikt.\nStap 3: De besturing wat \u0026ldquo;slimmer\u0026rdquo; maken Bij de blokken in de vorige stap zag je dat de Scratch kat nadat je de \u0026ldquo;A\u0026rdquo; knop had ingedrukt de hele tijd \u0026ldquo;Hallo!\u0026rdquo; bleef zeggen, en dat je de micro:bit steeds opnieuw naar links moest kantelen om de kat een stukje te laten bewegen. Dat kan handiger, en werkt op dezelfde manier als wanneer je gewoon de knoppen van je toetsenbord gebruikt. Door een herhaal te gebruiken samen met een als \u0026hellip; dan \u0026hellip; blok te gebruiken kun je steeds controleren of een knop is ingedrukt, de micro:bit wordt gekanteld, enzovoorts. Dan ziet je programma er bijvoorbeeld zo uit:\nJe kunt de verschillende als \u0026hellip; dan \u0026hellip; blokken natuurlijk ook in hetzelfde herhaal blok zetten.\nAls je de beweging van je figuur vloeiender wilt maken kun je bijvoorbeeld kijken naar deze instructies, waarbij je dan de toetsenbordknoppen moet vervangen door knoppen en bewegingen van de micro:bit. Je kunt ook spelen met kantelen naar voren en achteren, of schudden met de micro:bit.\nStap 4: Een spelletje bouwen Nu je de Scratch kat kunt laten bewegen met de micro:bit kun je hier een spelletje omheen bedenken. Heb je zelf geen ideeën? Vraag de mentoren of kijk eens hier:\n Onze andere Micro:Bit opdrachten Scratch projecten en zoek bijvoorbeeld op \u0026lsquo;platform\u0026rsquo; of \u0026lsquo;vliegen\u0026rsquo; (waarschijnlijk werkt dit alleen in Google Chrome)  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/microbit-controller/","title":"Micro:Bit - Als controller in Scratch"},{"categories":null,"contents":"We gaan de Maqueen laten voelen en laten doen.\nIntroductie Voor je de Maqueen aanzet: de Maqueen eerst op de grond zetten! Hou rekening met de beperkte ruimte: laat het vermogen van de wielen eerst gewoon op 50% staan.\nOok handig om te weten (zie de cijfers in de afbeelding hierboven):\n Bij de instellingen kun je de taal aanpassen. Deze instructies gaan uit van Nederlandse blokken. Net als bij Scratch staan de blokken per soort bij elkaar. Neem even de tijd om te kijken wat voor blokken er in de verschillende menu\u0026rsquo;s staan. Waar vind je bijvoorbeeld de als\u0026hellip; dan\u0026hellip; blokken? Met de knop Downloaden zet je je programma op de micro:bit. Als je een fout hebt gemaakt en die wil herstellen dan klik je op het pijltje terug  De Maqueen met de computer verbinden  Start MakeCode. Voeg de Maqueen functies toe aan MakeCode door helemaal onderaan het menu met de blokken op Uitbreidingen te klikken. Plak deze url in de zoekbalk boven in het scherm dat nu verschijnt: https://github.com/MKleinSB/maqueen en klik op het plaatje dat verschijnt. Steek de micro:bit in de Maqueen. De knoppen en LEDjes moeten aan de voorkant zitten. Sluit de micro:bit met de USB-kabel op de computer aan. Je hoeft de Maqueen zelf nog niet aan te zetten. Klik nu op verbinden, begin met de Live stand. Test of de verbinding gelukt is door dit programma te maken en het naar de micro:bit te downloaden: De LED linksvoor zou nu moeten gaan branden. Je bent nu klaar om een eigen programma te gaan schrijven!  De input en output van de Maqueen Voelen (met de sensoren) De Maqueen heeft een aantal sensoren om z\u0026rsquo;n omgeving te voelen.\n Ultrasoon: dit zijn de twee \u0026lsquo;ogen\u0026rsquo; voorop de Maqueen. De Maqueen gebruikt net als een vleermuis echo\u0026rsquo;s om voorwerpen te \u0026lsquo;zien\u0026rsquo;. Het ene oog stuurt een geluidje en het andere oog vangt de echo op. De afstand die de sensor meet heet in MakeBlock Sensor eenheid. Lijnvolg: onderop, achter het voorwiel, zitten twee sensoren die het verschil tussen licht en donker kunnen meten. Als de Maqueen over een lijn rijdt kan hij op deze manier zien of er een bocht aankomt. Wat deze sensoren meten heet in MakeBlock Lees route geleiding. Infrarood: voorop, als een soort neusje, zit een infrarood sensor waarmee je de Maqueen bijvoorbeeld met een afstandsbediening kunt besturen.  Doen (met de actuatoren)  Motoren: ieder wiel wordt met een aparte motor bestuurd. LEDs: voorop zitten twee rode LEDs, onderop zitten 4 LEDs (NeoPixels) die je iedere kleur kunt maken die je wilt. Buzzer: net achter de micro:bit zit een buzzer waarmee je de Maqueen allerlei tonen kunt laten maken, en zelfs een beetje laten praten. Meer over de Maqueen kun je hier lezen (in het Engels).  MakeCode opdrachten Voorbeeldopdracht 1: een vierkant rijden  De eerste stap is om de Maqueen een stuk vooruit te laten rijden. 100 is een mooie snelheid om mee te beginnen. Laat de Maqueen gaan rijden als je op de linkerknop van de micro:bit drukt. Zet \u0026rsquo;m eerst op de grond! MakeCode code     Nu rijdt de Maqueen eindeloos door! Zorg dus dat deze na een paar seconden weer stopt met rijden. MakeCode code     Laat nu de Maqueen een bocht maken. Probeer de tijd zo in te stellen dat ie rechtsaf (of linksaf) slaat. MakeCode code     Nu wil je meer bochten maken. Probeer daar eens een herhaal-blok voor te gebruiken! MakeCode code      Voorbeeldopdracht 2: help, een muur! In deze opdracht is het de bedoeling om te voorkomen dat de Maqueen tegen de muur botst (nadat je \u0026rsquo;m er wel naar toe laat rijden natuurlijk).\n Begin weer met de Maqueen te laten rijden na het indrukken van de knop. MakeCode code     Maak nu een voorwaarde waarbij de Maqueen bij een afstand van minder dan 20 centimeter stopt met rijden. MakeCode code     Gebeurt er nu wat je wil? Zo niet, denk dan eens na waarom niet? Heb je een stukje code vergeten? MakeCode code oplossing 1    MakeCode code oplossing 2     Sla maar eens flink alarm met licht en geluid om duidelijk te maken dat de Maqueen bijna gebotst was! Natuurlijk kan dit op veel manieren, de voorbeeldcode is er daar één van. MakeCode code      Voorbeeldopdracht 3: knipperen op de zebra In deze opdracht is het de bedoeling dat je de LEDs van de Maqueen aan laat gaan op het moment dat je over zwarte strepen rijdt. Je kunt hiervoor het best zwart tape gebruiken, stiften werken niet zo goed.\n Begin weer met de Maqueen te laten rijden na het indrukken van de knop. MakeCode code     Welke sensor kun je gebruiken om de zwarte strepen te herkennen? En welke waarde heeft de sensor als deze zwart ziet? Hint: je kunt de display van de micro:bit (de 25 LEDs) gebruiken om deze waarde te laten zien. MakeCode code     Gebruik deze waarde nu in een voorwaarde om de LED aan en uit te laten gaan terwijl je over de strepen rijdt. MakeCode code      Uitdagingen Hier nog een paar uitdagingen waar je aan kunt werken. Ze beginnen makkelijk en worden steeds moeilijker.\nGa zelf aan de gang! Natuurlijk kun je zelf iets verzinnen voor de Maqueen, hier zijn wat ideeën voor als je inspiratie nodig hebt:\n Rijd een achtje (of extra moeilijk: een spiraal) Lichten aan in de tunnel Aan de slag als politieauto of ambulance Volg de lijn Ontwijk de voorwerpen Volg een voorwerp  Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/maqueen/","title":"Micro:Bit - Maqueen"},{"categories":null,"contents":"In deze opdracht ga je het spelletje steen-papier-schaar programmeren op de micro:bit, en dit spelen tegen iemand anders.\nVoorbereiding Wat heb je nodig:  een micro:bit (of twee) een USB kabel om de micro:bit aan te sluiten aan de computer een batterij om de micro:bit los van de computer te kunnen gebruiken  Het programma Stap 1: steen, papier en schaar tekenen Bij dit programma maken we gebruik van de LEDjes op de micro:bit. Hier kun je allerlei figuren op maken, teken nu eerst een steen, vel papier en een schaar.\nStap 2: een keuze maken De micro:bit gaat een van de drie kiezen. Hiervoor moet je een paar dingen programmeren.\n  Eerst heb je het blok pick random 0 to 10 voor nodig, dit vind je in het menu Wiskunde. Stel het blok zo in dat het drie getallen kan kiezen, namelijk 1, 2 of 3:   Maak nu een variabele aan om het gekozen getal een naam te geven en later weer te kunnen gebruiken. Noem het bijvoorbeeld \u0026ldquo;keuze\u0026rdquo;:   Geef nu deze variabele de waarde van het gekozen getal, en laat de micro:bit deze opdracht uitvoeren als je op de A knop van de micro:bit drukt:   Stap 3: het gekozen plaatje laten zien Je hebt nu een variabele keuze die het cijfer 1, 2 of 3 kan zijn, en drie plaatjes. Nu moet elk van de keuzes een ander plaatje laten zien: 1 = steen, 2 = papier en 3 = schaar.\nGebruik hiervoor het blok als \u0026hellip; dan \u0026hellip; blok en het \u0026hellip; = \u0026hellip; blok uit het menu Logisch:\nAls je het programma hierboven uitvoert laat de micro:bit alleen een plaatje zien als keuze 1 is, voeg daarom nu ook de andere twee plaatjes toe.\nAls iemand anders nu ook het steen-papier-schaar programma op een micro:bit zet dan kun je het tegen elkaar spelen!\nStap 4: een bericht sturen en ontvangen Als je nog tijd over hebt en het programma nog verder wilt uitbreiden dan kun je proberen de micro:bits met elkaar te laten praten. Als de micro:bits hun keuze naar elkaar sturen kunnen ze de keuzes vergelijken en zelf ook zien wie er gewonnen heeft.\nMicro:bits praten met elkaar via de radio. Ze kunnen bijvoorbeeld woorden of getallen naar elkaar sturen, en je kunt de micro:bit programmeren om een opdracht uit te voeren bij het ontvangen van een bericht.\nBij steen-papier-schaar sturen de micro:bits de waarde van keuze naar elkaar toe (pijl 1). Wacht voor je je keuze naar de andere micro:bit stuur eerst even (pijl 2), anders verdwijnt je plaatje meteen weer:\nOm een bericht te kunnen ontvangen moeten micro:bits op hetzelfde kanaal sturen en ontvangen (net als bijvoorbeeld bij een walkie-talkie):\nStap 5: de winnaar bekend maken De micro:bit kan nu de keuze van de ander ontvangen, maar doet er nog niks mee. Om de eigen keuze met die van de andere te vergelijken om te kijken wie er gewonnen heeft gebruik je weer een als \u0026hellip; dan \u0026hellip; blok uit het menu Logisch, waarbij er natuurlijk een boel verschillende combinaties zijn!\n Speler 1 heeft steen en speler 2 ook: gelijkspel! Speler 1 heeft steen en speler 2 heeft schaar: speler 1 wint! Speler 1 heeft steen en speler 2 heeft papier: speler 2 wint! Enzovoorts  In het voorbeeld hieronder zie je dat je moet kijken naar het receivedNumber, het ontvangen nummer dus de keuze van de andere micro:bit.\nEr zijn alvast twee gevallen geprogrammeerd:\n dat waarbij de micro:bits allebei dezelfde keus maakten: dan is \u0026ldquo;keuze\u0026rdquo; gelijk aan receivedNumber dat waarbij de eigen keuze steen was (getal 1) en dat van de ander papier (getal 2). Deze micro:bit heeft dan dus verloren.  Programmeer nu zelf de rest van de mogelijkheden.\nStap 6: tot drie tellen voor je het plaatje laat zien Om het nog even spannend te houden kun je de micro:bit eerst nog tot drie laten tellen voor je de keuze laat zien. Hier heb je een x keer herhalen blok voor nodig uit het menu Lussen en het toon nummer blok uit het menu Basis:\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/steen-papier-schaar/","title":"Micro:Bit - Steen-papier-schaar"},{"categories":null,"contents":"In deze opdracht ga je een stoplicht maken.\nHet stoplicht heeft twee kleuren: groen en rood. Normaal staat het stoplicht op rood. Als je op een knopje drukt springt het op groen, en na een tijdje weer op rood. Als dit gelukt is kun je het programma zo aanpassen dat het stoplicht op groen springt als er een auto over de micro:bit heen \u0026ldquo;rijdt\u0026rdquo;, bijvoorbeeld door je hand erboven te houden.\nVoorbereiding Wat heb je nodig:  een micro:bit een USB kabel om de micro:bit aan te sluiten aan de computer een rode en een groene LED vier \u0026ldquo;krokodillenbekken\u0026rdquo;  Alles aansluiten Net als batterijen hebben LED lampjes een plus en een min. Als je goed kijkt zijn de pootjes van de LED\u0026rsquo;s niet even lang: het net iets langere pootje is de plus, de kortere de min. Gebruik de krokodillenbekken om de plussen van de rode en groene LED vast te maken op aansluitingen Pin 0 en Pin 1 van de micro:bit, en de minnen aan de GND (je kunt de eerste krokodillenbek aan GND vastmaken en de tweede aan de eerste). Het zou er dan ongeveer zo uit moeten zien:\nHet programma Stap 1: Een LED aanzetten Om een LED aan te zetten moet je stroom laten lopen van de plus-aansluiting door de LED naar de min. Dit doe je met het blok schrijf digitaal pin \u0026lt;P0\u0026gt; naar 0. Dit vind je door op Geavanceerd (zie pijl 1) te klikken en daarna op Pinnen (pijl 2), zie het plaatje hieronder. Laat de LED aan gaan wanneer je op knop A drukt.\nStap 2: De LED weer uit laten gaan Je hebt er weinig aan als de LED de hele tijd aan blijft. Deze moet dus na een tijdje weer uit. Wacht na het aanzetten bijvoorbeeld een seconde (1000 ms) en zet de LED dan weer uit door Pin 0 weer op 0 te zetten:\nStap 3: Het stoplicht staat op rood, tot je op de knop drukt Nu is het tijd om allebei de LEDs te gebruiken: de rode moet eigenlijk altijd aan zijn, behalve wanneer op knop A wordt gedrukt. Dit doe je door bij het opstarten de rode LED al aan te zetten, en deze uit te zetten op het moment dat de groene LED aan gaat:\nStap 4: de knop vervangen door een “auto” Als extra uitdaging kun je nu het indrukken van knop A vervangen door wat er gebeurt als de micro:bit in het donker terecht komt doordat er een auto overheen rijdt. Hiervoor heb je het blok lichtniveau uit het menu Invoer nodig, en moet je kijken hoeveel licht (een getal tussen 0=helemaal donker en 255=heel licht) de micro:bit ziet als je er bijvoorbeeld je hand boven houdt. Deze waarde kun je dan gebruiken als voorwaarde om het stoplicht op groen te laten springen. Om een programma met deze voorwaarde te maken heb je ook blokken uit het menu Logisch nodig: het als waar dan \u0026hellip; blok en het \u0026hellip; \u0026lt; \u0026hellip; blok. En je moet ervoor zorgen dat je programma de hele tijd kijkt of de voorwaarde waar is of niet. Uiteindelijk moet het er dan ongeveer zo uitzien:\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie.  ","date":"August 27, 2020","permalink":"/instructies/microbit/stoplicht/","title":"Micro:Bit - Stoplicht"}]