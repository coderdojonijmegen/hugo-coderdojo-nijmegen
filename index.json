[{"categories":null,"contents":"\nWat gaan we doen? Daar moeten we nog even over nadenken\u0026hellip; üòâ\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWe gaan er vanuit dat je zelf een laptop meeneemt. Mocht dat niet kunnen, laat ons dat dan even weten, zodat we een leenlaptop voor je kunnen regelen.\nKinderen onder de 12 moeten worden begeleid door een ouder/verzorger.\nWanneer en waar? Zaterdag 1 juni van 12:00u tot 14:30u.\nWe zijn te gast in bibliotheek Zwanenveld.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"April 21, 2024","permalink":"/dojos/887178995257/","title":"#108: dojo"},{"categories":null,"contents":"\nWat gaan we doen? W at gaan we dan doen in deze bijzondere omgeving? Kunst maken met de computer! We hebben instructies met Scratch, Python en p5.js. Dus voor zowel kinderen met een beetje en met wat meer programmeerervaring zijn er uitdagende kunstwerken te maken - en zelf te bedenken.\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWe gaan er vanuit dat je zelf een laptop meeneemt. Mocht dat niet kunnen, laat ons dat dan even weten, zodat we een leenlaptop voor je kunnen regelen.\nKinderen onder de 12 moeten worden begeleid door een ouder/verzorger.\nWanneer en waar? Zaterdag 11 mei van 12:00u tot 14:30u.\nWe zijn te gast bij Mosadex eHealth.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"March 24, 2024","permalink":"/dojos/870504110227/","title":"#107: kunst maken, met Scratch, Python en p5.js"},{"categories":null,"contents":"\nSonic Pi is een leuke manier om muziek te maken met code. Je kunt je eigen liedjes, beats, geluiden en effecten programmeren met eenvoudige commando‚Äôs.\nJe kunt ook live coderen, wat betekent dat je je code kunt veranderen terwijl de muziek speelt. Zo kun je experimenteren, improviseren en samenwerken met anderen. Sonic Pi is gratis en werkt op Windows, Mac, Linux en Raspberry Pi. Je kunt Sonic Pi gebruiken om te leren over programmeren, muziek, wiskunde, kunst en nog veel meer. Sonic Pi is gemaakt door Sam Aaron, een onderzoeker aan de Universiteit van Cambridge, die ook muziek maakt met Sonic Pi. Dit korte filmpje toont hoe hij programmeert terwijl de muziek speelt:\nWil je ook leren hoe je muziek kunt maken met Sonic Pi? Ga dan naar de Sonic Pi website en volg de tutorial (Engelstalig). Je zult versteld staan van wat je kunt doen met Sonic Pi!\nbron: Copilot in Edge browser\nVoorbereiding Sonic Pi is beschikbaar voor Windows, MacOS en Raspberry Pi OS.\nJe moet het installeren om het te kunnen gebruiken. Er is (nog) geen web versie beschikbaar.\nInstructies Raspberry Pi Foundation Aan de slag met Sonic Pi\nLeer hoe je live muziek kunt coderen met Sonic Pi. Codeer de Tetris herkenningsmelodie\nSpeel de Tetris melodie met Sonic Pi! Drumloop\nMaak een drumloop met samples Alle Sonic Pi instructies: Sonic Pi\nCoderDojo Leiden Happy Birthday\nHappy birthday met Sonic Pi! Jingle Bells\nSpeciaal voor kerst: Jingle Bells met Sonic Pi! Muziek Als je wat ervaring hebt opgedaan met Sonic Pi, kun je hier wat muziek vinden om te gebruiken in je scripts. Er wordt gebruik gemaakt van dezelfde letters als in Sonic Pi.\n","date":"February 18, 2024","permalink":"/onderwerpen/sonic-pi/","title":"Sonic Pi"},{"categories":null,"contents":"\nDeze maand gaan we met L√∂ve2D aan de slag en gaan we games maken. L√∂ve2D is een 2D game framework gebaseerd op de programmeertaal Lua.\nJe kunt kiezen uit een shooter met vliegtuigen. Of je maakt het spelletje Snake waarbij een slang appels eet. Of je maakt een variant van Tetris. Het spel waarbij je blokjes met verschillende vormen in elkaar kunt laten vallen.\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWe gaan er vanuit dat je zelf een laptop meeneemt. Mocht dat niet kunnen, laat ons dat dan even weten, zodat we een leenlaptop voor je kunnen regelen.\nKinderen onder de 12 moeten worden begeleid door een ouder/verzorger.\nWanneer en waar? Zaterdag 6 april van 12:00u tot 14:30u.\nWe zitten in bibliotheek Mari√´nburg.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"February 18, 2024","permalink":"/dojos/843478455767/","title":"#106: games maken met L√∂ve2D"},{"categories":null,"contents":"\nWe gaan deze keer muziek programmeren met Sonic Pi.\nSonic Pi is een leuke manier om muziek te maken met code. Je kunt je eigen liedjes, beats, geluiden en effecten programmeren met eenvoudige commando‚Äôs.\nNOTABENE: Sonic Pi werkt helaas alleen op Windows en MacOs en niet op een Chromebook üò¢.\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWe gaan er vanuit dat je zelf een laptop meeneemt. Mocht dat niet kunnen, laat ons dat dan even weten, zodat we een leenlaptop voor je kunnen regelen.\nKinderen onder de 12 moeten worden begeleid door een ouder/verzorger.\nWanneer en waar? Zaterdag 2 maart van 12:00u tot 14:30u.\nWe zitten in bibliotheek Zwanenveld.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"January 15, 2024","permalink":"/dojos/798190428057/","title":"#105: muziek programmeren met Sonic Pi"},{"categories":null,"contents":"De Raspberry Pi Pico is een microcontroller, wat betekent dat het een heel eenvoudige computer is. Je kunt er inputs op aansluiten, zoals lichtsensoren, en outputs zoals motoren en lampen.\nMentor Jaap heeft deze instructie voorbereid voor dojo #103.\nKan de PDF niet laten zien. Download het hier.\n","date":"January 12, 2024","permalink":"/instructies/python-raspberry-pi-pico/","title":"Python - Raspberry Pi Pico"},{"categories":null,"contents":"\nWe zijn te gast bij internet hosting provider RootNet. Dus we gaan aan de slag met technieken van het web!\nWe gaan een chatprogramma in de browser maken met wat Javascript en natuurlijk HTML en CSS. Kun jij straks berichtjes sturen naar de ninja aan de andere kant van de ruimte? Heb jij het mooiste chat-window?\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWe gaan er vanuit dat je zelf een laptop meeneemt. Mocht dat niet kunnen, laat ons dat dan even weten, zodat we een leenlaptop voor je kunnen regelen.\nKinderen onder de 12 moeten worden begeleid door een ouder/verzorger.\nWanneer en waar? Zaterdag 3 februari van 12:00u tot 14:30u.\nWe zijn te gast bij RootNet en zij hebben een ruimte in De Achtertuin in de Vasim voor ons geregeld.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"January 1, 2024","permalink":"/dojos/787559069377/","title":"#104: Chat webapp"},{"categories":null,"contents":"\nOntdek de wereld van code.org, waar kinderen leren coderen en hun eigen digitale avonturen cre√´ren. Van het bouwen van Minecraft-werelden tot het vertellen van Frozen-verhalen, de lessen bieden eenvoudige codes voor creatieve expressie.\nOf je nu ge√Ønspireerd bent door de creatieve bouwwerelden van Minecraft of de magische verhalen van Frozen, hier kun je leren hoe je jouw idee√´n tot leven kunt brengen met eenvoudige codes.\nOp code.org vind je boeiende lessen waarmee je de basis van coderen leert en stap voor stap begint te begrijpen hoe je virtuele werelden kunt maken. Of je nu droomt van het bouwen van digitale kastelen zoals in Minecraft of het vertellen van verhalen met je favoriete Frozen-personages, er is voor elk wat wils.\nDus, duik in de uitdagende wereld van coderen en ontdek de vele mogelijkheden die code.org te bieden heeft. Laat je creativiteit stromen en cre√´er jouw eigen digitale meesterwerken!\nbron: ChatGPT\nLeuke instructies Stap voor stap programmeer concepten leren\n","date":"November 30, 2023","permalink":"/onderwerpen/code-org/","title":"Code.org"},{"categories":null,"contents":"\nWe gaan aan de slag met Raspberry Pi Pico. Het kleine broertje van de Raspberry Pi waar we al eerder mee gewerkt hebben.\nWe gebruiken Thonny om mee te programmeren, dus het is handig als je die al hebt ge√Ønstalleerd: Thonny downloaden.\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWe gaan er vanuit dat je zelf een laptop meeneemt. Mocht dat niet kunnen, laat ons dat dan even weten, zodat we een leenlaptop voor je kunnen regelen.\nKinderen onder de 12 moeten worden begeleid door een ouder/verzorger.\nWanneer en waar? Zaterdag 13 januari van 12:00u tot 14:30u.\nWe zitten in bibliotheek Mari√´nburg.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"November 30, 2023","permalink":"/dojos/769919739667/","title":"#103: Raspberry Pi Pico + Thonny"},{"categories":null,"contents":"\nJÔªøe mag deze keer zelf kiezen!\nWÔªøe hebben natuurlijk wel allerlei instructies bij ons en ook draait de Ninja Chat server. Als je wilt kun je je eigen chat client maken.\nOf je werkt aan de Ontbijtkoekclicker, of aan een leuke Scratch opdracht, of toch liever iets met Python?\nKortom, aan jou de keuze!\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWanneer en waar? Zaterdag 4 november van 12:00u tot 14:30u.\nWe zitten in bibliotheek Zwanenveld.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"October 3, 2023","permalink":"/dojos/731355964377/","title":"#101: Kies je eigen onderwerp"},{"categories":null,"contents":"\nWe gaan aan de slag op code.org, een site met het doel om kinderen tot 17 jaar informatica te leren. Van die site hebben we een paar instructies uitgezocht die vooral geschikt zijn voor de jongere kinderen die kennis willen maken met programmeren. Bijvoorbeeld met Minecraft of AI als thema.\nBen je wat meer gevorderd, dan kun je ook met Python aan de slag.\nAlgemene info Bij CoderDojo Nijmegen leren jonge mensen, tussen de 7 en 17 jaar, om te programmeren, websites bouwen, apps ontwikkelen, programma‚Äôs te maken, games te maken en meer. Elke maand op een zaterdagmiddag behandelen we een ander onderwerp. CoderDojo maakt leren programmeren een leuke en sociale ervaring.\nWanneer en waar? Zaterdag 9 december van 12:00u tot 14:30u.\nWe zitten in bibliotheek Muntweg.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"October 3, 2023","permalink":"/dojos/731383296127/","title":"#102: code.org \u0026 Python"},{"categories":null,"contents":"\nWe gaan weer aan de slag met Processing. Mooie en kunstig animaties maken, of kleine spelletjes.\nWe hebben wat opdrachten die je in p5.js kunt doen, de Javascript versie van Processing, maar we hebben ook een spiekbriefje waarmee je zelf met Processing aan de slag kunt!\nVoorbereiding Neem een laptop en een goed humeur mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nWanneer en waar? Zaterdag 7 oktober van 12:00u tot 14:30u.\nWe zijn te gast bij Mosadex op Keizer Karelplein 32, 6511 NH Nijmegen.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"August 28, 2023","permalink":"/dojos/707945182097/","title":"#100: Processing"},{"categories":null,"contents":"\nEen live dojo in de buitenlucht! We gaan deze zomermaand unplugged dus zonder computers aan de slag. Dat betekent wedstrijdjes levend programmeren, puzzelen op de Turing Tumble en complete chaos met RoboRally.\nVoorbereiding HÔªøet is handig om de instructies voor Turing Tumble, Robo Rally en Levend Programmeren alvast door te nemen, zodat je direct aan de slag kunt:\nTuring Tumble: handleiding Robo Rally: handleiding Levend Programmeren: handleiding Houdt de weersverwachtingen in de gaten. Mocht het dreigen te gaan regenen, neem dan toch je laptop mee. We kunnen dan binnen terecht.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nWanneer en waar? Zaterdag 2 september 2023.\nTÔªøijd: 9:30 - 12:00 dus: van half 10 tot 12 uur!\nWÔªøe zijn te gast bij bibliotheek de Ster in Lent, Queenstraat 37-B, 6663 HA Nijmegen.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"August 11, 2023","permalink":"/dojos/696605855867/","title":"#99 Unplugged"},{"categories":null,"contents":"\nJÔªøe mag weer zelf kiezen!\nWÔªøe hebben natuurlijk wel allerlei instructies bij ons en ook draait de Ninja Chat server. Als je wilt kun je je eigen chat client maken.\nOf je werkt aan de Ontbijtkoekclicker, of aan een leuke Scratch opdracht, of toch liever iets met Python?\nKortom, aan jou de keuze!\nVoorbereiding Neem een laptop en een goed humeur mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nWanneer en waar? Zaterdag 1 juli van 12:00u tot 14:30u.\nWe zitten in bibliotheek Muntweg aan Muntweg 207, 6532 TH Nijmegen.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"June 28, 2023","permalink":"/dojos/663904043867/","title":"#98: Kies je eigen onderwerp"},{"categories":null,"contents":"\nWelkom bij de wereld van webontwikkeling, waar kleurrijke websites tot leven komen! Vandaag gaan we kennis maken met drie belangrijke talen die je zullen helpen om je eigen webpagina\u0026rsquo;s te bouwen: HTML, JavaScript en CSS.\nHTML, ook wel bekend als HyperText Markup Language, is als de skeletstructuur van een website. Het is de taal die je gebruikt om de inhoud van je pagina te structureren. Stel je voor dat je een huis bouwt en HTML de blauwdruk is. Het vertelt de browser hoe de verschillende elementen van je pagina moeten worden georganiseerd, zoals koppen, paragrafen, afbeeldingen en links. Met HTML kun je je creativiteit de vrije loop laten en je eigen unieke webpagina\u0026rsquo;s maken.\nJavaScript is de taal waarmee je je webpagina\u0026rsquo;s interactief kunt maken. Het voegt leven toe aan je statische HTML-structuur. Vergelijk het met de elektrische bedrading en schakelaars in je huis. Met JavaScript kun je dynamische elementen toevoegen, zoals interactieve knoppen, spelletjes, animaties en zelfs geavanceerdere functies, zoals het verwerken van formulieren of het laden van gegevens vanaf het internet. Het is de taal die je in staat stelt om met je gebruikers te communiceren en je website tot leven te brengen.\nCSS, oftewel Cascading Style Sheets, is de taal die je gebruikt om je webpagina\u0026rsquo;s er mooi en aantrekkelijk uit te laten zien. Stel je voor dat je het interieur van je huis decoreert met kleuren, meubels en gordijnen. CSS doet hetzelfde voor je webpagina\u0026rsquo;s. Met CSS kun je kleuren, lettertypen, lay-outs, achtergronden en andere visuele aspecten van je pagina aanpassen. Het helpt je om je eigen stijl en ontwerp toe te voegen aan je website, zodat deze er precies uitziet zoals jij wilt.\nSamen vormen HTML, JavaScript en CSS een krachtig trio waarmee je je eigen unieke websites kunt maken. Of je nu een leuke spelletjespagina wilt maken, een blog wilt starten of je creatieve kunstwerken wilt delen, met deze talen kun je je idee√´n tot leven brengen op het internet. Dus laten we aan de slag gaan en de magie van webontwikkeling ontdekken!\nbron: ChatGPT\nOnze instructies Javascript - Ninja-Chat\nWe gaan een chat programma maken! P5.js - Art\nKunst maken in de browser. ","date":"May 29, 2023","permalink":"/onderwerpen/javascript/","title":"HTML, Javascript \u0026 CSS"},{"categories":null,"contents":"\nWelkom in de wonderlijke wereld van programmeren, waar je je eigen avonturen kunt cre√´ren met behulp van de taal van slangen: Python!\nWist je Python is ontwikkeld door een Nederlander? Guido van Rossem bedacht het in 1991.\nPython is een programmeertaal die speciaal is ontworpen om programmeren leuk en toegankelijk te maken, zelfs voor kinderen zoals jij. Het is als een toverstaf waarmee je de computer instructies kunt geven om coole dingen te doen. Stel je voor dat je een dirigent bent die een symfonie van code dirigeert!\nWat Python zo geweldig maakt, is dat het een heel eenvoudige en leesbare syntax heeft. Het lijkt bijna op het schrijven van Engelse zinnen. In plaats van een toverformule uit je mouw te schudden, schrijf je een reeks instructies in Python om de computer te vertellen wat hij moet doen. Je kunt het gebruiken om spelletjes te maken, verhalen te schrijven, problemen op te lossen en zelfs robots te programmeren!\nMet Python kun je ook je creativiteit de vrije loop laten. Je kunt prachtige tekeningen maken, kleurrijke afbeeldingen en animaties cre√´ren, en zelfs muziek componeren. Het is als een artistiek palet waarop je je eigen digitale meesterwerken kunt schilderen.\nMaar Python is niet alleen leuk en creatief, het is ook een krachtige taal die door professionals over de hele wereld wordt gebruikt. Het wordt gebruikt in wetenschappelijk onderzoek, kunstmatige intelligentie, webontwikkeling en nog veel meer. Door Python te leren, leg je een stevige basis voor de toekomst, waarin technologie een steeds grotere rol speelt.\nDus, klaar om je programmeeravontuur te beginnen? Pak je toetsenbord en laat je fantasie de vrije loop met Python. Je zult versteld staan van de dingen die je kunt bereiken!\nbron: ChatGPT\nOnze instructies Python - Art\nWe gaan kunst maken met Python Turtle. Python - Raspberry Pi\nEen Raspberry Pi is een mini-computer waar je allerlei leuke dingen mee kunt doen. Je kan de Raspberry Pi als computer gebruiken. Daarnaast kun je er ook allerlei apparaatjes en elektronische schakelingen aan koppelen. We gaan met bewegingssensoren, afstandssensoren en een stappenmotor aan de slag. Python - Raspberry Pi Pico\nDe Raspberry Pi Pico is een microcontroller, wat betekent dat het een heel eenvoudige computer is. Je kunt er inputs op aansluiten, zoals lichtsensoren, en outputs zoals motoren en lampen. Python - Turtle\nDeze keer gaan we tekenen met Python Turtle. Wil je meer Python opdrachten doen? Dan vind je hier wat andere instructies die we je kunnen aanbevelen.\nRaspberry Pi Foundation Raad het getal Geheime berichten Turtley Geweldig Turtle sneeuwvlokken Maak een gezicht Krachtige patronen Meer van de Raspberry Pi Foundation: Python opdrachten.\n","date":"May 29, 2023","permalink":"/onderwerpen/python/","title":"Python"},{"categories":null,"contents":"\nWelkom in de fascinerende wereld van micro:bit, Maqueen en mBot - waar je kunt experimenteren, coderen en je eigen slimme apparaten kunt maken!\nMicro:bit is een kleine, programmeerbare computer die je kunt gebruiken om allerlei coole projecten te maken. Het heeft ingebouwde sensoren, LED-lampjes en knoppen, waardoor het een geweldig apparaat is om te leren programmeren en elektronica te verkennen. Je kunt het gebruiken om games te maken, te communiceren met andere apparaten en zelfs draagbare gadgets te bouwen.\nMaqueen en mBot zijn twee verschillende soorten robots die je kunt programmeren om te bewegen, obstakels te vermijden en zelfs met elkaar te communiceren. Ze zijn ontworpen om kinderen kennis te laten maken met robotica en programmeren op een leuke en interactieve manier. Met Maqueen en mBot kun je verschillende programmeertalen gebruiken, zoals Blockly en Python, om je robots taken te laten uitvoeren en avonturen te beleven.\nHet mooie van micro:bit, Maqueen en mBot is dat ze speciaal zijn ontworpen voor kinderen zoals jij. Ze zijn gemakkelijk te gebruiken en bieden een leuke en hands-on manier om te leren over technologie, wetenschap en creatief denken. Je kunt experimenteren, problemen oplossen en je eigen projecten bedenken. Het is als het worden van een uitvinder en een programmeur in √©√©n!\nMet micro:bit, Maqueen en mBot kun je je eigen slimme apparaten maken en de wereld om je heen verkennen. Of je nu een robot wilt bouwen die objecten kan detecteren en sorteren, een slimme verkeerslichtcontroller wilt maken of een interactief spel wilt cre√´ren - de mogelijkheden zijn eindeloos.\nDus, klaar om de wereld van micro:bit, Maqueen en mBot te verkennen? Pak je programmeer- en elektronicatools en laat je creativiteit de vrije loop. Ontdek hoe je de kracht van technologie kunt benutten en je eigen slimme apparaten kunt cre√´ren. Veel plezier en veel succes!\nbron: ChatGPT\nOnze instructies mBlock\nWe gaan werken met programmeeromgeving mBlock. Micro:Bit\nMicro:Bit is een piepklein computertje met superveel mogelijkheden om te programmeren. ","date":"May 29, 2023","permalink":"/onderwerpen/bots/","title":"Botjes"},{"categories":null,"contents":"\nWelkom in de spannende wereld van programmeren met de taal C! Met C kun je je eigen software maken en de controle hebben over de computer als een echte meesterprogrammeur.\nC is als de basis van veel moderne programmeertalen. Het is een krachtige taal waarmee je effici√´nte en snelle programma\u0026rsquo;s kunt schrijven. Stel je voor dat je een tovenaar bent die directe bevelen geeft aan de computer en deze precies doet wat jij wilt.\nMet C kun je verschillende soorten programma\u0026rsquo;s maken. Je kunt bijvoorbeeld spellen ontwerpen waarin je de hoofdrol speelt, programma\u0026rsquo;s schrijven die berekeningen uitvoeren en gegevens verwerken, of zelfs software ontwikkelen voor robots en andere geavanceerde systemen.\nC is een taal waarbij je precieze instructies moet geven aan de computer. Het is alsof je een puzzel oplost waarbij je elk stukje op de juiste plaats moet zetten. Je kunt variabelen gebruiken om gegevens op te slaan, functies schrijven om taken uit te voeren en controlestructuren gebruiken om beslissingen te nemen.\nHoewel C een krachtige taal is, kan het wat uitdagend zijn om te leren. Maar maak je geen zorgen, met doorzettingsvermogen en oefening kun je al snel de geheimen van C ontrafelen en meester worden in het programmeren.\nHet mooie van C is dat het de basis vormt voor vele andere programmeertalen en je een stevige basis geeft om verder te leren. Door C te leren, zul je beter begrijpen hoe computers werken en kun je gemakkelijker andere talen leren, zoals C++, Java en zelfs Python.\nDus, klaar om de wereld van C te betreden en een meesterprogrammeur te worden? Pak je toetsenbord en duik in de spannende wereld van codering. Ontdek hoe je je eigen software kunt maken en de computer kunt laten dansen op jouw bevel. Veel succes en veel programmeerplezier!\nbron: ChatGPT\nOnze instructies Arduino - een snelle introductie\nAlles wat je moet weten om gave dingen te maken ","date":"May 29, 2023","permalink":"/onderwerpen/c/","title":"C"},{"categories":null,"contents":"\nWelkom in de opwindende wereld van L√ñVE2D, waar je je eigen videogames kunt maken en de hoofdrol kunt spelen in je eigen avonturen!\nL√ñVE2D is een geweldig programma waarmee je je eigen interactieve en kleurrijke spellen kunt ontwerpen en spelen. Het is als een toverdoos vol creatieve mogelijkheden, waarin je je verbeelding de vrije loop kunt laten en je eigen digitale werelden kunt bouwen.\nMet L√ñVE2D kun je personages en objecten maken, levels ontwerpen en zelfs je eigen spelregels bepalen. Ben je dol op platformspellen waarbij je moet springen, rennen en obstakels ontwijken? Of misschien hou je meer van puzzelspellen waarbij je logisch moet nadenken om vooruit te komen? Met L√ñVE2D kun je elk type spel maken dat je maar kunt bedenken!\nHet mooie van L√ñVE2D is dat het een gemakkelijk te leren programmeertaal heeft. Je hoeft geen expert te zijn om aan de slag te gaan. Het is als het samenstellen van puzzelstukjes om je spel tot leven te brengen. Je kunt verschillende blokken code combineren om de personages te laten bewegen, geluiden af te spelen, vijanden te verslaan en nog veel meer.\nL√ñVE2D is niet alleen leuk om mee te spelen, maar het is ook een geweldige manier om vaardigheden zoals probleemoplossing en creativiteit te ontwikkelen. Je kunt je eigen verhalen vertellen, personages ontwerpen en je eigen regels bepalen. Het is als het worden van een game-ontwerper en programmeur in √©√©n!\nDus, ben je klaar om je eigen game-avonturen te cre√´ren met L√ñVE2D? Duik in de wereld van creatie en innovatie. Laat je fantasie de vrije loop en bouw je eigen digitale meesterwerken. Met L√ñVE2D ben jij de regisseur van je eigen gamewereld. Veel plezier en veel succes!\nbron: ChatGPT\nOnze instructies L√∂ve2d - Blocks\nWe gaan met 2D game framework L√∂ve2D een spel met vallende blokken maken. L√∂ve2D - Shooter\nWe gaan met 2D game ‚Äúframework‚Äù L√∂ve2D een shooter bouwen. L√∂ve2D - Snake\nWe gaan met 2D game framework L√∂ve2D het klassieke spel Snake bouwen. ","date":"May 29, 2023","permalink":"/onderwerpen/love2d/","title":"L√∂ve2D"},{"categories":null,"contents":"\nWelkom in de fascinerende wereld van machine learning, waar computers kunnen leren en slimme beslissingen kunnen nemen, net als jij!\nMachine learning is een spannend gebied van de technologie waarbij computers worden geprogrammeerd om te leren en zichzelf te verbeteren. Het is als het hebben van een superintelligente assistent die steeds slimmer wordt naarmate hij meer informatie krijgt.\nStel je voor dat je een magische bril hebt waarmee je patronen en trends kunt zien die anderen misschien niet opmerken. Dat is wat machine learning doet voor computers. Het helpt ze om grote hoeveelheden gegevens te analyseren, patronen te herkennen en voorspellingen te doen.\nMachine learning kan ons helpen op veel verschillende manieren. Het kan ons helpen om betere aanbevelingen te krijgen voor films of boeken die we leuk vinden, het kan ons helpen om robots te bouwen die kunnen leren en zich aanpassen aan verschillende taken, en het kan zelfs helpen bij medisch onderzoek om ziektes eerder op te sporen en betere behandelingen te vinden.\nHet mooie van machine learning is dat het geen geheimzinnige magie is, maar iets dat we kunnen begrijpen en zelf kunnen leren. Je kunt leren hoe je een computer kunt trainen om bepaalde taken uit te voeren door hem voorbeelden te geven en feedback te geven. Het is als het trainen van een huisdier, maar in plaats van een hond, leer je een computer!\nMachine learning wordt steeds belangrijker in onze wereld, omdat het ons kan helpen problemen op te lossen en nieuwe mogelijkheden te ontdekken. Door machine learning te leren, kun jij ook een deel uitmaken van deze spannende ontwikkeling en misschien wel de volgende grote doorbraak in technologie realiseren.\nDus, klaar om je in de wereld van machine learning te storten? Zet je nieuwsgierige pet op en laat je verbeelding de vrije loop. Ontdek hoe computers kunnen leren en help ons de wereld een slimmere plek te maken!\nbron: ChatGPT\nOnze instructies Machine Learning - beeldherkenning\nHoe herkent een computer beeld? ","date":"May 29, 2023","permalink":"/onderwerpen/machine-learning/","title":"Machine Learning"},{"categories":null,"contents":"\nWelkom in de spannende wereld van webontwikkeling, waar je je eigen dynamische en interactieve websites kunt bouwen met PHP!\nPHP is een programmeertaal die speciaal is ontworpen om websites tot leven te brengen. Het is als een magische pen waarmee je de computer instructies kunt geven om coole dingen te doen. Stel je voor dat je een tovenaar bent die wonderen verricht met zijn code!\nWat PHP zo geweldig maakt, is dat het je in staat stelt om dynamische webpagina\u0026rsquo;s te maken. In plaats van statische inhoud die altijd hetzelfde blijft, kun je met PHP ervoor zorgen dat je website zich aanpast aan de gebruiker. Je kunt gebruikersnamen en wachtwoorden verwerken, interactieve formulieren maken en zelfs gegevens opslaan in een database. Het is als het cre√´ren van je eigen interactieve speeltuin op het internet!\nHet mooie aan PHP is dat het gemakkelijk te leren is. Je kunt kleine stukjes code schrijven en ze stap voor stap opbouwen tot iets groots. Het is als het oplossen van een puzzel, waarbij je elke keer een stukje toevoegt om het geheel compleet te maken. Met PHP kun je ook je creativiteit de vrije loop laten. Je kunt je eigen blogs maken, je eigen fotoalbums delen en zelfs je eigen kleine online winkel opzetten!\nPHP wordt ook veel gebruikt door professionals over de hele wereld. Het is de kracht achter populaire websites zoals Facebook en Wikipedia. Door PHP te leren, krijg je een waardevolle vaardigheid die je in de toekomst kan helpen bij het cre√´ren van geweldige dingen en het bouwen van je eigen online projecten.\nDus, ben je klaar om de wereld van webontwikkeling te betreden met PHP? Pak je toetsenbord en laat je creativiteit de vrije loop. Met PHP kun je je eigen interactieve websites bouwen en de magie van het web tot leven brengen!\nbron: ChatGPT\nOnze instructies Web - Development - Php\nWe gaan programmeren met PHP. ","date":"May 29, 2023","permalink":"/onderwerpen/php/","title":"PHP"},{"categories":null,"contents":"\nWelkom in de wondere wereld van creativiteit en plezier, waar je je eigen interactieve verhalen, spellen en animaties kunt maken met Scratch!\nScratch is een programma dat speciaal is ontworpen voor kinderen zoals jij, om te leren programmeren op een leuke en visuele manier. Het is als een digitale speeltuin waar je kunt spelen met blokken code en je verbeelding de vrije loop kunt laten.\nIn plaats van het typen van ingewikkelde code, gebruik je in Scratch kleurrijke blokken die je kunt slepen en neerzetten om commando\u0026rsquo;s te geven aan je personages en objecten. Het is net als het bouwen van een virtueel LEGO-huis, waarbij je verschillende blokken combineert om je eigen interactieve wereld te maken.\nMet Scratch kun je je eigen verhalen vertellen door personages te animeren, achtergronden te tekenen en dialogen te cre√´ren. Je kunt ook je eigen spellen maken, waarbij je punten verdient, obstakels overwint en missies voltooit. Wil je een dansfeestje organiseren of een concert met zelfgemaakte muziek? Geen probleem! Scratch heeft ook ingebouwde instrumenten en geluidseffecten om je creaties tot leven te brengen.\nHet beste van alles is dat Scratch niet alleen een creatieve speeltuin is, maar ook een gemeenschap van gelijkgestemde jonge programmeurs. Je kunt je projecten delen en inspiratie opdoen van andere kinderen over de hele wereld. Samen kun je leren, experimenteren en elkaar aanmoedigen om nog verder te gaan.\nDus waar wacht je nog op? Duik in de wereld van Scratch en ontdek de onbegrensde mogelijkheden om je eigen interactieve creaties te maken. Of je nu een verhalenverteller, een game-ontwerper of een digitale kunstenaar wilt worden, met Scratch kun je je fantasie de vrije loop laten en de ster van je eigen digitale avontuur worden!\nbron: ChatGTP\nOnze instructies Scratch - Art\nWe gaan kunst maken met Scratch. Scratch - Snake\nWe gaan met Scratch het klassieke spel Snake bouwen. Scratch - Space shooter\nJe gaat met Scratch een ‚Äúspace shooter‚Äù bouwen. Scratch - Videosensing\nWe gaan aan de slag met Scratch en video sensing. Meer over Scratch Je vindt meer informatie over Scratch en idee√´n over wat je er mee kunt doen op de site van Scratch: https://scratch.mit.edu/ideas.\n","date":"May 29, 2023","permalink":"/onderwerpen/scratch/","title":"Scratch"},{"categories":null,"contents":"\nJÔªøe mag deze keer zelf kiezen!\nWÔªøe hebben natuurlijk wel allerlei instructies bij ons en ook draait de Ninja Chat server. Als je wilt kun je je eigen chat client maken.\nOf je werkt aan de Ontbijtkoekclicker, of aan een leuke Scratch opdracht, of toch liever iets met Python?\nKortom, aan jou de keuze!\nVoorbereiding Neem een laptop en een goed humeur mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nWanneer en waar? Zaterdag 3 juni van 11:00u tot 13:30u.\nWe zitten in bibliotheek de Biezantijn aan de Waterstraat 146 in Nijmegen.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"May 21, 2023","permalink":"/dojos/638536328347/","title":"#97: Kies je eigen onderwerp"},{"categories":null,"contents":"\nWhatsApp en SnapChat. Je gebruikt het misschien dagelijks.\nWe gaan deze dojo zelf een chat app maken!\nMet HTML, CSS en JavaScript maken we een app waarmee je met de andere kinderen in de dojo kunt chatten.\nJe bepaalt zelf hoe je app er uit ziet en misschien verzin je wel iets slims om automatisch te antwoorden?\nMocht dit wat te hoog gegrepen zijn, dan kun je altijd √©√©n van onze andere instructies oppakken. zoals bijvoorbeeld een Scratch opdracht.\nVoorbereiding Neem een laptop mee. Een browser heb je vast. Verder is het handig om een editor als Visual Studio Code ge√Ønstalleerd te hebben.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het vereist dat een ouder of verzorger je kan begeleiden tijdens de dojo.\nWanneer en waar? Zaterdag 6 mei van 12:00u tot 14:30u.\nWe zitten in bibliotheek Zwanenveld.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"April 23, 2023","permalink":"/dojos/96-ninja-chat/","title":"#96: Ninja Chat"},{"categories":null,"contents":"\nChatGPT, Dall-E, Stable Diffusion en MidJourney zijn voorbeelden van grote Machine Learning modellen die op het moment veel in het nieuws zijn.\nDuik in de wereld van machine learning tijdens onze volgende Dojo! Leer de basisprincipes van machine learning in Scratch, ontdek AI-beeldgeneratie en ChatGPT, en krijg de kans om vragen te stellen aan onze mentoren. Misschien kunnen we het gebruik van ChatGPT samen uitproberen?\nKom je ook?\nVoorbereiding Neem een laptop en een goed humeur mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nWanneer en waar? Zaterdag 1 april van 12:00u tot 14:30u.\nWe zitten in De Klinker - de Grote Broek aan de Van Broeckhuysenstraat 46, 6511 PK Nijmegen\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"March 21, 2023","permalink":"/dojos/95-machine-learning/","title":"#95: Machine Learning"},{"categories":null,"contents":"\nWe gaan weer aan de slag met Processing. Mooie en kunstig animaties maken, of kleine spelletjes.\nWe hebben wat opdrachten die je in p5.js kunt doen, de Javascript versie van Processing, maar we hebben ook een spiekbriefje waarmee je zelf met Processing aan de slag kunt!\nVoorbereiding Neem een laptop en een goed humeur mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nCoderDojo en Corona We houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 4 maart van 11:00u tot 13:30u.\nWe zitten in bibliotheek de Biezantijn aan de Waterstraat 146 in Nijmegen.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"February 20, 2023","permalink":"/dojos/94-processing/","title":"#94: Processing"},{"categories":null,"contents":"\nDeze maand gaan we met L√∂ve2D aan de slag en gaan we games maken. L√∂ve2D is een 2D game framework gebaseerd op de programmeertaal Lua.\nJÔªøe kunt kiezen uit een shooter met vliegtuigen. Of je maakt het spelletje Snake waarbij een slang appels eet. Of je maakt een variant van Tetris. Het spel waarbij je blokjes met verschillende vormen in elkaar kunt laten vallen.\nVoorbereiding Neem een laptop mee. Een browser heb je vast. Verder is het handig om een editor als Visual Studio Code ge√Ønstalleerd te hebben.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het vereist dat een ouder of verzorger je kan begeleiden tijdens de dojo.\nWanneer en waar? Zaterdag 4 februari van 12:00u tot 14:30u.\nWe zitten in bibliotheek Zwanenveld.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"January 23, 2023","permalink":"/dojos/93-games-maken-met-love2d/","title":"#93: Games maken met L√∂ve2D"},{"categories":null,"contents":"We gaan met 2D game framework L√∂ve2D een spel met vallende blokken maken.\nDe regels Er zijn 7 verschillende stukken. Elk stuk bestaat uit 4 kleinere blokken.\nStukken vallen vanaf boven het speelveld. De speler kan het stuk verplaatsen naar links en rechts en het stuk ronddraaien. Als een stuk is geland, valt er een volgend stuk.\nBoven het speelveld wordt de vorm van het volgende stuk dat gaat vallen getoond.\nAls er een volledig gesloten rij van blokken is gevormd van links naar rechts op het speelveld, verdwijnt het en schuiven alle blokken erboven 1 rij naar beneden.\nHet spel eindigt als een nieuw stuk direct op een al liggend stuk terecht zou komen.\nControls toets actie pijl links beweeg links pijl rechts beweeg rechts z draai tegen de klok in x draai met de klok mee c val op liggende blokken Overzicht Een rooster bevat de blokken die al zijn gevallen. Een vak in het rooster kan leeg zijn of gevuld met een blok van een bepaalde kleur.\nTekst ' ' (spatie) is een leeg vak zonder blok en 'i', 'j', 'l', 'o', 's', 't' en 'z' zijn vakken met een blok met verschillende kleuren.\nAlle verschillende stukken worden in het rooster opgeslagen met de hoe ze gedraaid waren toen ze vielen.\nEen vallend stuk wordt opgeslagen met een getal dat aangeeft welk type stuk het is, hoe het gedraaid is en wat de positie is in het rooster. Voor de positie worden X en Y waarden gebruikt.\nEen nieuw stuk wordt boven het rooster getoond, maar niet als er te weinig voor is door al gestapelde blokken. In dat geval is het spel afgelopen.\nDe speler kan de stukken verplaatsen naar links en rechts, maar niet als het een stuk dat al gestapeld is overlapt. Een stuk kan ook niet buiten het rooster verplaatst worden.\nAls er wat tijd is verlopen, verplaatst het stuk √©√©n rij blokken naar beneden. Dit gebeurt alleen als de nieuwe positie van het stuk niet overlapt met al gestapelde blokken en niet buiten het rooster valt.\nAls knop z of x wordt ingedrukt, draait het stuk tegen de klok in of met de klok mee. Maar niet als het stuk dan overlapt met al gestapelde blokken of buiten het rooster valt.\nAls de val knop c wordt ingedrukt, gaat het stuk sneller naar beneden, totdat het landt op al geplaatste stukken.\nAls het stuk is geland, wordt een nieuw stuk gemaakt boven het rooster.\nDe 7 verschillende stukken worden in een willekeurige volgorde aangeboden.\nProgrammeren Voor het programmeren zelf heb je alleen een editor zoals bijvoorbeeld Visual Studio Code nodig. Maar om het programma uit te voeren, heb je het L√∂ve2D programma nodig. Deze kun je downloaden vanaf de site https://love2d.org/. Kijk voor meer informatie over het installeren op /instructies/love2d-shooter/#installatie-l√∂ve.\nAls je L√∂ve2D hebt ge√Ønstalleerd, open je een terminal of cmd op Windows en zou je love.exe moeten kunnen starten.\nBij het starten van het script is het belangrijk om te onthouden dat je de directory meegeeft aan Love en niet main.lua.\nDus:\nlove.exe blocks/ Hierbij bevat blocks het bestand main.lua waarin we de code schrijven van de volgende hoofdstukken.\nHet venster tekenen We beginnen in een lege conf.lua met:\nfunction love.conf(t) t.window.width = 20 * 14 t.window.height = 20 * 25 end conf.lua\nen een lege main.lua.\nAls je nu love.exe blocks/ uitvoert, krijg je een leeg rechthoekig scherm.\nHet rooster tekenen Voor ieder blok in het speelveld wordt een vierkant getekend.\nZet de volgende code in main.lua:\nfunction love.draw() for y = 1, 18 do for x = 1, 10 do local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end end end main.lua Het rooster inkleuren De achtergrondkleur en de kleur van een leeg vak worden ingesteld.\nVoeg functie love.load() toe aan main.lua, boven functie love.draw() die er al in staat:\nfunction love.load() love.graphics.setBackgroundColor(255, 255, 255) end main.lua\nPas nu functie love.draw() aan:\nfunction love.draw() for y = 1, 18 do for x = 1, 10 do -- voeg toe: love.graphics.setColor(.87, .87, .87) -- local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end end end main.lua De gevallen blokken bewaren Het rooster voor de gevallen blokken is gemaakt en elk blok wordt als ' ' (spatie) gezet wat betekend dat het vak leeg is.\nWe gaan de breedte en hoogte van het rooster gebruiken om de blokken te tekenen, dus we zetten de waarden 10 en 18 in variabelen.\nPas de functies aan met:\nfunction love.load() love.graphics.setBackgroundColor(255, 255, 255) -- voeg onderstaande toe: gridXCount = 10 gridYCount = 18 inert = {} for y = 1, gridYCount do inert[y] = {} for x = 1, gridXCount do inert[y][x] = \u0026#39; \u0026#39; end end -- end function love.draw() -- vervang: for y = 1, 18 do for x = 1, 10 do -- door: for y = 1, gridYCount do for x = 1, gridXCount do -- end main.lua\nDe kleur van de blokken De kleur van de blokken die we gaan tekenen wordt bepaald door het type.\nOm dit testen, zetten we verschillende typen blokken in het rooster.\nDe types geven we aan met een letter: i, j, l, o.. etc. Vervolgens koppelen we een kleur aan elk type.\nBijvoorbeeld:\ni = {.47, .76, .94}, Maak de volgende aanpassingen:\nfunction love.load() -- voeg toe: inert[18][1] = \u0026#39;i\u0026#39; inert[17][2] = \u0026#39;j\u0026#39; inert[16][3] = \u0026#39;l\u0026#39; inert[15][4] = \u0026#39;o\u0026#39; inert[14][5] = \u0026#39;s\u0026#39; inert[13][6] = \u0026#39;t\u0026#39; inert[12][7] = \u0026#39;z\u0026#39; -- end function love.draw() for y = 1, gridYCount do for x = 1, gridXCount do -- vervang: love.graphics.setColor(.87, .87, .87) -- door dit: local colors = { [\u0026#39; \u0026#39;] = {.87, .87, .87}, i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, } local block = inert[y][x] local color = colors[block] love.graphics.setColor(color) -- tot hier toe. local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) -- end end end main.lua De stukken opslaan Een puzzelstuk bestaat uit verschillende blokken. We slaan de variaties van puzzelstuk op als een nieuw raster. In dit raster kunnen we ook de gedraaide versies van het puzzelstuk bewaren.\n{ {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, } Elk puzzelstuk kan 4 varianten hebben, want hij kan 4 kanten op gedraaid zijn. We slaan dus 4 varianten op voor elk puzzelstuk. In het geval van de rechte lijn zijn dit er eigenlijk maar 2. Deze vorm is namelijk symmetrisch over 1 as. De kubus heeft maar 1 variant. Deze is namelijk symmetrisch over 2 assen. De rechte lijn ziet er als volgt uit:\n{ { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, } Dit zijn alle puzzelstukken; voeg deze toe aan functie love.load():\nfunction love.load() love.graphics.setBackgroundColor(255, 255, 255) pieceStructures = { { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;i\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;j\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;l\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;t\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;t\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;s\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;s\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;s\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, { { {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;z\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, { {\u0026#39; \u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;z\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39;z\u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, {\u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;, \u0026#39; \u0026#39;}, }, }, } main.lua\nHet vallende stuk opslaan Er kan altijd maar een puzzelstuk tegelijkertijd vallen. We kunnen dit puzzelstuk opslaan met de variabelen pieceType en pieceRotation. pieceType bevat welk stuk het is (lijn, blokje, etc). pieceRotation bevat hoe het stuk gedraaid is.\nfunction love.load() -- voeg toe aan het einde van de functie: pieceType = 1 pieceRotation = 1 -- end main.lua\nHet stuk tekenen Elk puzzelstuk wordt getekend door langs elk vakje in het rooster te gaan en de blokken een voor een in te kleuren.\nDe kleur is afhankelijk van het type blok.\nfunction love.draw() -- voeg dit hele stuk code toe onderaan deze functie for y = 1, 4 do for x = 1, 4 do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then local colors = { i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, } local color = colors[block] love.graphics.setColor(color) local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end end end -- end main.lua\nEn verwijder dit stuk uit functie love.load():\ninert[18][1] = \u0026#39;i\u0026#39; inert[17][2] = \u0026#39;j\u0026#39; inert[16][3] = \u0026#39;l\u0026#39; inert[15][4] = \u0026#39;o\u0026#39; inert[14][5] = \u0026#39;s\u0026#39; inert[13][6] = \u0026#39;t\u0026#39; inert[12][7] = \u0026#39;z\u0026#39; main.lua\nCode vereenvoudigen De code voor het tekenen van een stilstaand blok lijkt erg op de code voor het tekenen van een vallend blok. We voegen daarom de functie drawBlock toe en verplaatsen de code in de twee for-loops er naartoe.\nVervang alle code in love.draw() met deze code:\nfunction love.draw() local function drawBlock(block, x, y) local colors = { [\u0026#39; \u0026#39;] = {.87, .87, .87}, i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, } local color = colors[block] love.graphics.setColor(color) local blockSize = 20 local blockDrawSize = blockSize - 1 love.graphics.rectangle( \u0026#39;fill\u0026#39;, (x - 1) * blockSize, (y - 1) * blockSize, blockDrawSize, blockDrawSize ) end for y = 1, gridYCount do for x = 1, gridXCount do drawBlock(inert[y][x], x, y) end end for y = 1, 4 do for x = 1, 4 do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x, y) end end end end main.lua\nHet stuk draaien Wanneer we op de x-toets drukken willen wat dat het stuk draait.\npieceRotation bevat een getal dat de draaiing aangeeft. 1 is geen draaiing, 2 is 90¬∞ met de klok mee en 3 is 180¬∞.\nAls het rotation getal hoger is dan de verschillende draai posities (4, 2 of 1). Dan wordt het getal terug gezet naar 1.\nAls we op z-toets drukken willen we dat het het stuk de andere kant op draait. Dit doen we door de waarde in pieceRotation met 1 te verlagen.\nAls het getal lager wordt dan 0. Zetten we het weer terug naar 1.\nVoeg dit stuk code toe onderaan het bestand:\nfunction love.keypressed(key) if key == \u0026#39;x\u0026#39; then pieceRotation = pieceRotation + 1 if pieceRotation \u0026gt; #pieceStructures[pieceType] then pieceRotation = 1 end elseif key == \u0026#39;z\u0026#39; then pieceRotation = pieceRotation - 1 if pieceRotation \u0026lt; 1 then pieceRotation = #pieceStructures[pieceType] end end end main.lua\nDe stukken testen We willen graag de code testen. Daarom voegen we toe dat we het puzzelstuk kunnen veranderen met de omhoog en omlaag pijltjestoetsen.\nDe tijdelijke code onderaan functie love.keypressed(key):\nfunction love.keypressed(key) -- vervang laatste twee \u0026#34;end\u0026#34; regels met onderstaande tijdelijke code: elseif key == \u0026#39;down\u0026#39; then pieceType = pieceType + 1 if pieceType \u0026gt; #pieceStructures then pieceType = 1 end pieceRotation = 1 elseif key == \u0026#39;up\u0026#39; then pieceType = pieceType - 1 if pieceType \u0026lt; 1 then pieceType = #pieceStructures end pieceRotation = 1 end -- end main.lua\nAls je hebt gezien dat de stukken veranderen, kun je de net toegevoegde code weer verwijderen.\nDe positie van het vallende stuk bijhouden We bewaren de positie van het vallende puzzelstuk op in het rooster en we tekenen het puzzelstuk op die positie.\nfunction love.load() -- voeg deze regels toe onderaan deze functie pieceX = 3 pieceY = 0 -- end En het tekenen van het blok op de juiste positie:\nfunction love.draw() -- vervang: drawBlock(block, x, y) -- met: drawBlock(block, x + pieceX, y + pieceY) -- end main.lua\nHet stuk verplaatsen We gaan nu de linker en rechter pijltjestoetsen gebruiken om het stuk te verplaatsen.\nVoeg de volgende regels toe onderaan love.keypressed(key):\nfunction love.keypressed(key) -- vervang de een na laatste \u0026#34;end\u0026#34; met: elseif key == \u0026#39;left\u0026#39; then pieceX = pieceX - 1 elseif key == \u0026#39;right\u0026#39; then pieceX = pieceX + 1 end -- end main.lua\nTimer We willen dat elke 0.5 seconden het puzzelstuk valt.\nWe maken daarom een timer variabele, die we steeds met dt (delta time: de tijd die verstreken is) verhogen.\nAls de waarde van timer gelijk aan 0.5 of hoger is, zetten we het terug naar 0.\nfunction love.load() -- onderaan deze functie: timer = 0 -- end En een nieuwe functie onderaan het bestand:\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 -- tijdelijk; kijk naar de console/cmd window voor een tick elke halve seconde print(\u0026#39;tick\u0026#39;) -- end end main.lua\nNa het testen mag je print('tick') weer weghalen.\nStukken vallen We gebruiken de timer om het stuk elke 0.5 seconden verder naar beneden te laten vallen.\nDe waarde van pieceY wordt met 1 verhoogd om het stuk 1 regel lager te tekenen:\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 -- voeg toe: pieceY = pieceY + 1 -- end end main.lua\nLinker, rechter en onderrand van het rooster We willen voorkomen dat de puzzelstukken links of rechts van het scherm af kunnen bewegen. Daarom checken we altijd eerst of alle blokken nog wel in het speelveld zijn.\nWe willen deze check vaker uitvoeren, daarom stoppen we het in een functie. Dan kunnen we het makkelijk herbruiken. De functie heeft de positie en rotatie nodig. De functie geeft true of false terug om aan te geven of we mogen bewegen of draaien.\nWe noemen de functie: canpieceMove(testX, testY, testRotation). Voor nu zal de functie alleen true teruggeven, dan kunnen we namelijk de functie in de rest van de code verwerken.\nWe passen de code aan zodat de check functie eerst wordt uitgevoerd, voordat we bewegen of draaien.\nfunction love.load() -- voeg aan het einde van de functie toe: function canPieceMove(testX, testY, testRotation) return true end -- end function love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 -- vervang: pieceY = pieceY + 1 -- door: local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY end -- end end function love.keypressed(key) elseif key == \u0026#39;left\u0026#39; then -- vervang: pieceX = pieceX - 1 -- door: local testX = pieceX - 1 if canPieceMove(testX, pieceY, pieceRotation) then pieceX = testX end -- elseif key == \u0026#39;right\u0026#39; then -- vervang: pieceX = pieceX + 1 -- door: local testX = pieceX + 1 if canPieceMove(testX, pieceY, pieceRotation) then pieceX = testX end -- end end main.lua\nLinks We beginnen met links checken. Als het blok niet leeg is, en de x positie lager is dan 1, geeft de functie false terug.\nfunction love.load() -- vervang functie canPieceMove in zijn geheel door: function canPieceMove(testX, testY, testRotation) for y = 1, 4 do for x = 1, 4 do if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and (testX + x) \u0026lt; 1 then return false end end end return true end -- end main.lua\nCode vereenvoudigen Het aantal blokken van elk puzzelstuk op de X en Y worden herbruikt uit het tekenen. We stoppen deze waardes in variabelen.\nfunction love.load() -- vervang functie canPieceMove weer, maar nu in zijn geheel door: pieceXCount = 4 pieceYCount = 4 function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and (testX + x) \u0026lt; 1 then return false end end end return true end -- end function love.draw() -- vervang: for y = 1, 4 do for x = 1, 4 do -- door: for y = 1, pieceYCount do for x = 1, pieceXCount do -- local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x + pieceX, y + pieceY) end end end end main.lua\nRechts We gaan nu rechts checken. Als het blok niet leeg is, en de x positie groter is dan het grid, geeft de functie false terug.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do -- vervang if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and (testX + x) \u0026lt; 1 then return false end -- door: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ((testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount) then return false end -- end end return true end end main.lua\nOnderkant Het puzzelstuk moet stoppen als het de onderkant aanraak. Als de onderkant van het puzzelstuk lager is dan de onderkant van het veld geeft de functie false terug.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do -- vervang: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ((testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount) then return false end -- door: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount ) then return false end -- end end return true end end main.lua\nControle op botsingen Als er al een ander puzzelstuk is, kan het puzzelstuk daar niet naartoe bewegen. Daarom checken we of er al een blok is op die plek. Als dat zo is, geeft de functie ook false terug.\nWe testen dit door zelf een blokje op het rooster te zetten.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and -- vervang: ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount ) -- door: ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount or inert[testY + y][testX + x] ~= \u0026#39; \u0026#39; ) -- then return false end end end return true end -- tijdelijk, om toegevoegde voorwaarde te testen inert[8][5] = \u0026#39;z\u0026#39; -- end main.lua\nAls het stuk valt, wordt het geblokkeerd door het blok. Schuif het stuk eens naar links of rechts. Wat gebeurt er?\nVerwijder na het testen de tijdelijke code.\nCode vereenvoudigen De posities van de blokken die we testen kunnen we herbruiken. We stoppen deze in variabelen.\nfunction love.load() function canPieceMove(testX, testY, testRotation) for y = 1, pieceYCount do for x = 1, pieceXCount do -- vervang: if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ( (testX + x) \u0026lt; 1 or (testX + x) \u0026gt; gridXCount or (testY + y) \u0026gt; gridYCount or inert[testY + y][testX + x] ~= \u0026#39; \u0026#39; ) then return false end -- door: local testBlockX = testX + x local testBlockY = testY + y if pieceStructures[pieceType][testRotation][y][x] ~= \u0026#39; \u0026#39; and ( testBlockX \u0026lt; 1 or testBlockX \u0026gt; gridXCount or testBlockY \u0026gt; gridYCount or inert[testBlockY][testBlockX] ~= \u0026#39; \u0026#39; ) then return false end -- end end return true end end main.lua\nSneller vallen Als de speler c indrukt laten we het puzzelstuk snel vallen. Zolang c is ingedrukt verhogen we de Y positie met 1 totdat het puzzelstuk iets raakt.\nfunction love.keypressed(key) -- voeg elseif key == \u0026#39;c\u0026#39; then while canPieceMove(pieceX, pieceY + 1, pieceRotation) do pieceY = pieceY + 1 end -- toe voor de √©√©n na laatste \u0026#34;end\u0026#34; end end main.lua\nEen stuk terugzetten Als de timer tikt, en het puzzelstuk niet verder kan bewegen, resetten we de positie en rotatie en type.\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 local testY = pieceY + 1 -- vervang: if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY end -- door: if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 end -- end end main.lua\nCode vereenvoudigen We resetten het puzzelstuk vaker, dus we stoppen de code in een functie om her te gebruiken.\nfunction love.load() -- voeg toe aan einde van functie function newPiece() pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 end newPiece() -- end function love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else -- vervang: pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 -- door: newPiece() -- end end end main.lua\nEen reeks met volgende stukken We maken nu een sequence (volgorde) waarin de puzzelstukken gaan vallen. We slaan deze op als een tabel met getallen die aangeven welk puzzelstuk het is.\nWe stoppen alle verschillende nummers/puzzelstuk types in de tabel op een willekeurige positie.\nWe testen dit door een reeks te maken en te printen als je op s drukt\nfunction love.load() -- voeg toe aan einde van functie function newSequence() sequence = {} for pieceTypeIndex = 1, #pieceStructures do local position = love.math.random(#sequence + 1) table.insert( sequence, position, pieceTypeIndex ) end end newSequence() -- end function love.keypressed(key) -- tijdelijke code elseif key == \u0026#39;s\u0026#39; then newSequence() print(table.concat(sequence, \u0026#39;, \u0026#39;)) -- end end main.lua\nResultaat van drukken op knop s in tijdelijke code:\n3, 2, 4, 1, 7, 5, 6\nVerwijder de tijdelijke code na het testen.\nEen nieuw stuk uit de reeks Wanneer er een nieuw puzzelstuk wordt gemaakt, halen we de vorige uit de reeks en herbruiken we het.\nAls de reeks leeg is, is maken we een nieuwe.\nLet op! We verplaatsen de newPiece functie naar onder de newSequence functie.\nfunction love.load() -- vervang: function newPiece() pieceX = 3 pieceY = 0 pieceType = 1 pieceRotation = 1 end -- door: function newPiece() pieceX = 3 pieceY = 0 pieceRotation = 1 pieceType = table.remove(sequence) if #sequence == 0 then newSequence() end end -- newPiece() end main.lua\nGevallen stukken bewaren Als een stuk is gevallen, worden ze apart gezet en bewaard.\nElk blok in het stuk wordt bekeken en als het niet leeg is, wordt het blok als bezet gezet.\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= 0.5 then timer = 0 local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else -- voeg toe for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then inert[pieceY + y][pieceX + x] = block end end end -- newPiece() end end end main.lua\nEen nieuw stuk direct na landing vorige Als een stuk is gevallen, wordt de timer direct opnieuw ingesteld, zodat een volgende stuk direct wordt gemaakt.\nfunction love.load() -- vervang: pieceY = 0 timer = 0 pieceXCount = 4 -- door: pieceY = 0 timer = 0 timerLimit = 0.5 pieceXCount = 4 -- end function love.update(dt) -- vervang: timer = timer + dt if timer \u0026gt;= 0.5 then -- door: timer = timer + dt if timer \u0026gt;= timerLimit then -- end function love.keypressed(key) elseif key == \u0026#39;c\u0026#39; then -- vervang: while canPieceMove(pieceX, pieceY + 1, pieceRotation) do pieceY = pieceY + 1 end -- door: while canPieceMove(pieceX, pieceY + 1, pieceRotation) do pieceY = pieceY + 1 timer = timerLimit end -- end end main.lua\nVolle rijen vinden Elke rij wordt gecontroleerd. Als er geen legen blokken in de rij zijn, is de rij compleet.\nOm te controleren of het werkt worden complete rijen geprint naar de console.\nfunction love.update(dt) timer = timer + dt if timer \u0026gt;= timerLimit then timer = 0 local testY = pieceY + 1 if canPieceMove(pieceX, testY, pieceRotation) then pieceY = testY else for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then inert[pieceY + y][pieceX + x] = block end end end -- voeg toe: for y = 1, gridYCount do local complete = true for x = 1, gridXCount do if inert[y][x] == \u0026#39; \u0026#39; then complete = false break end end -- tijdelijke code if complete then print(\u0026#39;Complete row: \u0026#39;..y) end -- end -- newPiece() end end end main.lua\nVolle rijen verwijderen Als een rij compleet is,\nIf the row is complete, the rows from the complete row to the row second from the top are looped through.\nEach block in the row is looped through and set to the value of the block above it. Because there is nothing above the top row it doesn\u0026rsquo;t need to be looped through.\nThe top row is then set to all empty blocks.\nDe volledige code tot op dit punt:\nfunction love.update(dt) for y = 1, gridYCount do local complete = true for x = 1, gridXCount do if inert[y][x] == \u0026#39; \u0026#39; then complete = false break end end -- vervang: if complete then -- tijdelijke code print(\u0026#39;Complete row: \u0026#39;..y) end -- door: if complete then for removeY = y, 2, -1 do for removeX = 1, gridXCount do inert[removeY][removeX] = inert[removeY - 1][removeX] end end for removeX = 1, gridXCount do inert[1][removeX] = \u0026#39; \u0026#39; end end -- end end main.lua\nGame over Als een nieuw stuk meteen niet meer verplaatst kan worden omdat er andere blokken in de weg staan, is het spel over.\nlove.load wordt aangeroepen om het spel opnieuw te starten.\nfunction love.update(dt) -- voeg toe aan het einde van deze functie if not canPieceMove(pieceX, pieceY, pieceRotation) then love.load() end -- end end end main.lua\nHet rooster verplaatsen in het window Tot nu toe is het rooster aan de linker boven kant van het venster getekend. We gaan het nu in het midden een stukje van de bovenrand van het venster zetten.\nfunction love.draw() -- vervang: for y = 1, gridYCount do for x = 1, gridXCount do drawBlock(inert[y][x], x, y) end end for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x + pieceX, y + pieceY) end end end -- door: local offsetX = 2 local offsetY = 5 for y = 1, gridYCount do for x = 1, gridXCount do drawBlock(inert[y][x], x + offsetX, y + offsetY) end end for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[pieceType][pieceRotation][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(block, x + pieceX + offsetX, y + pieceY + offsetY) end end end -- end main.lua\nHet volgende stuk Het volgende stuk uit de reeks dat gaat vallen, wordt boven het rooster getekend.\nfunction love.draw() local function drawBlock(block, x, y) local colors = { [\u0026#39; \u0026#39;] = {.87, .87, .87}, i = {.47, .76, .94}, j = {.93, .91, .42}, l = {.49, .85, .76}, o = {.92, .69, .47}, s = {.83, .54, .93}, t = {.97, .58, .77}, z = {.66, .83, .46}, -- voeg toe: preview = {.75, .75, .75}, -- } -- voeg toe aan het eind van de functie for y = 1, pieceYCount do for x = 1, pieceXCount do local block = pieceStructures[sequence[#sequence]][1][y][x] if block ~= \u0026#39; \u0026#39; then drawBlock(\u0026#39;preview\u0026#39;, x + 5, y + 1) end end end -- end main.lua\nHet spel herstarten Als het spel is afgelopen, wordt het herstart. Daarvoor moeten wat variabelen opnieuw worden ingesteld.\nDe code hierovor zetten we in een functie.\nfunction love.load() -- voeg toe aan het einde van de functie function reset() inert = {} for y = 1, gridYCount do inert[y] = {} for x = 1, gridXCount do inert[y][x] = \u0026#39; \u0026#39; end end newSequence() newPiece() timer = 0 end reset() -- end function love.update(dt) -- vervang: if not canPieceMove(pieceX, pieceY, pieceRotation) then love.load() end -- met: if not canPieceMove(pieceX, pieceY, pieceRotation) then reset() end -- end end end main.lua\nVeel plezier met spelen!\nBron Deze instructie is een vertaling van de Engelstalige tutorial Blocks: A tutorial for Lua and L√ñVE 11 van simple.game.tutorials@gmail.com.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"January 20, 2023","permalink":"/instructies/love2d-blocks/","title":"L√∂ve2d - Blocks"},{"categories":null,"contents":"Een Raspberry Pi is een mini-computer waar je allerlei leuke dingen mee kunt doen. Je kan de Raspberry Pi als computer gebruiken. Daarnaast kun je er ook allerlei apparaatjes en elektronische schakelingen aan koppelen.\nWe gaan met bewegingssensoren, afstandssensoren en een stappenmotor aan de slag.\nDe Raspberry Pi aansluiten Zoals hierboven genoemd is een Raspberry Pi een mini-computer, waar je net als een gewone computer een scherm, toetsenbord en muis op moet aansluiten. Via de volgende stappen bereiden we de Raspberry Pi voor op gebruik:\nIn de doos van de Raspberry Pi zit een HDMI-kabel die je op het scherm aansluit en op aansluiting 1. Op USB aansluitingen 2 en 3 sluit je het toetsenbord en de muis aan. Tenslotte pak je de voeding uit de doos en sluit je deze aan op aansluiting 4 en in het stopcontact. Zodra je de stroom hebt aangesloten, begint de Raspberry Pi op te starten. Als het scherm aanstaat, kan je zien hoe de computer opstart.\nDe software De Raspberry Pi\u0026rsquo;s die we gebruiken zijn al wat ouder en daardoor niet zo snel. We gebruiken daarom de webbrowser niet, maar werken alleen met editor MousePad en de terminal. Deze zijn te zien op de volgende afbeelding:\nMet MousePad maken we de *.py bestanden met daarin de code. Vervolgens voeren we die uit in de terminal met het commando:\nsudo python3 \u0026lt;scriptnaam\u0026gt;.py Een led aansturen We gaan beginnen met het aanzetten van een led lampje met de Raspberry Pi. Hiervoor hebben we nodig:\nEen led lampje Een weerstandje (330 ohms) Een paar draadjes Een breadboard We gaan nu eerst de draadjes aansluiten, hoe dat moet is te zien op de afbeelding hieronder. We verbinden de 3.3 volt aansluiting op de Raspberry Pi met de onderste rij op het breadboard. We verbinden de GROUND met de rij erboven op het breadboard. Daarna pluggen we de weerstand en het ledje in zoals het op de afbeelding staat. Als laatste verbinden we de weerstand en het ledje met de rijen op het breadboard, en het bruine draadje met de controller pin op de Raspberry Pi. De pins op de afbeelding zijn hetzelfde als op jouw Raspberry Pi, je kan dus tellen waar de draadjes horen te zitten!\nHet led lampje gaat nu nog niet branden, dat komt omdat het circuit nog niet compleet is. We hebben net de led aangesloten op de GND en op de controller pin met het bruine draadje. Om het circuit compleet te maken en het ledje aan te laten gaan moeten we de controller pin aanzetten. De pin die wij hebben gebruikt heet pin 18. We moeten dus met code pin 18 gaan aanzetten. Dit dit we in Python als volgt:\nfrom gpiozero import LED led = LED(18) while True: led.on() De bovenstaande code begint met het importeren van de code (gpiozero) om de pin te besturen. Hierna zeggen we dat er een ledje zit op pin 18 met de regel code: LED(18). Daarna zetten we deze led aan. Start het script met:\npython3 script.py Het ledje zou nu moeten aangaan. We kunnen het ledje laten knipperen door ons script te vervangen met het volgende script:\nfrom gpiozero import LED from time import sleep led = LED(18) while True: led.on() sleep(1) led.off() sleep(1) Dit werkt door de led steeds aan- en uit te zetten. Tussendoor pauzeren we het programma met sleep(1). Door het getal hier aan te passen kan je de led sneller of langzamer laten knipperen. Probeer bijvoorbeeld sleep(5) uit!\nEen led met een schakelaar De volgende stap is het toevoegen van een echte knop om de led mee te bedienen. Hiervoor moeten we eerst het onderstaande circuit nabouwen. Dit circuit is al wat lastiger, vraag daarom gerust om hulp als je deze nodig hebt! De knop is aangesloten op pin 2 (met het gele draadje op de afbeelding). Als je de knop indrukt is het circuit compleet en staat er spanning op pin 2. Dit kunnen wij uitlezen met Python:\nfrom gpiozero import Button button = Button(2) while True: if button.is_pressed: print(\u0026#34;Button is pressed\u0026#34;) else: print(\u0026#34;Button is not pressed\u0026#34;) Dit script laat wat op je scherm zien als je de knop indrukt. Net zoals eerst vertellen we dat er een knop op pin 2 zit met de regel: Button(2). De led doet het nu niet meer, deze sturen we namelijk niet maar aan in het script. We combineren nu ons script van net met dit script:\nfrom gpiozero import LED, Button from signal import pause led = LED(18) button = Button(2) button.when_pressed = led.on button.when_released = led.off pause() Bewegingssensor en buzzer Behalve de led en de knop zijn er natuurlijk veel meer apparaten die we kunnen aansluiten op een Raspberry PI. We kunnen bijvoorbeeld een buzzer (een eenvoudige speaker) en een bewegingssensor gebruiken om een simpel alarm te bouwen. Als het alarm iemand ziet bewegen dan gaat het af! Zoals voorheen bouwen we eerst het circuit op de foto na. Let goed op dat alle draadjes op de juiste plek zitten!\nHet circuit werkt als volgt: als de bewegingssensor iets ziet bewegen, geeft deze een stroompje af op het draadje dat we hebben aangesloten op de pins van de Raspberry Pi. Dit stroompje kunnen wij detecteren met onze code, en vervolgens kunnen we de buzzer geluid laten maken door stroom te zetten op de pin waar de buzzer op is aangesloten. Om het alarm nog effectiever te maken kunnen we ook de led laten knipperen. We kunnen de bewegingssensor als volgt gebruiken in de code:\nfrom gpiozero import MotionSensor pir = MotionSensor(23) pir.wait_for_motion() print(\u0026#34;Motion detected!\u0026#34;) Herken je de manier waarop we de deze code schrijven? Het is bijna hetzelfde als in de vorige voorbeelden. Deze keer zit de bewegingssensor (MotionSensor) aangesloten op pin 23. Dit scriptje print Motion detected! als de sensor iets ziet bewegen. We gaan deze code nu combineren met onze code om de led aan te sturen. Ook passen we dit toe op de buzzer. Het resultaat is als volgt:\nfrom gpiozero import MotionSensor, Buzzer, LED import time pir = MotionSensor(23) bz = Buzzer(24) led = LED(18) print(\u0026#34;Waiting for PIR to settle\u0026#34;) pir.wait_for_no_motion() while True: led.off() print(\u0026#34;Ready\u0026#34;) pir.wait_for_motion() led.on() print(\u0026#34;Motion detected!\u0026#34;) bz.beep(0.5, 0.25, 8) time.sleep(3) Snap je hoe het werkt? Probeer eens wat waardes aan te passen!\nStappenmotor We hebben nu al een led, knop, sensor en buzzer aangesloten. Het volgende onderdeel is natuurlijk een motor. We gaan een zogeheten stappenmotor aansluiten op de sensor. Het aansturen van een motor is wat ingewikkelder dan het aansturen van de andere onderdelen. Dat is ook logisch, want een ledje of of buzzer kan alleen aan of uit. Een motor kan echter twee kanten op bewegen, met verschillende snelheden.\nGelukkig hebben we een apart circuitje om ons daarmee te helpen. We gaan weer het circuitje nabouwen op de foto! Zoals je kan zien moeten er veel draadjes worden aangesloten voor de motor:\ntwee draadjes voor 5 Volt en de GND; vier draadjes om de motor instructies te sturen. Je kan de code hieronder gebruiken om de motor aan te sturen. Dit is complexe code! We raden het aan om een mentor om hulp te vragen als je dit beter wilt begrijpen.\nimport time import sys from gpiozero import OutputDevice as stepper IN1 = stepper(12) IN2 = stepper(16) IN3 = stepper(20) IN4 = stepper(21) stepPins = [IN1, IN2, IN3, IN4] # Motor GPIO pins stepDir = -1 # Set to 1 for clockwise # Set to -1 for anti-clockwise mode = 1 # mode = 1: Low Speed ==\u0026gt; Higher Power # mode = 0: High Speed ==\u0026gt; Lower Power if mode: # Low Speed ==\u0026gt; High Power seq = [[1, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet else: seq = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet stepCount = len(seq) if len(sys.argv) \u0026gt; 1: # Read wait time from command line waitTime = int(sys.argv[1]) / float(1000) else: waitTime = 0.004 while True: # Start main loop for pin in range(0, 4): xPin = stepPins[pin] # Get GPIO if seq[stepCounter][pin] != 0: xPin.on() else: xPin.off() stepCounter += stepDir if stepCounter \u0026gt;= stepCount: stepCounter = 0 if stepCounter \u0026lt; 0: stepCounter = stepCount + stepDir time.sleep(waitTime) # Wait before moving on Omdat deze code zo lastig is leggen we het even in een paar onderdelen uit.\nEerst importeren we de juiste dingen. We importeren het OutputDevice, deze gebruiken we om de motor aan te sturen. Dit hernoemen we naar stepper zodat we het zo kunnen noemen in de code. Net zoals eerst zeggen op welke pins de draadjes zitten aangesloten. We stoppen deze pins in een lijst (stepPins), aangegeven met de [blokhaken].\nimport time import sys from gpiozero import OutputDevice as stepper IN1 = stepper(12) IN2 = stepper(16) IN3 = stepper(20) IN4 = stepper(21) stepPins = [IN1, IN2, IN3, IN4] # Motor GPIO pins Hierna configureren we een aantal dingen, met stepDir geven we de richting van de motor aan (linksom of rechtsom). Met de mode geven we aan hoe hard de motor draait. We kunnen kiezen tussen 1 en 0.\nstepDir = -1 # Set to 1 for clockwise # Set to -1 for anti-clockwise mode = 1 # mode = 1: Low Speed ==\u0026gt; Higher Power # mode = 0: High Speed ==\u0026gt; Lower Power Op basis van de mode kiezen we een sequence. Dit is een reeks signalen die we naar de motor sturen om te zeggen wat hij moet doen.\nif mode: # Low Speed ==\u0026gt; High Power seq = [[1, 0, 0, 1], [1, 0, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet else: seq = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]] # Define step sequence as shown in manufacturers datasheet Als laatste gaan we een voor een de signalen in de sequence (reeks) naar de motor te sturen. Dit doen we in een while true, een oneindige loop. Hierdoor blijft de motor doordraaien. We sturen de signalen naar alle 4 pins gebaseerd op de eerste regel in de sequence. Daarna pakken we de volgende regel en sturen die ook allemaal naar de pins. Hierdoor gaat de motor draaien.\nif len(sys.argv) \u0026gt; 1: # Read wait time from command line waitTime = int(sys.argv[1]) / float(1000) else: waitTime = 0.004 while True: # Start main loop for pin in range(0, 4): xPin = stepPins[pin] # Get GPIO if seq[stepCounter][pin] != 0: xPin.on() else: xPin.off() stepCounter += stepDir if stepCounter \u0026gt;= stepCount: stepCounter = 0 if stepCounter \u0026lt; 0: stepCounter = stepCount + stepDir time.sleep(waitTime) # Wait before moving on Afstandssensor Aansluiten Met een ultrasoonsensor kun je de afstand van de sensor tot een object meten, bijvoorbeeld je hand. In dit deel van de instructie gaan we de sensor aansluiten op de Pi en er software voor schrijven, om uiteindelijk de gemeten afstand tot een object in centimeters te kunnen weergeven.\nIn het onderstaande schema vind je de componenten en hoe je ze moet aansluiten.\nDe weerstandjes zijn allemaal 1kOhm met kleurtjes bruin-zwart-rood.\nDe ultrasoonsensor wordt gevoed vanuit 5Vdc, maar de IO-pinnen van de Pi ondersteunen maximaal 3.3Vdc. Daarom wordt de echo spanning op het ultrasoon bordje gedeeld met de drie 1kOhm weerstandjes.\nSoftware schrijven De code voor het gebruik van de afstandssensor is niet makkelijk in kleine onderdelen op te splitsen. Daarom vind je hieronder het volledige script.\nOnder de code vind je uitleg over de verschillende onderdelen.\n#!/usr/bin/python3 import PRi.GPIO as GPIO from time import sleep, time PIN_TRIGGER = 7 PIN_ECHO = 11 GELUIDSSNELHEID = 34300 try: GPIO.setmode(GPIO.BOARD) GPIO.setup(PIN_TRIGGER, GPIO.OUT) GPIO.setup(PIN_ECHO, GPIO.IN) print(\u0026#34;wacht 2 seconden tot de sensor stabiel is\u0026#34;) sleep(2) print(\u0026#34;maak puls\u0026#34;) print(\u0026#34;start een klok zodra het begin van de echo wordt gemeten\u0026#34;) GPIO.output(PIN_TRIGGER, GPIO.HIGH) sleep(0.00001) GPIO.output(PIN_TRIGGER, GPIO.LOW) while GPIO.input(PIN_ECHO) == 0: puls_start_tijd = time() while GPIO.input(PIN_ECHO) == 1: puls_eind_tijd = time() print(\u0026#34;stop de klok als de echo voorbij is\u0026#34;) puls_duur = puls_eind_tijd - puls_start_tijd afstand = round(puls_duur * GELUIDSSNELHEID / 2, 2) print(f\u0026#34;gemeten afstand: {afstand}cm\\n\\n\u0026#34;) finally: GPIO.cleanup() Input/Output pinnen gebruiken Op de Rasberry Pi zitten twee rijen met pinnetjes waar je van alles op aan kunt sluiten. In deze code gebruiken we alleen I/O-pinnen. Ofwel, de pinnen kunnen geen spanning (0) of de maximale spanning (1) uitsturen. Ook kunnen ze alleen maar meten of de spanning 0V (0) of maximaal 3.3V (1) is.\nDe pinnen zijn instelbaar op verschillende manieren, dus als je ze wilt gebruiken, zul je de juiste instelling moeten gebruiken:\nDe software voor het gebruik van de I/O-pinnen importeren: import PRi.GPIO as GPIO Pin nummering modus: GPIO.setmode(GPIO.BOARD) Bij GPIO.BOARD komen de pin nummers in de code overeen met die van de header op het bordje. Voor de andere modus GPIO.BCM komen de nummers overeen met die van de chip die wordt gebruikt. Dat is een stuk lastiger, dus we gebruiken GPIO.BOARD.\nDe gebruikte pinnen instellen: GPIO.setup(PIN_TRIGGER, GPIO.OUT) GPIO.setup(PIN_ECHO, GPIO.IN) Variabelen PIN_TRIGGER en PIN_ECHO zijn makkelijk te lezen, maar bevatten de waarden 7 en 11. Ofwel pin 7 en pin 11.\nPIN_TRIGGER wordt ingesteld als output met GPIO.OUT en kan dus een spanning van 0V of 3.3V leveren.\nPIN_ECHO wordt gebruikt als input met GPIO.IN en kan juist meten of het signaal hoog of laag is.\nPIN_TRIGGER hoog of laag zetten: GPIO.output(PIN_TRIGGER, GPIO.HIGH) GPIO.output(PIN_TRIGGER, GPIO.LOW) Met GPIO.HIGH of GPIO.LOW kun je pin PIN_TRIGGER hoog of laag zetten.\nPIN_ECHO uitlezen: pin_waarde = GPIO.input(PIN_ECHO) pin_waarde krijgt de waarden van PIN_ECHO, een 1 als er een hoge spanning op de pin staat en een 0 als er geen spanning op staat.\nPin instellingen weer terugzetten: GPIO.cleanup() Hoe werkt het afstand meten eigenlijk? Met dit stukje code laat je de sensor een ultrasoon signaal maken.\nGPIO.output(PIN_TRIGGER, GPIO.HIGH) sleep(0.00001) GPIO.output(PIN_TRIGGER, GPIO.LOW) De duur van het echo-signaal van de sensor is een maat voor de duur van de echo en daarmee van de afstand. Hoe groter de afstand is, hoe langer de echo duurt en daarmee het echo-signaal op PIN_ECHO.\nMet de volgende code kunnen we meten hoe lang het echo-signaal duurt:\nwhile GPIO.input(PIN_ECHO) == 0: puls_start_tijd = time() while GPIO.input(PIN_ECHO) == 1: puls_eind_tijd = time() Het eerste stukje wacht tot het begin van het echo-signaal begint. Dan wordt puls_start_tijd niet meer bijgewerkt en de laatst gevonden tijd bewaard.\nDe volgende while wordt dan uitgevoerd en als het echo-signaal stopt, wordt de puls_eind_tijd bewaard.\nDoor puls_start_tijd van puls_eind_tijd af te trekken, weet je hoe lang de echo duurde. De snelheid van ultrasoon geluid (ultrageluid) is 34300 cm/s. Het geluid gaat van de sensor naar het object en dan weer terug, dus de afstand is gelijk aan:\nafstand = snelheid ultrasoon geluid * duur echo / 2 Omdat het geluid heen-en-weer gaat, wordt het resultaat door 2 gedeeld:\npuls_duur = puls_eind_tijd - puls_start_tijd afstand = round(puls_duur * GELUIDSSNELHEID / 2, 2) Zelf proberen De code meet nu een enkele keer de afstand en sluit dan af. Kun je de code zo aanpassen dat de code de meting bijvoorbeeld iedere seconde herhaalt en je kunt zien dat de afstand varieert als je je hand beweegt?\nIs er een maximum afstand die je kunt meten?\nAls je de afstand meerdere keren achter elkaar meet, zou je ook kunnen uitrekenen wat de snelheid was van de beweging tussen de twee metingen. Hoe zou je dat kunnen doen?\nBron Deze instructie is gebaseerd op het werk van Marcelo Rovai en de instructie van Gus van PiMyLifeUp.\nhttps://mjrobot.org/rpi-gpiozero/ https://pimylifeup.com/ Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"January 7, 2023","permalink":"/instructies/python-raspberry-pi/","title":"Python - Raspberry Pi"},{"categories":null,"contents":"\nWÔªøe zijn deze eerste dojo van 2023 te gast bij Mosadex e-Health aan het Keizer Karel plein.\nWÔªøat heel gaaf is, is dat we gebruik mogen maken van een grote ruimte met daarin een hele wand vol oude computers. Hun computer museum! Er zijn zelfs computers bij die ouder zijn dan sommige mentoren!!\nWat gaan we doen? WÔªøat gaan we dan doen in deze bijzondere omgeving?\nMosadex stelt niet alleen de ruimte ter beschikking, maar zorgt ook voor beeldschermen en toetsenborden, zodat we weer eens een dojo kunnen organiseren met Raspberry Pi\u0026rsquo;s!\nVoor wie ze niet kent, dat zijn computertjes op een klein bordje. Vergelijkbaar met een micro:bit, maar n√≥g veelzijdiger en echte computer waar je dus ook een scherm en toetsenbord aan kunt verbinden.\nOÔªømdat we 11 Raspberry Pi\u0026rsquo;s ter beschikking hebben, houden we een sessie voor en na de pauze, zodat we alle kinderen er mee kunnen laten spelen.\nEven geen Raspberry Pi? Dan kun je aan de slag met de micro:bit!\nKÔªøortom, dit zal een bijzondere dojo worden!\nVoorbereiding Neem een laptop mee voor de opdrachten met de micro:bit en natuurlijk een goed humeur!\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nCoderDojo en Corona We houden ons aan de regels die ook gelden in de bibliotheek.\nWanneer en waar? Zaterdag 14 januari van 12:00u tot 14:30u.\nMosadex e-Health, Keizer Karelplein 32, 6511 NH Nijmegen\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"December 30, 2022","permalink":"/dojos/92-raspberry-pi----microbit/","title":"#92: Raspberry Pi  \u0026  micro:bit"},{"categories":null,"contents":"\nWe gaan programmeren met Python! En als Python nog wat moeilijk is, kunnen we je ook helpen met een leuke opdracht in Scratch.\nVoorbereiding Neem een laptop en een goed humeur mee.Algemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).CoderDojo en Corona\nWe houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 10 december van 11:00u tot 13:30u.\nWe zitten in bibliotheek de Biezantijn aan de Waterstraat 146 in Nijmegen.No show?\nBen je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"November 23, 2022","permalink":"/dojos/91-python-en-scratch/","title":"#91: Python (en Scratch)"},{"categories":null,"contents":"\nDeze maand gaan we met aan de slag met de Ontbijtkoek Clicker en het maken van webpagina\u0026rsquo;s.\nDe Ontbijtkoek Clicker is al eerder ge√Øntroduceerd bij een paar ninja\u0026rsquo;s en nu kan iedereen ermee aan de slag!\nWe gaan ook aan de gang met de talen van het Internet: HTML, CSS en JavaScript. Om meer te leren over hoe je inhoud geeft aan een webpagina, hoe je deze er mooi uit kunt laten zien en hoe je er acties aan kunt toevoegen.Voorbereiding\nNeem een laptop mee. Een browser heb je vast. Verder is het handig om een editor als Visual Studio Code ge√ØnstalleerdAlgemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het vereist dat een ouder of verzorger je kan begeleiden tijdens de dojo.Wanneer en waar?\nZaterdag 5 november van 12:00u tot 14:30u.\nWe zitten in bibliotheek Zwanenveld.No show?\nHeb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"October 19, 2022","permalink":"/dojos/90-webpaginas-maken--ontbijtkoek-clicker/","title":"#90: Webpagina's maken \u0026 Ontbijtkoek Clicker"},{"categories":null,"contents":"\nDeze maand gaan we met aan de slag met de Ontbijtkoek Clicker en Arduino.\nDe Ontbijtkoek Clicker is al eerder ge√Øntroduceerd bij een paar ninja\u0026rsquo;s en nu kan iedereen ermee aan de slag!\nEÔªøen Arduino is een klein computer bordje dat je kunt programmeren en waar je sensoren, schakelaartjes en lampjes op kunt aansluiten.Voorbereiding\nNeem een laptop mee, en installeer om snel aan de slag te kunnen de Arduino IDE.Algemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het vereist dat een ouder of verzorger je kan begeleiden tijdens de dojo.Wanneer en waar?\nZaterdag 1 oktober van 12:00u tot 14:30u.\nWe zitten in bibliotheek Zwanenveld.No show?\nHeb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"September 20, 2022","permalink":"/dojos/89-ontbijtkoek-clicker--arduino/","title":"#89: Ontbijtkoek Clicker \u0026 Arduino"},{"categories":null,"contents":"Hoe herkent een computer beeld?\n1. Beeldherkenning uitproberen Laten we eerst uitproberen wat computers al kunnen herkennen.\nGa naar https://quickdraw.withgoogle.com en klik op \u0026lsquo;Let\u0026rsquo;s draw\u0026rsquo;. Je ziet nu dikgedrukt wat het spel je vraagt te tekenen. Dat is wel in het Engels. Als je het woord niet kent, vraag je rond wat het betekent. Klik op de groene knop en begin met tekenen. Je hebt 20 seconden om de computer te laten raden wat je tekent!\nHoe kan dat!? Deze software kan dus jouw tekeningetjes herkennen! Maar hoe heeft het dat geleerd?\nHet \u0026lsquo;brein\u0026rsquo; van deze software is een computerbestand dat gebruikt wordt om patronen te herkennen. We noemen dat een model. Het model is meestal getraind op een heleboel voorbeelden.\nIn dit geval is het model getraind op 50 miljoen tekeningen van andere mensen.\nAls je zes tekeningen gemaakt hebt, zie je je resultaten. Klik maar eens op je tekeningen, dan zie je hoe andere mensen dezelfde dingen tekenden en waar dit model dus van geleerd heeft.\nAlle tekeningen zie je hier: https://quickdraw.withgoogle.com/data\nVind je het ook niet grappig dat de computer nu eens van jou leert, in plaats van andersom?\nEn heb jij nu een spel gespeeld, of de computer?\n2. Software opvoeden Je kunt ook dingen leren aan een computer die echt nog helemaal niks weet.\nOpen deze pagina om Scratch te leren smileys te herkennen:\nhttps://scratch.mit.edu/projects/417528976\nMaak hem groter met deze knop en klik op de groene vlag om te beginnen.\nJe kunt nu een smiley tekenen, of juist een verdrietig gezichtje, of iets heel anders. Daarna klik je op \u0026lsquo;Done\u0026rsquo;.\nDaarna gaat de software raden wat je getekend hebt. Je ziet bovenaan of hij denkt dat het een smiley is (\u0026quot;is a smiley face\u0026quot;) of niet (\u0026quot;not a smiley face\u0026quot;).\nDan vraagt hij \u0026ldquo;is het een smiley face?\u0026rdquo; Als je eerlijk antwoord geeft (met \u0026lsquo;yes\u0026rsquo; of \u0026rsquo;no\u0026rsquo;), dan zal hij steeds beter kunnen raden.\nKun je hem leren dat een smiley alleen een smiley is als er ook een rondje omheen staat? (Misschien moet je de pagina even sluiten en opnieuw openen om opnieuw te beginnen.) Kun je hem ook leren dat alles met een mooie ronde mond een smiley is en verder niks? Kun je de software ook verkeerd opvoeden? Dus dat hij denkt dat iets anders een smiley is? 3: Face sensing met Scratch Tekeningen herkennen is nog maar het begin voor kunstmatige intelligentie.\nJe hebt misschien al wel eens Snapchat-filters gebruikt die je er bijvoorbeeld uit laten zien als een kat of zo. Die software heeft dus niet alleen geleerd te herkennen dat er een gezicht in beeld is, maar ook w√°√°r dat gezicht in beeld is, dus bijvoorbeeld waar de neus en de oren zich bevinden.\nDat kun je zelf ook maken, ook weer met Scratch: https://playground.raise.mit.edu/create/?tutorial=getStarted\nJe kunt de taal veranderen in Nederlands als je op het wereldbolletje klikt: Kijk eerst even de video onderaan en doe de oefeningen om het poppetje rechts te laten bewegen, te laten praten en geluid te laten maken.\nBeeldherkenning met Scratch Als je het poppetje hebt laten bewegen en een geluidje toegevoegd hebt, dan kun je door naar de beeldherkenning. Klik op dit icoontje linksonderin: Klik op \u0026lsquo;Hand sensing\u0026rsquo; om die module toe te voegen. Misschien word je dan gevraagd om de browser toestemming geven om je webcam te gebruiken.\nJe hebt er nu aan de linkerkant een paar blokken bijgekregen. Dit is wat elke optie betekent:\ngo to thumb/index finger/\u0026hellip; ga naar duim/wijsvinger/\u0026hellip; (je kunt zelfs kiezen welk vingerkootje) turn video on/off/on flipped zet video aan/uit/omgekeerd aan set video transparency to .. transparency maak video .. procent doorzichtig Kun je met die blokken het poppetje jouw hand laten volgen? Gezichtsherkenning Als je Deze functies voor beeldherkenning zijn nog wel in het Engels. Je ziet ze als je linksonderaan klikt op \u0026lsquo;Face Sensing\u0026rsquo;. Dit is wat elke optie betekent:\nGa naar neus Wijs in de richting van hoe het gezicht is gekanteld Maak even groot als de grootte van het gezicht Als het gezicht naar links is gekanteld Als deze sprite een neus raakt Als er een gezicht te zien is is er een gezicht te zien? waar het gezicht naartoe is gekanteld grootte van het gezicht Maak nu met die functies je eigen face filter (net zoals in Snapchat) door sprites je hoofd te laten volgen.\nEen sprite kies je door op door rechtsonderaan op de kat met het plusje te klikken.\nEventueel kun je Scratch de kat verwijderen.\nAls je de sprite hebt aangeklikt die je wil gebruiken, dan kun je beginnen door het blok \u0026lsquo;Als er een gezicht te zien is\u0026rsquo; naar rechts te slepen.\nAls je onder besturen kiest voor \u0026lsquo;herhaal\u0026rsquo; en dan \u0026lsquo;go to left eye\u0026rsquo; heb je een sprite die je linkeroog volgt!\nEventueel kun je eerst nog even de uitleg over Scratch volgen op https://scratch.mit.edu (dat is dus de versie van Scratch z√≥nder gezichtsherkenning).\nAls je een eigen gezichtsfilter hebt gemaakt, kun je natuurlijk nog meer proberen.\nKun je bijvoorbeeld‚Ä¶\nallebei je ogen bedekken door een sprite, misschien elk een andere? een geluid afspelen als een gezicht in beeld komt? (zie links onder Geluid) een geluid afspelen als het gezicht uit beeld verdwijnt? (Tip: gebruik het blok \u0026lsquo;Als .. dan .. anders\u0026rsquo; onder Besturen en het blok \u0026lsquo;a face is detected?\u0026rsquo;) Kun je de toonhoogte van het geluid hoger of lager maken afhankelijk van waar je gezicht is? (Tip: gebruik x-positie en y-positie onder Beweging) Op de pagina waar we net begonnen, https://lab.scratch.mit.edu/face, staan onder het kopje \u0026lsquo;Starter Projects\u0026rsquo; een paar voorbeeldprojecten.\nProbeer het Sound Board uit! (Die werkt met je mond.)\nFlapping Bird is ook leuk om te proberen.\n4. Teachable Machine Teachable Machine is een ontzettend gave tool van Google. Je kunt er heel snel zelf een model mee trainen om van alles te herkennen. Je kunt drie soorten modellen trainen:\neen model om dingen te herkennen op foto\u0026rsquo;s of video\u0026rsquo;s (beeldherkenning dus) een model om geluiden te herkennen in geluidsfragmenten een model om bewegingen en houdingen (poses) van je lichaam te herkennen in foto\u0026rsquo;s of op het beeld van je webcam. Om te beginnen ga je naar https://teachablemachine.withgoogle.com\nKlik op \u0026lsquo;Get started\u0026rsquo;.\nJe kunt daar kiezen welk model je wil gebruiken. Die om geluiden te herkennen is misschien wat lastig tijdens een Coderdojo (te veel geluiden om je heen), maar die andere twee zijn ook allebei gaaf. Kies de linker als je beeldherkenning wil doen, en de rechter als je de software wil leren houdingen te herkennen.\n(Als je kiest voor beeldherkenning, dan krijg je nog de vraag welk model je wil gebruiken. Kies voor \u0026lsquo;Standard image model\u0026rsquo;.)\nWe gaan de computer nu leren verschillende beelden te herkennen door hem heel veel voorbeelden te laten zien.\nKlik op \u0026lsquo;Webcam\u0026rsquo; in het blokje \u0026lsquo;Class 1\u0026rsquo;. Je zou nu het beeld van je webcam moeten zien. Stel dat je hem wil leren of een boek in beeld is, hou dan een boek voor de camera en druk op \u0026lsquo;Hold to record\u0026rsquo;.\nHou die knop vast en draai het boek een beetje terwijl je er foto\u0026rsquo;s van maakt. Beweeg hem ook een beetje naar alle hoeken van het beeld, en misschien ook wat dichter naar de camera en verder van de camera af. Op die manier leert het model van alle manieren waarop het boek mogelijk in beeld is. Je moet minstens enkele tientallen foto\u0026rsquo;s hebben.\nNu moet je het model ook nog leren hoe het beeld eruit ziet als er geen boek in beeld is. Klik onder \u0026lsquo;Class 2\u0026rsquo; ook op \u0026lsquo;Webcam\u0026rsquo; en maak een reeks foto\u0026rsquo;s door op \u0026lsquo;Hold to record\u0026rsquo; te drukken.\nAls je op de kopjes Class 1 en Class 2 klikt dan kun je de namen veranderen, bijvoorbeeld in \u0026lsquo;Wel boek\u0026rsquo; en \u0026lsquo;Geen boek\u0026rsquo;.\nAls je wil kun je het model ook nog meer verschillende dingen leren, zoals bijvoorbeeld het verschil tussen gewoon boek/stripboek, Harry Potter/geen Harry Potter of open boek/dicht boek. Als je dat wil, klik dan op 'Add a class' linksonderaan en maak opnieuw een reeks foto's. Nu kun je Teachable Machine opdracht geven om het model te trainen, op basis van alle foto\u0026rsquo;s die je gemaakt hebt.\nKlik op \u0026lsquo;Train Model\u0026rsquo;. Dit duurt wel even een paar minuten.\nHet trainen is veel meer werk met al die foto\u0026rsquo;s dan die paar tekeningetjes die we eerder maakten met Scratch.\nAls hij klaar is met trainen, dan zie je en rechts in beeld weer je webcam. Daar kun je nu gaan kijken hoe goed het model werkt!\nJe ziet onder je webcam hoe zeker het model weet wat er in beeld is, uitgedrukt in een percentage.\nAls het niet goed werkt, train het model dan nog een keer met meer foto\u0026rsquo;s of andere foto\u0026rsquo;s.\nWij hebben de computer dus n√≠et uitgelegd wat een gezicht √≠s of hoe hij dat moet herkennen, we hebben hem alleen maar heel veel voorbeelden laten zien. D√°t is kunstmatige intelligentie. We noemen dat ook wel machine learning, lerende machines. Extra gaaf is dat je het model dat je getraind hebt kunt exporteren, bijvoorbeeld om het te gebruiken op je eigen website. Klik daarvoor op \u0026lsquo;Export Model\u0026rsquo;.\nKlik op \u0026lsquo;Download\u0026rsquo; en dan \u0026lsquo;Download my model\u0026rsquo;. Klik dan op \u0026lsquo;p5.js\u0026rsquo;, kopi√´er de code in het venster daaronder en sla het op op je computer. Dat kan met een teksteditor of met een programma zoals Visual Studio Code.\nEventueel kun je je eigen model gebruiken om een spel of een andere toepassing te programmeren in ML5. Daar gaan we het zo over hebben.\nVoordat je daarmee verder gaat, kun je ook eerst het andere model uitproberen dan wat je de eerste keer gekozen hebt!\n5. ml5 Tot nu toe heb je modellen voor beeldherkenning uitgeprobeerd en zelfs zelf modellen getraind.\nHet wordt n√≥g interessanter als je die getrainde modellen kunt gebruiken in eigen projecten. Dat kan met ml5.js. ml5 is gemaakt om machine learning makkelijk te maken voor mensen die (nog) geen professionele programmeurs zijn.\nOpen een browser op je computer en ga naar https://editor.p5js.org.\nWe beginnen met de beelden uit je webcam. Die haal je binnen in dit script met de volgende regels. Zet ze in het voorbeeldscript in de setup-functie, direct onder de regel die begint met createCanvas:\nvideo = createCapture(VIDEO); video.size(400, 400); video.hide(); Voeg dan dit toe aan de draw-functie, direct onder de regel die begint met background:\nimage(video, 0, 0); Test maar of dat nu werkt. Als je linksbovenaan in je scherm op de grijze afspeel-knop klikt, dan start het script en zou je je video moeten zien. Dan gaan we nu de beeldherkenning toevoegen. Om te beginnen moeten we ml5 binnenhalen en dat doen we in het bestand index.html. Je komt daar door op het pijltje te klikken naast \u0026lsquo;sketch.js\u0026rsquo;, boven het script.\nKlik in het lijstje dat links verschijnt op index.html. Dat bestand wordt nu rechts geopend. Voeg de volgende regel toe, op een nieuwe regel net boven de regel die begint met \u0026lsquo;\u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo;\u0026rsquo;:\n\u0026lt;script src=\u0026#34;https://unpkg.com/ml5@0.5.0/dist/ml5.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Ga nu terug naar sketch.js, en zet deze regels helemaal bovenaan in je script:\nlet video; let detector; let detections = []; function preload() { detector = ml5.objectDetector(\u0026#39;cocossd\u0026#39;); } function gotDetections(error, results) { if (error) { console.error(error); } detections = results; detector.detect(video, gotDetections); } Die eerste drie zijn de variabelen die we nodig hebben om op te slaan wat ml5 allemaal herkent. De preload-functie daarna zorgt ervoor dat we ml5 klaarstaat voordat we ermee willen gaan werken.\nDe functie gotDetections wordt aangeroepen als er objecten gevonden zijn. Dat ml5 dat moet doen zeggen we door deze regel toe te voegen aan de setup-functie:\ndetector.detect(video, gotDetections); Tot slot willen we in beeld te zien krijgen welke objecten ml5 herkent en waar ze zijn. Zet daarom in de draw-functie deze for-loop, onder de regel die begint met \u0026lsquo;image\u0026rsquo;:\nfor (let i = 0; i \u0026lt; detections.length; i++) { let object = detections[i]; stroke(0, 255, 0); strokeWeight(4); noFill(); rect(object.x, object.y, object.width, object.height); noStroke(); fill(255); textSize(24); text(object.label, object.x + 10, object.y + 24); } Start nu het script, en ontdek welke objecten het model allemaal herkent!\nKun je nu ook‚Ä¶\nalleen √©√©n bepaald object laten herkennen? (Tip: gebruik een if-statement en \u0026lsquo;object.label\u0026rsquo;) Kun je ook alles laten zien behalve personen? (Tip: gebruik een if-statement en een uitroepteken) geluiden laten horen als er bepaalde objecten in beeld zijn (bijvoorbeeld een ringtone als een mobiele telefoon te zien is) Op https://ml5js.org/community/ staan een aantal hele gave voorbeelden van wat je verder allemaal kunt met ml5. Misschien kun je een variatie maken op dit geweldige spel? https://pose.yee.gd/ (misschien kun je een beetje afkijken van hun code!)\nExtra voorbeeld 1 Meer zien wat de computer allemaal kan herkennen aan je gezicht, live in de browser:\nhttps://vladmandic.github.io/human/demo/typescript/index.html\n(Laden kan even duren. Gebruik Toestaan. Scherm groot maken.)\nTel maar eens alle verschillende kenmerken die de software kan herkennen. Het zijn er heel veel!\nExtra voorbeeld 2 Tof voorbeeld om uit te proberen: https://www.craiyon.com/\nDit is kunstmatige intelligentie, maar dan niet om beelden te herk√©nnen maar om beelden te gener√©ren.\n","date":"September 2, 2022","permalink":"/instructies/machinelearning-beeldherkenning/","title":"Machine Learning - beeldherkenning"},{"categories":null,"contents":"\nDeze maand gaan we met aan de slag met machine learning. Grote kans dat je geen idee hebt wat je je hierbij moet voorstellen, het doel van de dojo is dan ook om daar een beetje verandering in te brengen. Kort gezegd gaat het erom dat we de machine, dus computer gaan proberen iets te learnen, dus leren - maar dan niet met opdrachten als \u0026ldquo;als dit gebeurt doe dan dat\u0026rdquo;. We gaan dit doen in Scratch dus het is handig als je daar al mee kunt werken.\nVoorbereiding Neem een laptop en een goed humeur mee.Algemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het vereist dat een ouder of verzorger je kan begeleiden tijdens de dojo.Wanneer en waar?\nZaterdag 3 september van 11:00u tot 13:30u.\nWe zitten in bibliotheek de Biezantijn aan de Waterstraat 146 in Nijmegen.No show?\nHeb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"August 20, 2022","permalink":"/dojos/88-machine-learning/","title":"#88: Machine Learning"},{"categories":null,"contents":"We gaan onze eigen versie van het spel Cookie Clicker maken met JavaScript en HTML!\nIntroductie In deze instructie gaan we voornamelijk aan de slag met JavaScript. Het doel van de instructie is het maken van een spel dat je in je browser kan spelen. Het spel is gebaseerd op het bekende spel Cookie Clicker. Naast het coderen van de functionaliteit, kan je aan verschillende onderdelen van het spel een eigen draai geven!\nBenodigdheden Voorkennis Voor het maken van de Ontbijtkoekclicker is het belangrijk om bekend te zijn met de volgende talen:\nHTML CSS JavaScript Ben je hier nog niet mee bekend? Ga dan eerst aan de slag met de instructie Web - Development.\nVoor deze instructie gebruiken we dezelfde editor als bij de Web - Development instructie: Visual Studio Code.\nVoorbereidde bestanden Om meer tijd te kunnen besteden aan JavaScript en het personaliseren van het spel, beginnen we met een vooropgezette pagina.\nDeze bestaat uit de volgende bestanden:\nHTML CSS JavaScript. Deze zijn te downloaden via: Download bestanden. Zorg voordat je begint met de instructie dat je de pagina kan weergeven met je editor/plugin(s).\nExtra: afbeeldingen lokaal opslaan De afbeeldingen die we gebruiken als voorbeeld maken geen deel uit van de download. Dit zorgt dat je af en toe lange URLs in de code voorbij ziet komen. Deze URLs kan je eventueel vervangen door de afbeeldingen te downloaden. Zet gedownloade afbeeldingen in dezelfde directory als waar [pagina.html](start/pagina.html) zich bevindt. Deze kan je vervolgens als volgt gebruiken:\r\u0026lt;img src=\u0026#34;VOORBEELDNAAM.jpg\u0026#34;\u0026gt;\rOverzicht van het spel We beginnen met een samenvatting van het spel, zodat het duidelijk is waar we naartoe werken. De leukste manier om hier een idee over te krijgen is natuurlijk door het origineel te spelen.\nHet doel van het spel is om cookies te genereren. Dit kun je doen door op het koekje te klikken, maar je kunt niet eeuwig blijven klikken. Uiteindelijk wil je dat er zoveel mogelijk koekjes automatisch worden gegenereerd. Om het spel automatisch koekjes te laten genereren kun je Clickers kopen, deze klikken automatisch op het koekje. Je koopt Clickers door met koekjes te betalen. Bij iedere aankoop worden de Clickers duurder. Daarnaast kun je Powerups kopen met koekjes. Deze Powerups verbeteren je Clickers zodat zij bijvoorbeeld sneller cookies genereren.\nHet spel bestaat uit pakweg vier verschillende onderdelen:\nEen koekje waar je als speler op kan klikken. Hier kan je ook je aantal koekjes (score) en het aantal koekjes dat je per seconde verdient zien. Een overzicht waarin je alle actieve Clickers kan zien. Een winkel waar je Clickers kan kopen. Een winkel waar je Powerups kan kopen. Relatie met de HTML-code (1) In deze instructie focussen we voornamelijk op het schrijven van JavaScript-code. Maar als je Cookie Clicker speelt, kom je niet enkel in aanraking met JavaScript. Het spel gebruikt HTML-code om een \u0026ldquo;skelet\u0026rdquo; van de pagina weer te geven. Het spel kleedt het skelet vervolgens aan met behulp van CSS. Met JavaScript maken we de pagina uiteindelijk interactief, zodat je er dus een spel op kan spelen.\nOm de drie talen op een georganiseerde manier samen te laten werken, hebben we een aantal keuzes in de opzet van het HTML-bestand gemaakt. Die keuzes lichten we in dit deel toe, zodat je de individuele onderdelen op de HTML-pagina straks gemakkelijk kan be√Ønvloeden via JavaScript-code.\nWe beginnen met het HTMl bestand. Het bestand pagina.html bevat een section tag met daarin vier verschillende div tags:\n\u0026lt;section\u0026gt; \u0026lt;!-- In deze div kan de speler op de Cookie klikken. --\u0026gt; \u0026lt;div id=\u0026#34;klikruimte\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- In deze div laten we van elk type Clicker zien hoeveel we er hebben. --\u0026gt; \u0026lt;div class=\u0026#34;tierdisplay rows\u0026#34; id=\u0026#34;actieveClickers\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- In deze div kan de speler de verschillende Clickers kopen. --\u0026gt; \u0026lt;div class=\u0026#34;tierdisplay rows\u0026#34; id=\u0026#34;clickerWinkel\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- In deze div kan de speler Powerups voor de Clickers kopen. --\u0026gt; \u0026lt;div class=\u0026#34;tierdisplay table\u0026#34; id=\u0026#34;powerupWinkel\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; Deze divs komen overeen met de onderdelen van het originele spel en bepalen dus op welke plek van de pagina de onderdelen komen te staan. Het belangrijkste onderdeel van de divs zijn de ids. Met behulp van de ids kunnen we deze divs bereiken en gebruiken in JavaScript.\nStel bijvoorbeeld dat we in het overzicht met actieve Clickers een Clicker toe willen voegen. Om te zorgen dat we vanuit de div met actieve Clickers opereren, bereiken we deze als volgt:\nconst actieveClickerDiv = document.getElementById(\u0026#34;actieveClickers\u0026#34;) Kortom, elk onderdeel van het spel komt overeen met een div in de HTML-code! Als we bijvoorbeeld in JavaScript iets aan de Powerups willen veranderen, zoeken we de Powerup div eerst op met de correcte id! De id is in dit voorbeeld powerupWinkel.\nRelatie met de HTML-code (2) We weten nu waar de onderdelen van het spel komen te staan, maar hoe zien die onderdelen er precies uit? En wat staat er in de bijbehorende divs?\nDe meeste onderdelen bestaan uit een lijst, met een onderdeel (of: element) voor elke rang (Engels: \u0026ldquo;tier\u0026rdquo;) Clicker. Als voorbeeld kunnen we naar de Powerups kijken:\n\u0026lt;!-- In deze div kan de speler Powerups voor de Clickers kopen. --\u0026gt; \u0026lt;div class=\u0026#34;tierdisplay table\u0026#34; id=\u0026#34;powerupWinkel\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Powerups\u0026lt;/h3\u0026gt; \u0026lt;!-- Via deze div kan je de Deegroller Powerup kopen. Deze kan je als voorbeeld gebruiken. --\u0026gt; \u0026lt;div class=\u0026#34;tier0\u0026#34; onclick=\u0026#34;koopPowerup(0)\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;icon\u0026#34; src=\u0026#34;https://gartic.com.br/imgs/mural/__/__fera__/rolling-pin.png\u0026#34;\u0026gt; \u0026lt;text\u0026gt;10$\u0026lt;/text\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tier1\u0026#34; onClick=\u0026#34;koopPowerup(1)\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;icon\u0026#34; src=\u0026#34;???\u0026#34;\u0026gt; \u0026lt;text\u0026gt;???$\u0026lt;/text\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tier2\u0026#34; onClick=\u0026#34;koopPowerup(2)\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tier3\u0026#34; onClick=\u0026#34;koopPowerup(3)\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tier4\u0026#34; onClick=\u0026#34;koopPowerup(4)\u0026#34;\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; De Deegroller Powerup (tier 0) is hier volledig uitgewerkt. Het belangrijkste onderdeel van dit voorbeeld is de class van de elementen in de lijst. De class werkt op een soortgelijke manier als de id, maar een class is niet uniek. Hierdoor kunnen we het class systeem voor alle drie de lijsten gebruiken die we gaan maken. Als iets met de goedkoopste Clicker te maken heeft, heeft het class=\u0026quot;tier0\u0026quot;. De een na goedkoopste Clicker heeft class=\u0026quot;tier1\u0026quot;, etc.\nAls je een element zoekt, moet je nu echter wel zorgen dat je in de juiste lijst zoekt. De volgende code verkrijgt resultaten met class=\u0026quot;tier0\u0026quot; uit alle lijsten (actieve Clickers, Clickers winkel, Powerup winkel).\nconst tierDiv = document.getElementsByClassName(\u0026#34;tier0\u0026#34;) Dat is niet de bedoeling als we bijvoorbeeld iets aan de tier 0 Powerup willen veranderen. In plaats daarvan zorgen we dat we eerst naar de Powerups kijken, en vervolgens naar die van tier 0:\nconst actieveClickerDiv = document.getElementById(\u0026#34;powerup\u0026#34;) const tierDiv = actieveClickerDiv.getElementsByClassName(\u0026#34;tier0\u0026#34;)[0] Let op: omdat getElementsByClassName meerdere resultaten kan geven (in dit voorbeeld niet), kiezen we de eerste via [0].\nEen klikbaar koekje Aan het begin van het spel heb je nog geen Clickers en moet je handmatig je koekjes verdienen. Dit doe je door op de grote afbeelding van het koekje te klikken. Hier komen enkele dingen bij kijken:\nelke klik op de afbeelding word geregistreerd via een onClick=\u0026quot;onClickCookie()\u0026quot; HTML-attribuut; we houden de hoeveelheid koekjes bij in een variabele geld in JavaScript, deze begint op 0; de functie onClickCookie verhoogt geld met 1; een functie updateGeld zorgt dat de nieuwe waarde van geld in de HTML-code update; onClickCookie roept updateGeld aan na het verhogen van geld. Om dit te implementeren, moet je goed letten op de ids van de div- en h2 tags:\n\u0026lt;div id=\u0026#34;klikRuimte\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://www.pngall.com/wp-content/uploads/2016/07/Cookie-PNG.png\u0026#34; onClick=\u0026#34;onClickCookie()\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- In deze h2 tags laten we de huidige hoeveelheid geld zien, en hoeveel geld we per seconde verdienen. --\u0026gt; \u0026lt;h2 id=\u0026#34;geld\u0026#34;\u0026gt;Geld: 0$\u0026lt;/h2\u0026gt; \u0026lt;h2 id=\u0026#34;geldPerSeconde\u0026#34;\u0026gt;Geld per seconde: 0$\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; Voor updateGeld heb je de h2 die het geld weergeeft nodig. Als je deze eenmaal gevonden hebt, kan je de inhoud van de h2 via innerText als volgt updaten:\ngeldH2.innerText = \u0026#34;Geld: \u0026#34; + hoeveelheid + \u0026#34;$\u0026#34; Voorbeeldcode klikbaar koekje let geld = 0 /* Voegt 1$ toe en update de pagina */ function onClickCookie() { geld = geld + 1 updateGeld(geld) /* Update de pagina! */ } /* Verander het geld bedrag dat op de pagina word weergegeven naar hoeveelheid. */ function updateGeld(hoeveelheid) { const geldH2 = document.getElementById(\u0026#34;geld\u0026#34;) geldH2.innerText = \u0026#34;Geld: \u0026#34; + hoeveelheid + \u0026#34;$\u0026#34; }\rEventueel kan je `updateGeld` ook direct gebruik laten maken van de globale variabele `geld`.\rClickers winkel Als we eenmaal wat koekjes hebben, willen we het spel natuurlijk voor ons laten werken! Hiervoor gebruiken we Clickers, die je kan kopen bij de Clickers winkel. In pagina.html zien we een div met id=clickerWinkel; dit is waar we de Clickers te koop zullen zetten. In deze div vinden we de volgende HTML-code:\n\u0026lt;div class=\u0026#34;tier1 ruimte\u0026#34; onClick=\u0026#34;koopClicker(1)\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;icon\u0026#34; src=\u0026#34;???\u0026#34;\u0026gt; \u0026lt;text\u0026gt;???\u0026lt;/text\u0026gt; \u0026lt;text\u0026gt;??? $\u0026lt;/text\u0026gt; \u0026lt;/div\u0026gt; Hier kan je je eigen Clickers in zetten, met een plaatje en een prijs! Dit doe je door de ??? te vervangen. Als voorbeeld hebben we dit al gedaan voor tier0 in het HTML-bestand; hier is een chefkok met zijn cloche te zien. Je hoeft ze natuurlijk niet per se alle vijf toe te voegen.\nAls je een paar Clickers hebt, kunnen we beginnen met het toevoegen van de functionaliteit. Laten we een paar doelen vaststellen:\nelke klik op een Clicker div word geregistreerd via een onClick=\u0026quot;koopClicker(n)\u0026quot; HTML-attribuut; we maken een constante variabele met het maximum aantal Clickers van een tier, om te zorgen dat ze later op de pagina passen 1; we houden per tier Clicker bij hoeveel ze kosten; de functie koopClicker checkt of je genoeg geld hebt en of er nog niet teveel Clickers zijn; als dit het geval is, registreer dan de nieuwe Clicker en haal het geld weg (aankoop voltooid); update naderhand de pagina op basis van de veranderingen. Vooralsnog verdienen de Clickers dus nog geen koekjes voor ons, we houden enkel bij hoeveel we er van welke tier gekocht hebben.\nTip: omdat we het onderdeel Actieve Clickers nog niet hebben, is het lastig te zien of de winkel werkt. Het kan handig zijn om in clickerWinkel console.log(aantalClickers[tier]) te gebruiken, om te zien hoeveel je er hebt na aanschaf.\nVoorbeeldcode Clicker winkel const aantalClickers = [0, 0, 0, 0, 0] const clickerKosten = [1, 10, 50, 100, 500] let geld = 0 let maxAantalClickers = 14 /* Voor de basisfunctie ligt dit aan de grootte van je scherm. */ /* Koopt een Clicker, mits hier geld voor is en er nog ruimte is. Update de pagina. */ function koopClicker(tier) { if (aantalClickers[tier] \u0026gt;= maxAantalClickers) { return } if (geld \u0026lt; clickerKosten[tier]) { return } geld = geld - clickerKosten[tier] aantalClickers[tier] = aantalClickers[tier] + 1 /* Update de pagina! */ updateGeld(geld) }\rActieve Clickers inkomsten toevoegen In deze sectie zorgen we dat de actieve Clickers geld genereren. Dit doen we door elke seconde het inkomen van alle actieve Clickers bij elkaar op te tellen. Het totaal voegen we toe aan de hoeveelheid koekjes die we al hebben. Een voorbeeld:\nClicker Inkomen per seconde Aantal Totaal Kok 1 4 4 Clicker tier 1 2 1 2 Clicker tier 2 4 3 12 Clicker tier 3 0 0 0 Clicker tier 4 0 0 0 Som: 18 We hebben drie nieuwe functies nodig:\nberekenGeldPerSeconde voert de berekening uit het voorbeeld uit; updateGeldPerSeconde update de div met id=\u0026quot;geldPerSeconde\u0026quot;; koopClicker (en later koopPowerup) voeren updateGeldPerSeconde uit bij aankoop van een nieuwe Clicker. updateClickerGeld voegt de inkomsten van de Clickers toe aan het totaal, met behulp van berekenGeldPerSeconde. Om de functie updateClickerGeld elke seconde uit te voeren kan je de volgende code gebruiken:\n/* Zorgt dat updateClickerGeld elke seconde activeert. */ setInterval(updateClickerGeld, 1000) Voorbeeldcode actieve Clickers inkomsten toevoegen const aantalClickerTiers = 5 const clickerInkomsten = [1, 2, 4, 8, 32] const aantalClickers = [0, 0, 0, 0, 0] function berekenGeldPerSeconde() { let totaal = 0 for (let tier = 0; tier \u0026lt; aantalClickerTiers; tier++) { const inkomsten = clickerInkomsten[tier] const aantal = aantalClickers[tier] totaal += inkomsten * aantal } return totaal } /* Voegt het geld van de Clickers toe aan het geld. Update de pagina. */ function updateClickerGeld() { geld = geld + berekenGeldPerSeconde() /* Update de pagina! */ updateGeld(geld) } /* Zorgt dat updateClickerGeld elke seconde activeert. */ setInterval(updateClickerGeld, 1000) /* Verander het geld per seconde bedrag dat op de pagina word weergegeven naar hoeveelheid. */ function updateGeldPerSeconde(hoeveelheid) { const geldPerSecondeH2 = document.getElementById(\u0026#34;geldPerSeconde\u0026#34;) geldPerSecondeH2.innerText = \u0026#34;Geld per seconde: \u0026#34; + hoeveelheid + \u0026#34;$\u0026#34; }\rVergeet niet dat `koopClicker` (en later `koopPowerup`) `updateGeldPerSeconde` uitvoeren bij aankoop van een nieuwe Clicker!\rActieve Clickers weergeven We kunnen eindelijk werkende Clickers toevoegen, maar de pagina voelt nog erg leeg. Het zou leuk zijn om te zien welke Clickers we in dienst hebben! Hiervoor gebruiken we de div met id=\u0026quot;actieveClickers\u0026quot;. Dit is hoe de div er uit zou moeten zien na het kopen van twee Chefs:\n\u0026lt;div class=\u0026#34;tierdisplay rows\u0026#34; id=\u0026#34;actieveClickers\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Actieve Clickers\u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;tier0\u0026#34;\u0026gt; \u0026lt;!-- Per clicker van dit type voegen we een afbeelding toe. Er zijn nu 2 Chefs. --\u0026gt; \u0026lt;img src=\u0026#34;https://pngimg.com/uploads/chef/chef_PNG54.png\u0026#34; class=\u0026#34;icon\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://pngimg.com/uploads/chef/chef_PNG54.png\u0026#34; class=\u0026#34;icon\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tier1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; We gebruiken hier weer hetzelfde systeem als voorheen, waarin elk onderdeel van het spel een div is, welke een lijst met class=\u0026quot;tier\u0026quot; elementen bevat. Die elementen kunnen we dus vinden zoals voorheen! De vraag is nu: hoe voegen we hier afbeeldingen aan toe zoals in het bovenstaande voorbeeld?\nHet antwoord: via document.createElement. Via deze functie kunnen we in de JavaScript-code HTML-elementen maken, en deze later in een ander HTML-element toevoegen. Dit is te zien in het volgende voorbeeld:\nconst actieveClickerDiv = document.getElementById(\u0026#34;actieveClickers\u0026#34;) const tierDiv = actieveClickerDiv.getElementsByClassName(\u0026#34;tier0\u0026#34;)[0] const afbeelding = document.createElement(\u0026#34;img\u0026#34;) afbeelding.src = \u0026#34;\u0026#34; /* jouw afbeelding bron */ afbeelding.className = \u0026#34;icon\u0026#34; tierDiv.appendChild(afbeelding) Het voorbeeld laat alleen niet zien hoe je dit voor een willekeurige tier doet. Als je dit lastig vindt, vraag dan gerust om hulp!\nVoorbeeldcode actieve Clickers /* Een lijst met de icoontjes van de Clickers. */ clickerIcons = [ \u0026#34;https://pngimg.com/uploads/chef/chef_PNG54.png\u0026#34;, /* tier 1 */ /* tier 2 */ /* tier 3 */ /* tier 4 */ ] /* Voeg een nieuw icoontje toe aan de lijst met Actieve Clickers van tier tier */ function voegActieveClickerToe(tier) { const actieveClickerDiv = document.getElementById(\u0026#34;actieveClickers\u0026#34;) const tierDiv = actieveClickerDiv.getElementsByClassName(\u0026#34;tier\u0026#34; + tier)[0] const afbeelding = document.createElement(\u0026#34;img\u0026#34;) afbeelding.src = clickerIcons[tier] afbeelding.className = \u0026#34;icon\u0026#34; tierDiv.appendChild(afbeelding) }\rVan belang: gebruik `voegActieveClickerToe(tier)` aan het einde van de functie `koopClicker`, zodat het kopen van een Clicker van tier `tier` een nieuwe aan de lijst voor `tier` Clickers toevoegt.\rClicker Powerup winkel We kunnen nu handmatig koekjes verdienen en deze investeren in Clickers. De Clickers zijn te zien in het overzicht met actieve Clickers. Het spel voelt echter een beetje eenzijdig: klikken \u0026gt; kopen \u0026gt; klikken \u0026gt; \u0026hellip; \u0026gt; einde(?).\nEen manier om extra strategie toe te voegen is het introduceren van Powerups. Een Powerup zorgt dat de actieve Clickers van een bepaalde tier beter worden. In het voorbeeld kan je voor de Chef een deegroller kopen: deze zorgt dat de Chef twee keer zoveel koekjes per seconde kan produceren.\nIn deze instructie zullen we √©√©n Powerup per tier Clicker maken. Dit is net iets simpeler dan in het originele spel, maar je kan het later uitbreiden! De HTML-code voor Powerups lijkt erg op die van de Clicker winkel:\n\u0026lt;!-- In deze div kan de speler Powerups voor de Clickers kopen. --\u0026gt; \u0026lt;div class=\u0026#34;tierdisplay table\u0026#34; id=\u0026#34;powerupWinkel\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Powerups\u0026lt;/h3\u0026gt; \u0026lt;!-- Via deze div kan je de Deegroller Powerup kopen. Deze kan je als voorbeeld gebruiken. --\u0026gt; \u0026lt;div class=\u0026#34;tier0\u0026#34; onclick=\u0026#34;koopPowerup(0)\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;icon\u0026#34; src=\u0026#34;https://gartic.com.br/imgs/mural/__/__fera__/rolling-pin.png\u0026#34;\u0026gt; \u0026lt;text\u0026gt;10$\u0026lt;/text\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;tier1\u0026#34; onClick=\u0026#34;koopPowerup(1)\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;icon\u0026#34; src=\u0026#34;???\u0026#34;\u0026gt; \u0026lt;text\u0026gt;???$\u0026lt;/text\u0026gt; \u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; Ook hier komt een kort plan van aanpak van pas:\nelke klik op een Clicker div word geregistreerd via een onClick=\u0026quot;koopPowerup(n)\u0026quot; HTML-attribuut; we houden per tier Clicker bij of de Powerup al gekocht is; de functie koopPowerup check of je genoeg geld hebt en of de Powerup nog niet gekocht is; als dit het geval is, registreer dan de nieuwe Powerup en haal het geld weg (aankoop voltooid); update naderhand de pagina op basis van de veranderingen. Ook moeten we zorgen dat we ergens een lijstje bijhouden met de inkomsten per seconde van elke Clicker. Als de Powerup is gekocht, vermenigvuldigen we die inkomsten met twee.\nTip: als de aanschaf van een Powerup succesvol is, moeten we zorgen dat men deze niet nogmaals kan kopen. Je kan de Powerup uit de lijst halen via:\nconst tierDiv = ... tierDiv.remove() Voorbeeldcode Powerup winkel const powerupKosten = [10, 100, 500, 1000, 5000] let geld = 0 const beschikbarePowerups = [true, true, true, true, true] const clickerInkomsten = [1, 2, 4, 8, 32] /* Koopt een Powerup, mits hier geld voor is en de powerup nog niet gekocht is. Update de pagina. */ function koopPowerup(tier) { if (beschikbarePowerups[tier] == false) { return } if (geld \u0026lt; powerupKosten[tier]) { return } beschikbarePowerups[tier] = false; geld = geld - powerupKosten[tier] clickerInkomsten[tier] = clickerInkomsten[tier] * 2 /* Update de pagina! */ verwijderPowerup(tier) updateGeldPerSeconde(berekenGeldPerSeconde()) updateGeld(geld) } /* Verwijder de Powerup voor tier tier uit de lijst. */ function verwijderPowerup(tier) { const powerupDiv = document.getElementById(\u0026#34;powerupWinkel\u0026#34;) const tierDiv = powerupDiv.getElementsByClassName(\u0026#34;tier\u0026#34; + tier)[0] tierDiv.remove() }\rUitbreidingen Allereerst: gefeliciteerd met het halen van het einde van deze instructie!\nEr zijn een hoop uitbreidingen mogelijk op het basisconcept:\nde kosten van Clickers verhogen na elke aankoop; meerde Powerups per Clicker; meer Clickers toevoegen; Hier kan je zelf mee aan de slag gaan en natuurlijk extra hulp bij vragen.\nLaat ons eventueel weten of er nog andere uitbreidingen zijn die je in deze instructie zou willen zien!\nTop secret De volledige voorbeeldcode /* Een lijst met de icoontjes van de Clickers. */ clickerIcons = [ \u0026#34;https://pngimg.com/uploads/chef/chef_PNG54.png\u0026#34;, /* tier 1 */ /* tier 2 */ /* tier 3 */ /* tier 4 */ ] /* De volgende functies be√Ønvloeden het uiterlijk van de pagina. */ /* Voeg een nieuw icoontje toe aan de lijst met Actieve Clickers van tier tier */ function voegActieveClickerToe(tier) { const actieveClickerDiv = document.getElementById(\u0026#34;actieveClickers\u0026#34;) const tierDiv = actieveClickerDiv.getElementsByClassName(\u0026#34;tier\u0026#34; + tier)[0] const afbeelding = document.createElement(\u0026#34;img\u0026#34;) afbeelding.src = clickerIcons[tier] afbeelding.className = \u0026#34;icon\u0026#34; tierDiv.appendChild(afbeelding) } /* Verander het geld bedrag dat op de pagina word weergegeven naar hoeveelheid. */ function updateGeld(hoeveelheid) { const geldH2 = document.getElementById(\u0026#34;geld\u0026#34;) geldH2.innerText = \u0026#34;Geld: \u0026#34; + hoeveelheid + \u0026#34;$\u0026#34; } /* Verander het geld per seconde bedrag dat op de pagina word weergegeven naar hoeveelheid. */ function updateGeldPerSeconde(hoeveelheid) { const geldPerSecondeH2 = document.getElementById(\u0026#34;geldPerSeconde\u0026#34;) geldPerSecondeH2.innerText = \u0026#34;Geld per seconde: \u0026#34; + hoeveelheid + \u0026#34;$\u0026#34; } /* Verwijder de Powerup voor tier tier uit de lijst. */ function verwijderPowerup(tier) { const powerupDiv = document.getElementById(\u0026#34;powerupWinkel\u0026#34;) const tierDiv = powerupDiv.getElementsByClassName(\u0026#34;tier\u0026#34; + tier)[0] tierDiv.remove() } /* Vanaf hier focussen we op de functionaliteit! */ /* De volgende gegevens veranderen niet. */ const aantalClickerTiers = 5 const clickerKosten = [1, 10, 50, 100, 500] const powerupKosten = [10, 100, 500, 1000, 5000] /* De volgende gevevens kunnen veranderen. */ let geld = 0 let maxAantalClickers = 14 /* Voor de basisfunctie ligt dit aan de grootte van je scherm. */ const clickerInkomsten = [1, 2, 4, 8, 32] const aantalClickers = [0, 0, 0, 0, 0] const beschikbarePowerups = [true, true, true, true, true] /* Voegt 1$ toe en update de pagina */ function onClickCookie() { geld = geld + 1 updateGeld(geld) /* Update de pagina! */ } /* Berekent het geld dat de Clickers genereren per seconde. */ function berekenGeldPerSeconde() { let totaal = 0 for (let tier = 0; tier \u0026lt; aantalClickerTiers; tier++) { const inkomsten = clickerInkomsten[tier] const aantal = aantalClickers[tier] totaal += inkomsten * aantal } return totaal } /* Koopt een Powerup, mits hier geld voor is en de Powerup nog niet gekocht is. Update de pagina. */ function koopPowerup(tier) { if (beschikbarePowerups[tier] == false) { return } if (geld \u0026lt; powerupKosten[tier]) { return } beschikbarePowerups[tier] = false; geld = geld - powerupKosten[tier] clickerInkomsten[tier] = clickerInkomsten[tier] * 2 /* Update de pagina! */ verwijderPowerup(tier) updateGeldPerSeconde(berekenGeldPerSeconde()) updateGeld(geld) } /* Koopt een Clicker, mits hier geld voor is en er nog ruimte is. Update de pagina. */ function koopClicker(tier) { if (aantalClickers[tier] \u0026gt;= maxAantalClickers) { return } if (geld \u0026lt; clickerKosten[tier]) { return } geld = geld - clickerKosten[tier] aantalClickers[tier] = aantalClickers[tier] + 1 /* Update de pagina! */ voegActieveClickerToe(tier) updateGeldPerSeconde(berekenGeldPerSeconde()) updateGeld(geld) } /* Voegt het geld van de Clickers toe aan het geld. Update de pagina. */ function updateClickerGeld() { geld = geld + berekenGeldPerSeconde() /* Update de pagina! */ updateGeld(geld) } /* Zorgt dat updateClickerGeld elke seconde activeert. */ setInterval(updateClickerGeld, 1000)\rLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. Er is immers geen ruimte op het scherm voor 100 kok icoontjes!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"July 28, 2022","permalink":"/instructies/ontbijtkoekclicker/","title":"Web - Ontbijtkoekclicker"},{"categories":null,"contents":"\nDeze maand gaan we met de talen van het Internet aan de gang: HTML, CSS en JavaScript.\nOm meer te leren over hoe je inhoud geeft aan een webpagina, hoe je deze er mooi uit kunt laten zien en hoe je er acties aan kunt toevoegen.\nWe zijn bezig met een nieuwe instructie ge√Ønspireerd door √©√©n van de ninjas: Cookie Clicker. De instructie is nog niet helemaal af, maar als je het leuk vind mag je het alvast uitproberen!\nMisschien hebben we deze dojo ook nog de gelegenheid om \u0026ldquo;Levend te programmeren\u0026rdquo;! Voorbereiding\nNeem een laptop en een goed humeur mee.Algemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om¬†√©√©n van je ouders¬†mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te¬†eten¬†mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even¬†reserveren. Je hebt¬†√©√©n ticket per kind¬†nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je¬†ticket mee te nemen naar CoderDojo¬†(dit mag digitaal).CoderDojo en Corona\nWe houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 6 augustus 2022, van 12:00u tot 14:30u.\nWe zitten in bibliotheek Gelderland Zuid, vestiging Zwanenveld. Het adres is Zwanenveld 9098, 6538 SC Nijmegen.No show?\nBen je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"July 22, 2022","permalink":"/dojos/87-websites-maken/","title":"#87: Websites maken"},{"categories":null,"contents":"\nBij deze dojo bepaal je zelf waar je mee aan de slag gaat, en helpen wij je daarbij (als je niet kunt kiezen kunnen we je daar ook bij helpen)! Dus wil je programmeren met Scratch, Python, of L√∂ve, een webpagina maken of bijvoorbeeld een spel in MakeCode Arcade - schrijf je in voor de dojo en we helpen je met je uitdaging of opdracht. Zie bijvoorbeeld de projecten van de Raspberry Pi Foundation of die CoderDojo Nijmegen hier en hier heeft staan.\nVoorbereiding Neem een laptop en een goed humeur mee.Algemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).CoderDojo en Corona\nWe houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 2 juli 12:00u tot 14:30u. We zitten in bibliotheek Gelderland Zuid, vestiging Zwanenveld. Het adres is Zwanenveld 9098, 6538 SC Nijmegen.No show?\nBen je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"June 22, 2022","permalink":"/dojos/86-kies-je-eigen-onderwerp/","title":"#86: Kies je eigen onderwerp"},{"categories":null,"contents":"\nIn juni is de dojo op een bijzondere locatie, we zijn namelijk te gast in Museum Het Valkhof. Wat gaan we daar doen? Kunst maken met de computer! We hebben instructies met Scratch, Python en p5.js dus voor zowel kinderen zonder als met wat meer programmeerervaring zijn er uitdagende kunstwerken te maken - en zelf te bedenken.\nLet op: de tijd is anders dan meestal, de dojo begint namelijk om 11.00 en eindigt om 13.30!Voorbereiding Neem een laptop en een goed humeur mee.Algemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).CoderDojo en Corona\nWe houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 4 juni van 11:00u tot 13:30u. We zitten in de Museum Het Valkhof, het adres is Kelfkensbos 59, 6511 TB Nijmegen.No show?\nBen je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"May 23, 2022","permalink":"/dojos/85-kunst-met-scratch-python-en-p5.js/","title":"#85: Kunst, met Scratch, Python en p5.js"},{"categories":null,"contents":"\nNa de afgelopen periode met online dojos en een tijdelijke stop, starten we op zaterdag 7 mei weer met een live dojo!\nWe zijn dan weer te gast bij bibliotheek Zwanenveld.\nWat gaan we daar doen? We gaan aan de slag met de micro:bit!\nOpdrachten voor de micro:bit kun je op verschillende plekken vinden, bijvoorbeeld\ninstructies op de CoderDojo Nijmegen site\ninstructies op de Raspberry Pi Foundation websiteVoorbereiding\nNeem een laptop en een goed humeur mee.Algemene info\nKinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).CoderDojo en Corona\nWe houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 7 mei van 12:00u tot 14:30u. We zitten in de bibliotheek Gelderland Zuid, vestiging Zwanenveld. Het adres is Zwanenveld 9098, 6538 SC Nijmegen.No show?\nBen je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"March 19, 2022","permalink":"/dojos/84-microbit/","title":"#84: micro:bit"},{"categories":null,"contents":"Spiekbriefje met veelgebruikte Processing-instructies.\nHet spiekbriefje is ook als Processing_spiekbriefje.pdf te downloaden.\nAls je eerst nog wat meer uitleg wil over kunst maken met Processing, kun je deze uitleg downloaden: Processing3-Coderdojo-Nm.pdf.\nBasis van een Processing-script void setup() { // √©√©n keer doen } void draw() { // steeds opnieuw } Vormen Rechthoek rect(20, 20, 40, 40); rechthoek\nEllips ellipse(0, 0, 80, 40); ronde vorm van 80 pixels breed en 40 hoog\nLijn line(20, 20, 80, 50); rechte lijn met beginpunt 20,20 en eindpunt 80,50\nVierhoek quad(152, 124, 344, 80, 276, 252, 120, 304); vierhoek\nAndere vormen arc(50, 50, 80, 80, PI); halve cirkel curve gebogen lijnen bezier nog meer gebogen lijnen beginShape, vertex en endShape complexe vormen Kleur background(255); achtergrondkleur fill(100); inkleuren noFill(); niet inkleuren stroke(30); kleur van randen strokeWeight(5); dikte van randen noStroke(); geen randen Voorbeelden:\nfill(200); √©√©n getal is een grijswaarde tussen zwart (0) en wit (255) fill(255, 20); twee getallen: grijswaarde en doorzichtigheid fill(255, 40, 200); drie getallen: rood, groen en blauw mengen fill(255, 100, 100, 30); rood, groen, blauw en doorzichtigheid Grootte van het Processing-scherm size(200, 200); grootte scherm opgeven fullScreen(); scherm beeldvullend maken width breedte van scherm als variabele height hoogte van scherm als variabele Het midden van het scherm vind je door width en height door twee√´n te delen:\nrect(width/2, height/2, 40, 40); Muis en toetsenbord mouseX horizontale positie van je muis mouseY verticale positie van je muis Deze woorden kun je gebruiken in een if-statement of als functie:\nmousePressed ‚Äòtrue‚Äô als je op muis klikt mouseDragged ‚Äòtrue‚Äô als je muis over het scherm sleept mouseMoved als de muis beweegt zonder dat de knop is ingedrukt keyPressed ‚Äòtrue‚Äô als je typt key variabele met de laatst getypte toets Variabelen In verschillende variabelen kun je verschillende soorten informatie bewaren:\nint hele getallen, positief of negatief\nfloat decimale getallen\nboolean waar/niet waar, ‚Äòtrue‚Äô of ‚Äòfalse‚Äô\nstring een tekst\nchar een enkele letter\ncolor een kleur\nint getal = 10;\nfloat variabele1 = 3.01;\nVragen stellen if (voorwaarde) { .. } if-statement // zijn het er meer dan 10? if (aantal \u0026gt; 10) { // zo ja, doe dan hier iets } \u0026lt; kleiner dan \u0026gt; groter dan == gelijk aan != niet gelijk aan Iets meerdere keren doen while (voorwaarde) { .. } while loop: blijf iets doen zolang de voorwaarde waar is for (int i=0; i \u0026lt; 10; i++) { .. } for-loop (in dit voorbeeld): begin bij 0, ga door zolang we nog niet bij 10 zijn, en tel er steeds 1 bij op. Steeds anders random() kies een willekeurig getal noise() willekeurig, maar wel steeds dichtbij het getal ervoor frameCount aantal beeldjes in de animatie tot nu toe Het canvas verschuiven of draaien float r; // variabele void setup() { rectMode(CENTER); } void draw() { background(51); translate(width/2, height/2); rotate(r); // draaiing rect(0, 0, 60, 60); // klein beetje verder draaien r += 0.02; } rotate(0.1); draai het canvas rond 0,0 translate(300, 300); verplaats het beginpunt van het canvas (dus 0,0) van linksbovenin naar ergens anders (bijvoorbeeld het midden). pushMatrix(); onthou alle rotates en translates die hierna komen popMatrix(); maak alle rotates en translates ongedaan voor alles wat hierna komt. Nummers passend maken met map() Waarde (bijvoorbeeld de muispositie) ‚Äòvertalen‚Äô naar een ander bereik:\nfloat h = map(mouseX, 0, width, 40, 300);\nAfstand tot een bepaald punt met dist() void draw() { float d = dist(50, 50, mouseX, mouseY); float gray = map(d, 0, 100, 0, 255); fill(gray); rect(0, 0, width, height); } Tekst invoegen textSize(20); text(\u0026#34;tekst komt\u0026#34;, 6, 20); textSize(50); text(\u0026#34;hier\u0026#34;, 6, 70); Plaatjes inladen PImage foto; // variabele void setup() { size(400, 400); // laad een plaatje in die in // dezelfde map staat als dit script foto = loadImage(\u0026#34;foto.jpg\u0026#34;); } void draw() { // laat het plaatje zien image(foto, 0, 0); } Golfbewegingen met sinus Gebruik sin() en cos() om golvende veranderingen te krijgen: float hoek = 0; // variabele void draw( ) { background(0); // sinus gebruiken als grootte circle(50, 50, sin(hoek)*100); // hoek een klein beetje veranderen hoek += 0.02; }\nMeer informatie en inspiratie Dit zijn nog lang niet alle functies in Processing! Op https://processing.org/reference vind je alle functies m√©t uitleg.\nMooie voorbeelden van wat er allemaal kan met Processing zie je op\nhttps://processing.org/examples https://openprocessing.org https://reddit.com/r/processing/ http://generative-gestaltung.de/2/ Probeer het! Maak een vierkant dat steeds opnieuw getekend wordt op de plek van je muis. Teken steeds een nieuwe achtergrond in draw() met een kleur die verandert met de muispositie.\nTeken een puntje op de plek waar de muis is. Zet geen background() in draw(). Probeer het ook met andere vormen en kleuren, ook met half-doorzichtige. Kun je een tweede vorm maken die in omgekeerde richting beweegt?\nTeken een vorm die van heel klein steeds een beetje groter wordt (met een variabele, niet op basis van de muis). Laat hem opnieuw klein beginnen als je op de muis klikt √≥f als hij groter wordt dan de breedte van het scherm. Gebruik dezelfde variabele ook om de positie en kleur te veranderen.\nTeken een stuk of 10 vierkantjes onder elkaar. Laat ze horizontaal mee-veranderen met de muispositie, maar zorg dat elk vierkantje dat n√®t iets anders doet. (Tip: je kunt getallen bij mouseX optellen, maar mouseX ook vermenigvuldigen en delen! Vermenigvulden doe je met * en delen met /.)\nMaak confetti! Teken steeds een nieuwe kleine cirkel op steeds een andere plek met steeds een andere kleur. (Tip: gebruik random() voor de x- en y-positie √©n voor de kleuren. Probeer ook een donkere achtergrond!)\nTeken een bijna helemaal doorzichtig rondje met dikke rand op een lichte achtergrond. Teken die achtergrond niet in draw().\nMaak een bloem met overlappende cirkels!\nSchrijf een woord steeds ergens anders op het scherm, met steeds een andere kleur.\nSchrijf smileys met tekst (:-)) met een gele cirkel eromheen, steeds op een andere plek. (Probeer het eerst op de simpelste manier. Als je daarna ook nog translate() en rotate() gebruikt, dan kun je de smileys ook nog om hun as laten draaien!)\nTeken een vorm die steeds van plek verandert. Als hij bij de randen aankomt, laat hem dan van kleur veranderen en een andere kant op gaan. (Hier heb je variabelen bij nodig om de x- en y-positie van je vorm op te slaan, en een paar if-statements.)\nTeken twee vormen naast elkaar. De grootte van de ene is afhankelijk van de muispositie, die van de andere van de muispositie min ongeveer de helft van de breedte van het scherm.\nTeken een cirkel die van kleur verandert als je dichterbij komt.\u2028(Tip: dit is het makkelijkst met dist().)\nTeken 8 cirkels die in elkaar zitten. (Tip: gebruik een while-loop of for-loop.)\nMaak een spiraal! Gebruik translate() en rotate() om vormen niet alleen verder weg te laten bewegen, maar ook steeds verder van een middelpunt af te tekenen.\nTeken een bijna helemaal doorzichtige lijn helemaal van bovenaan het scherm naar onderaan. Gebruik je muis als horizontale positie. Teken geen achtergrond in draw().\nVerplaats het beginpunt van je canvas naar ergens met translate(), laat het canvas steeds een klein beetje ronddraaien met rotate() en teken een of meer rechthoeken.\nTeken heel veel kleine rondjes naast elkaar en verander elke keer de kleur een klein beetje. Probeer ze in een cirkel te laten tekenen met rotate()!\nTeken meerdere vormen waarvan je de positie (of draaiing) met een sinus-functie bepaalt.\nMaak een soort zon door driehoeken en lijnen rond een middelpunt te tekenen. (Tip: gebruik translate() en rotate().)\nVerder vari√´ren met\nVorm Grootte Kleur (en doorzichtigheid) Positie Beweging (snelheid en richting) Rotatie Aantal Blijvend in beeld of niet Input van het toetsenbord Probeer ook tekst, image, video, webcam en sound! Zie de voorbeeld-scripts in Processing onder het menu Bestand \u0026gt; Voorbeelden.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"December 8, 2021","permalink":"/instructies/processing-spiekbriefje/","title":"Processing - Spiekbriefje"},{"categories":null,"contents":"\nWat gaan we doen? Deze maand zullen we de dojo weer online organiseren vanwege de nieuwe maatregelen. We bouwen voort op het onderwerp van vorige keer! Kunst en games maken met processing (p5.js).\nOp de informatiepagina van het online evenement plaatsen we de link naar de Jitsi sessie en de instructies die we voor deze dojo gaan gebruiken.\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Als je vooraf een opdracht uitzoekt, kijk dan alvast of je hier software voor moet installeren - dat scheelt tijd tijdens de dojo!\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het fijn als een ouder of verzorger je kan begeleiden tijdens de dojo.\nWanneer en waar? Zaterdag 11 december van 12:30u tot 14:30u.\nVoor deze dojo blijf je THUIS, achter de computer.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"November 24, 2021","permalink":"/dojos/83-online-kunst-en-games-met-p5.js/","title":"#83 online: Kunst en games met P5.js"},{"categories":null,"contents":"Kunst maken in de browser.\nIntroductie Naast kunst met Scratch en Python, kan je ook kunst programmeren met Processing.\nEr is een Processing variant voor in de browser. Deze heet p5.js. We gaan er in deze instructie mee aan de slag. Eerst een voorbeeld van wat je ermee kunt doen:\nde code bij dit voorbeeld Favoriet van Jaap! üòâ\nKopie van Sketch 422446.\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 var circle = 200; var rot; var col; var freq = 0.000005; var cont = 0; var r; function setup() { createCanvas(600, 600); } function draw() { background(242); translate(300, 300); rotate(radians(rot)); ellipseMode(RADIUS); for (var i=0; i\u0026lt;500; i ++) { circle= 200 + 50*sin(millis()*freq*i); col=map(circle,150,250,255,60); r=map(circle,150,250,5,2); fill(col,0,74); noStroke(); ellipse(circle*cos(i), circle*sin(i),r,r); rot=rot+0.00005; } } Editor p5.js is een Javascript bibliotheek. Deze kun je in elke webpagina integreren. Je kunt \u0026ldquo;sketches\u0026rdquo; schrijven in een editor op je PC en het resultaat dan bekijken in een webbrowser. Het is echter makkelijker om een editor in de browser zelf te gebruiken. Ga daarvoor naar deze editor.\nDe volgende instructies en voorbeelden gaan ervan uit dat je deze editor gebruikt.\nDe basis p5.js sketches hebben de volgende basis:\n1 2 3 4 5 6 7 function setup() { createCanvas(100, 100); } function draw() { background(255, 0, 200); } Er zijn twee functies die worden aangeroepen door de p5.js bibliotheek:\nsetup() wordt √©√©nmaal bij de start van het script uitgevoerd draw() wordt oneindig herhaald en iedere schermvernieuwing aangeroepen (normaal 60 keer per seconde) In de setup() functie zet je √©√©nmalige instellingen, zoals bijvoorbeeld een vaste achtegrondkleur. In de draw() functie dingen die veranderen, zoals bijvoorbeeld een verschuivende kubus.\nHet volgende voorbeeld tekent een draaiend vierkant:\n1 2 3 4 5 6 7 8 9 10 function setup() { createCanvas(150, 150); } function draw() { background(255); translate(width / 2, height / 2); rotate(frameCount/50); rect(-26, -26, 52, 52); } We zullen stap voor stap door de code heen lopen:\nop regel 2 in de setup functie wordt het tekenblad (canvas) gemaakt. Dit hoeft slechts 1 keer te gebeuren. regels 6 tot en met 9 worden telkens herhaald: background(255) maakt de achtergrond kleur wit (waarde 255). translate(width / 2, height / 2) zorgt ervoor dat het vierkant midden in het tekenblad komt. rotate(frameCount / 50) draait het vierkant iedere keer dat dit wordt uitgevoerd. frameCount staat voor het aantal schermvernieuwingen per seconde. Daardoor bepaald frameCount / 50 de snelheid waarmee het vierkant draait. tenslotte tekent rect(-26, -26, 52, 52) het vierkant. Opdracht 1: neem de code over in de editor en kijk of er een draaiend vierkant wordt getekend door op de speel knop te klikken.\nOpdracht 2: vervang waarde 255 op regel 6 eens met een andere waarde tussen 0 en 256. Wat gebeurt er met een lage waarde? En wat met een hoge?\nOpdracht 3: misschien vraag je je af waarom de achtergrond iedere keer opnieuw moet worden getekend? Door // voor de regel te zetten, maak je er commentaar van en wordt het niet meer uitgevoerd. Zet // voor regel 6. Wat gebeurt er?\nOpdracht 4: regel 8 zorgt ervoor dat het vierkant draait. Verander waarde 50 eens door 10. Wat gebeurt er? En bij een waarde van 100?\nOpdracht 5: regel 9 tekent het vierkant. De eerste twee getallen -26 verschuiven het draaipunt van het vierkant horizontaal en verticaal. De twee laatste bepalen de hoogte en breedte. Vervang de getallen 52 eens door 75. Wat gebeurt er? En als je √©√©n van de twee 52 laat en de ander veranderd naar 75?\nNa het uitvoeren van deze eerste opdrachten begrijp je een beetje hoe het werkt. In de volgende hoofdstukken gaan we verder met meer voorbeelden en uitleg.\nCirkels en muis In dit hoofdstuk gaan we kunst maken met je muis. Beweeg je muis maar eens over het grijze vlak hieronder. üòâ\nStap voor stap gaan we dit nabouwen.\rTekenvlak We openen nu een nieuw venster om opnieuw te beginnen. Ga daarvoor naar deze editor.\nWe beginnen met het vlak waarin we de cirkels gaan tekenen:\n1 2 3 4 5 6 7 function setup() { createCanvas(710, 400); background(102); } function draw() { } Opdracht 6: neem bovenstaande code over in de editor en voer het programma uit. Je hebt nu een grijs vlak.\nEen cirkel De volgende stap is een cirkel:\n1 2 3 4 5 6 7 8 function setup() { createCanvas(710, 400); background(102); } function draw() { ellipse(300, 200, 60, 60); } Opdracht 7: neem regel 7 over in je code en voer het programma uit. Er verschijnt nu een witte cirkel in het grijze vlak. Wat gebeurt er als je de getallen 300 en 200 veranderd? En als je de getallen 60 veranderd?\nDe cirkel bewegen met de muis Om de cirkel te bewegen met de muis, moet je er voor zorgen dat de cirkel de positie van de muis volgt:\n1 2 3 4 5 6 7 8 function setup() { createCanvas(710, 400); background(102); } function draw() { ellipse(mouseX, mouseY, 60, 60); } Opdracht 8: vervang de getallen 300 en 200 in regel 7 met mouseX en mouseY. Deze twee variabelen bevatten de horizontale positie (mouseX) en vertikale positie (mouseY) van de muis. Voor je programma uit. Beweegt de cirkel mee?\nEen kleurtje voor de cirkel Het voorbeeld heeft een gekleurde cirkel. Laten we eens een kleurtje toevoegen:\n1 2 3 4 5 6 7 8 9 function setup() { createCanvas(710, 400); background(102); } function draw() { fill(color(255, 128, 0)); ellipse(mouseX, mouseY, 60, 60); } Opdracht 9: voeg regel 7 toe aan je code. Welke kleur heeft de cirkel?\nHet commando fill() vult het figuur dat erna wordt getekend met de kleur die wordt bepaald door het commando color(). Het commando color() heeft 3 parameters, een voor rood, een voor groen en een voor blauw. Alle drie de kleuren kunnen met een getal tussen 0 en 255 worden bepaald. 0 is geen kleur en 255 is maximaal kleur. color(0, 0, 0) komt daarmee overeen met zwart en color(255, 0, 0) met helder rood.\nOpdracht 10: speel met de kleur van de cirkel door met de getallen 255, 128 en 0 op regel 7 te vari√´ren.\nDe cirkel grootte afhankelijk van de snelheid Als je de snelheid van de muis berekent, kun je die gebruiken om de grootte van de cirkel ermee aan te passen:\n1 2 3 4 5 6 7 8 9 10 function setup() { createCanvas(710, 400); background(102); } function draw() { let snelheid = abs(mouseX - pmouseX) + abs(mouseY - pmouseY); fill(color(255, 128, 0)); ellipse(mouseX, mouseY, snelheid, snelheid); } Opdracht 11: voeg regel 7 toe en pas regel 9 aan. Wordt de cirkel groter en kleiner als je je muis sneller en langzamer beweegt?\nOp regel 7 wordt de snelheid van de muis berekend. Wil je daar meer over weten, lees dan door in onderstaande grijze vak.\nHoe bereken je de snelheid van de muis? Op het moment dat je je muis beweegt, dan beweegt het horizontaal, vertikaal of in beide richtingen als je je muis schuin beweegt. Als je je muis langzaam beweegt, dan verschuift het een kleiner stukje per seconde dan als je het sneller beweegt.\nDe verschuiving die je doet, kun je berekenen door het verschil te bepalen tussen de vorige positie en de huidige. In p5.js geven pmouseX en pmouseY de vorige horizontale en vertikale positie en mouseX en mouseY de huidige.\nDe horizontale en vertikale verschuiving kun je als volgt tekenen:\nEen schuine beweging, zoals getekend in het plaatje, is het resultaat van een horizontale en vertikale verschuiving. De lengte van de schuine pijl is dan een maat voor de snelheid. Hoe langer de pijl, hoe groter de verschuiving en dus hoe groter de snelheid.\nDe code bevat een berekening voor de maat van de snelheid (niet 100% correct, maar voldoende voor dit doel). Het telt de horizontale verschuiving (abs(mouseX - pmouseX) op bij de vertikale verschuiving (abs(mouseY - pmouseY)).\nDe kleur afhankelijk van de snelheid Naast de grootte van de cirkel is ook de kleur in het voorbeeld afhankelijk van de snelheid van de muis. We hebben de snelheid al berekend, nu gaat we die gebruiken bij het inkleuren van de cirkel:\n1 2 3 4 5 6 7 8 9 10 11 function setup() { createCanvas(710, 400); background(102); } function draw() { let snelheid = abs(mouseX - pmouseX) + abs(mouseY - pmouseY); let kleur = color(255 - snelheid, snelheid, 128 + snelheid); fill(kleur); ellipse(mouseX, mouseY, snelheid, snelheid); } Met het commando color op regel 8 kunnen we een kleur maken. Het commando heeft 3 parameters. Het eerste bepaald de hoeveelheid rood (R), het tweede de hoeveelheid groen (G) en het derde en laatste de hoeveelheid blauw (B). Deze RGB waarde zorgt samen een mengsel van de drie kleuren. Daarbij zorgt color(255, 255, 255) voor wit (alle kleuren maximaal) en color(0, 0, 0) voor zwart (alle kleuren uit).\nIn het voorbeeld wordt voor rood de snelheid van 255 afgetrokken. Dus, hoe sneller de muis beweegt, hoe minder rood er in de kleur zit. Bij de middelste kleur, groen, is hoeveelheid direct afhankelijk van de snelheid. Hoe sneller, hoe meer groen er in de kleur zit. Tenslotte zit er bij blauw een minimum van 128 in de kleur en neemt de hoeveelheid blauw toe als de snelheid van de muis toeneemt.\nTenslotte wordt de cirkel ingekleurd met het commando fill(kleur).\nOpdracht 12: wissel de berekening per kleur eens met een andere kleur. Dus bijvoorbeeld 255 - snelheid voor groen in plaats van voor rood. Welke kleuren krijg je?\nGames met P5.js We hebben gezien dat we hele mooie kunst kunnen maken. Ook hebben we programma\u0026rsquo;s gemaakt waar we zelf iets kunnen besturen, bijvoorbeeld met de muis. Nu hebben we alle ingredi√´nten om ook games te gaan bouwen!\nIn de volgende instructies ga je een spel maken waar je op doelwitten moet klikken. De doelwitten verdwijnen langzaam, en als je te langzaam bent verlies je. Het doel is om zoveel mogelijk doelwitten aan te klikken voordat je verliest!\nOnderstaand een demo van de game:\nOpdracht 13 We beginnen met het maken van een canvas van 400 bij 400 pixels. 1 2 3 4 5 6 7 function setup() { createCanvas(400, 400); } function draw() { background(255); } Opdracht 14 Om het spel goed te laten verlopen, moeten we verschillende gegevens bijhouden. Zo willen we bijvoorbeeld weten hoeveel levens de speler nog heeft, zodat we later kunnen bepalen of het spel over is. Daarnaast houden we bij hoe snel de doelwitten krimpen en welke doelwitten we allemaal hebben.\n1 2 3 4 5 6 7 8 9 10 11 let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); } function draw() { background(255); } Opdracht 15 Het is handig als de speler weet hoeveel levens hij nog heeft. Laten we dat toevoegen. De tekst wordt 20 pixels van links, en 20 pixels vanaf boven getekend. Probeer de tekst zelf eens te verplaatsen naar een andere hoek. 1 2 3 4 5 6 7 8 9 10 11 12 let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); } Opdracht 16 Laten we wat doelwitten te voorschijn toveren. Onze doelwitten worden cirkels. Om cirkels te tekenen, kunnen we de ellipse functie gebruiken.\nWe hebben eerder al een lijst met doelwitten gemaakt: hier zorgt de eerste regel voor. We gaan nu elk doelwit in de lijst met doelwitten af en tekenen ze op het scherm. Dit doen wij met een for-loop.\nJe code zal er (ongeveer) uit zien als volgt. Dit is een lastig onderdeel van de opdracht, dus als je hier vragen over hebt, stel deze dan vooral!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten ellipse(t.x, t.y, t.d, t.d); } } Opdracht 17 Je zult zien dat er nog niks getekend wordt. Dat komt omdat we nog geen doelwitten hebben toegevoegd aan onze lijst. We kunnen de doelwitten op onderstaande manier toevoegen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); //voeg begin doelwitten toe doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten ellipse(t.x, t.y, t.d, t.d); } } Opdracht 18 Cool! Maar er gebeurt nog steeds niks. We voegen een regel toe zodat de doelwitten langzaam krimpen.\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten t.d -= krimpSnelheid; } } Opdracht 19 Als je het programma nu draait en lang genoeg wacht, dan zullen de cirkels verdwijnen. Maar wacht eens: ze komen daarna weer terug?!\nDit gebeurt omdat de grootte van de cirkels negatief wordt na een tijdje. De computer interpreteert dit echter als een positief getal. Omdat dit niet de bedoeling van het spel is, moeten we een doelwit weggooien als het te klein is om nog verder te kunnen krimpen.\nDan doen we met onderstaande code:\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten t.d -= krimpSnelheid; //verwijder te kleine doelwitten if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen doelwitten.splice(i, 1); //Haal het doelwit uit de lijst. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. } } } Opdracht 20 In deze stap programmeren we dat we op doelwitten kunnen klikken, om deze te verwijderen. Dat doen we als volgt: De functie mouseClicked() activeert wanneer je klikt. Plaats deze functie helemaal onderaan in het bestand. Probeer elke regel te begrijpen en vraag om hulp als er iets onduidelijk is!\n38 39 40 41 42 43 44 45 46 47 48 49 50 51 function mouseClicked() { for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Bereken de afstand tussen de muis en het doelwit let afstand = dist(mouseX, mouseY, t.x, t.y); if(afstand \u0026lt; t.d/2) { //Als de afstand kleiner is dan de halve diameter (radius) van het doelwit is het raak doelwitten.splice(i, 1); //Verwijder het doelwit dat geraakt is doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. return; } } } Opdracht 21 Wat nu? De speler kan nog niet verliezen. We voegen toe dat de speler een leven verliest als een doelwit verdwijnt waar hij niet op klikt.\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten t.d -= krimpSnelheid; //verwijder te kleine doelwitten if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen doelwitten.splice(i, 1); //Haal het doelwit uit de lijst. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. levens--; } } } Opdracht 22 Als laatste: we laten de speler weten wanneer hij verloren heeft, via de volgende code:\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); if(spelerIsDood) { textSize(52); text(\u0026#34;Dood!\u0026#34;, 130, 170, 100, 100); textSize(32); return; } for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten t.d -= krimpSnelheid; //verwijder te kleine doelwitten if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen doelwitten.splice(i, 1); //Haal het doelwit uit de lijst. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. levens--; } } if(levens \u0026lt;= 0) { spelerIsDood = true; } } Afronden Als het goed is heb je nu een spel gemaakt. Werkt het niet? Je kan jouw code vergelijken met de uitwerking hieronder.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 let doelwitten = [] let levens = 5; let spelerIsDood = false; let krimpSnelheid = 0.1; function setup() { createCanvas(400, 400); //voeg begin doelwitten toe doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. } function draw() { background(255); text(\u0026#34;Levens: \u0026#34;+str(levens), 20, 20, 100, 100); if(spelerIsDood) { textSize(52); text(\u0026#34;Dood!\u0026#34;, 130, 170, 100, 100); textSize(32); return; } for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Teken alle doelwitten ellipse(t.x, t.y, t.d, t.d); //Krimp alle doelwitten t.d -= krimpSnelheid; //verwijder te kleine doelwitten if(t.d \u0026lt; 0) { //Is de grootte kleiner dan 0? Dan verwijderen doelwitten.splice(i, 1); //Haal het doelwit uit de lijst. doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. levens--; } } if(levens \u0026lt;= 0) { spelerIsDood = true; } } function mouseClicked() { for (var i = doelwitten.length-1; i \u0026gt;= 0; i--) { t = doelwitten[i]; //Bereken de afstand tussen de muis en het doelwit let afstand = dist(mouseX, mouseY, t.x, t.y); if(afstand \u0026lt; t.d/2) { //Als de afstand kleiner is dan de halve diameter (radius) van het doelwit is het raak doelwitten.splice(i, 1); //Verwijder het doelwit dat geraakt is doelwitten.push({x: random(300), y: random(300), d: 50}) //Voeg een doelwit toe op een nieuwe willekeurige plek. return; } } } Verbeter het spel We hebben zojuist een spel gemaakt. Kan jij het spel verbeteren? Probeer de volgende idee√´n toe te voegen:\nGeef de doelwitten mooie kleuren. Kan jij de kleur mee laten veranderen met de grootte van de doelwitten? Voeg tekst toe die de huidige score laat zien. Zo kan je aan andere Ninja\u0026rsquo;s laten zien wat je record is. Vind je het spel te makkelijk of te moeilijk? Pas de hoeveelheid doelwitten of de krimpsnelheid aan! Tot slot De instructie geeft je slechts een introductie van wat er mogelijk is met de p5.js bibliotheek. Naast tekenen kun je ook met geluid werken, of met foto\u0026rsquo;s en filmpjes.\nZie https://p5js.org/examples/ voor een overzicht van voorbeelden.\nEen aantal voorbeelden die we zelf leuk vinden:\nhttps://p5js.org/examples/math-parametric-equations.html https://p5js.org/examples/math-graphing-2d-equations.html https://p5js.org/examples/math-distance-2d.html https://p5js.org/examples/sound-playback-rate.html (zet je luidsprekers aan!) https://p5js.org/examples/sound-oscillator-frequency.html (zet je luidsprekers aan!) Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"October 22, 2021","permalink":"/instructies/p5.js-art/","title":"P5.js - Art"},{"categories":null,"contents":"We gaan kunst maken met Python Turtle.\nIntroductie We gebruiken voor deze instructies Thonny, een eenvoudige editor voor Python scripts.\nJe kunt deze hier downloaden en vervolgens installeren.\nIn Thonny kun je op twee manieren code uitvoeren.\nDoor de code die je hebt geschreven - je script - uit te voeren in de editor, dit is het bovenste deel van Thonny. Uitvoeren van je script doe je door op de groene startknop te klikken of de F5-toets in te drukken. De eerste keer dat je dit doet vraagt Thonny je om het script op de computer op te slaan. In de shell, het onderste deel van Thonny. Hier kun je je code regel voor regel uitproberen door na het typen van een regel op Enter te drukken. Tip: regels code die je eerder in de shell hebt getypt kun je opnieuw gebruiken door pijltje omhoog te gebruiken. Mocht je nog geen ervaring hebben met Thonny en Turtle, kijk dan ook eens naar onze Python Turtle instructies.\nJe kunt ook kunst maken met Scratch. Kijk daarvoor naar de Scratch Art instructies.\nIn deze instructie behandelen we kunst met lijnen, cirkels, polygonen (zoals een driehoek en vierkant) en een lissajous.\nLijnen We beginnen eenvoudig met het tekenen van een enkele lijn:\n1 2 3 4 5 from turtle import * forward(100) done() Op regel 1 wordt Turtle geladen. Deze regel is nodig om de Turtle commando\u0026rsquo;s te kunnen gebruiken.\nOp de 3e regel wordt met Turtle commando forward een lijn getrokken met lengte 100.\nTenslotte zorgt done op regel 5 er voor dat het scherm waarop getekend is, open blijft.\nOpdracht 1: Verander de lengte eens en kijk wat er gebeurt.\nOpdracht 2: Maak de lengte eens negatief. Waar gaat de lijn heen?\nPolygonen Een andere naam voor een polygoon is een veelhoek. Voorbeelden van eenvoudige veelhoeken zijn een driehoek, vierkant en vijfhoek.\nEen driehoek tekenen Met drie lijnen kun je een driehoek tekenen. Dit kan er als volgt uitzien:\n1 2 3 4 5 6 7 8 9 10 from turtle import * forward(100) right(120) forward(100) right(120) forward(100) right(120) done() Het commando right op regels 4, 6 en 8 zorgt ervoor dat de pen naar rechts draait en wel met 120 graden.\nOpdracht 3: Voer regels 3 tot en met 8 eens stap voor stap uit en zie wat elke stap doet.\nTekenen met herhalingen In het vorige voorbeeld zag je 3 keer een herhaling van een forward en right commando. Dit kun je ook met een herhaling beschrijven in Python:\n1 2 3 4 5 6 7 from turtle import * for i in range(3): forward(100) right(120) done() Op regel 3 zorgt commando for i in range(3) ervoor dat regels 4 en 5 driemaal herhaald worden.\nOpdracht 4: Verander de range (het getal 3) eens naar 1, 2, 3 of 4? Wat gebeurt er?\nOpdracht 5: Maak de hoek (het getal 120) eens groter of kleiner en kijk wat er gebeurt.\nTekenen met een functie Je hebt over herhalingen geleerd. Je kunt herhalingen nog makkelijker maken door een functie te gebruiken.\nEen functie is een stukje code met een naam. Door die naam kun je de functie overal in je code gebruiken. Verder kun je getallen meegeven om het gedrag van de functie aan te passen.\nHier een voorbeeld van de code voor de functie vorm:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from turtle import * def vorm(x, y, rib, hoeken, rotatie=0): goto(x, y) right(rotatie) pendown() for _ in range(hoeken): forward(rib) right(180 - ((hoeken - 2) * 180 / hoeken)) penup() right(-rotatie) vorm(0, 0, 100, 4, 45) vorm(30, 300, 80, 5, 60) done() Je hoeft niet te weten hoe een functie precies werkt, maar wel hoe je deze moet gebruiken.\nFunctie vorm heeft de volgende parameters:\nx: de horizontale plek in het plaatje. 0 is in het midden. - getallen zijn naar links en + getallen naar rechts. y: de verticale plek in het plaatje. 0 is in het midden. - getallen zijn naar beneden en + getallen naar boven. rib: een vierkant bestaat uit vier lijnen. Deze lijnen heten ribben. Parameter rib is een getal groter dan 0 dat bepaalt hoe lang elke zijde van de veelhoek is. hoeken: een driehoek heeft 3 hoeken (duh!). Met parameter hoeken kun je aangeven hoeveel hoeken de veelhoek moet hebben. rotatie: meestal wordt een vierkant recht getekend dus de bovenste en onderste rib horizontaal en de linker- en rechterrib verticaal. Met de parameter rotatie kun je het vierkant (of andere veelhoek) kantelen. Op regels 15 en 16 staan voorbeelden van het gebruik van de functie vorm. De eerste is een vierkant midden in het plaatje. Het tweede een gekantelde vijfhoek boven in het plaatje.\nOpdracht 6: Maak eens een achthoek met een rib van 120.\nOpdracht 7: Herhaal de aanroep van de vorm functie eens een paar keer met iedere keer andere waarden.\nJe kunt de polygonen ook inkleuren:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from turtle import * def vorm(x, y, rib, hoeken, rotatie=0): goto(x, y) right(rotatie) pendown() for _ in range(hoeken): forward(rib) right(180 - ((hoeken - 2) * 180 / hoeken)) penup() right(-rotatie) vorm(0, 0, 120, 8, 45) fillcolor(\u0026#34;red\u0026#34;) begin_fill() vorm(-19, -46, 80, 8, 45) end_fill() goto(-120, -175) color(\u0026#34;white\u0026#34;) write(\u0026#34;STOP\u0026#34;, font=(\u0026#39;Arial\u0026#39;, 36, \u0026#39;bold\u0026#39;)) hideturtle() done() Voor het inkleuren van de figuur gaat het eigenlijk alleen maar om regels 17, 18 en 20.\nMet fillcolor kies je de kleur. Na begin_fill wordt een volgend figuur dat getekend wordt ingekleurd. Om te voorkomen dat een daarop volgend figuur ook wordt ingekleurd, gebruik je end_fill.\nOpdracht 8: Neem de code over en voer deze uit. Er zit een verrassing in! üòâ\nCirkels Naast rechte lijnen, kun je met Turtle ook cirkels tekenen. Daarvoor is het commando circle:\n1 2 3 4 5 from turtle import * circle(100) done() Het getal 100 op lijn 3 staat voor de diameter van de cirkel.\nOpdracht 9: Maak de cirkel eens groter.\nAls je cirkels combineert met herhalingen en rotaties, dan kun je mooie figuren als deze maken:\nDe code die hierbij hoort, is:\n1 2 3 4 5 6 7 from turtle import * for i in range(12): circle(100) right(30) done() Door met het aantal (getal 12) en de hoek tussen de cirkels (getal 30) te spelen, kun je het figuur er anders uit laten zien.\nOpdracht 10: Als je de hoek kleiner maakt, bijvoorbeeld 20, heb je dan genoeg cirkels om het figuur helemaal rond te maken? Welk getal moet je aanpassen om het figuur weer compleet te krijgen? Moet dit groter of kleiner worden?\nDoor met kleuren te spelen, wordt de figuur nog mooier:\n1 2 3 4 5 6 7 8 9 10 11 from turtle import * kleuren = [\u0026#34;red\u0026#34;, \u0026#34;cyan\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;blue\u0026#34;] bgcolor(\u0026#34;black\u0026#34;) for i in range(12): color(kleuren[i % 7]) circle(100) right(30) done() Op regel 3 worden de kleuren die we willen gebruiken in een lijstje gezet. Je kunt niet zomaar elke kleur gebruiken en Python snapt geen Nederlands. Voor een overzicht van de kleuren die mogelijk zijn, kun je even kijken naar onze Python Turtle instructies.\nOp regel 4 maken we de achtergrond zwart. Hierdoor komen de kleuren in het lijstje beter uit.\nOp regel 7 wordt een kleur gekozen uit het lijstje en geactiveerd.\nOpdracht 11: Neem de code over en kies eens wat andere kleuren. Je kunt ook het lijstje korter of langer maken, maar dan moet het getal 7 op regel 7 aangepast worden, zodat het gelijk is aan het aantal kleuren in de lijst.\nLissajous Met lijnen, polygonen en cirkels kun je al mooie plaatjes maken. Met een Lissajous wordt het n√≥g interessanter.\nMet een wiskundige formule worden twee golven gecombineerd:\nSinus Allereerst tekenen we een sinus-golf:\nDat doe je met deze code:\n1 2 3 4 5 6 7 8 9 10 from turtle import * from math import sin penup() goto(-400, 0) pendown() for i in range(-400, 400): goto(i, 100 * sin((i + 400) / 50)) done() Let op: zorg dat je regel 2 overneemt, anders wordt het sinus commando niet herkend.\nHet commando sin zorgt hier voor de golfvorm. Afhankelijk van het getal dat je als parameter mee geeft, gaat de golf sneller of langzamer.\nOpdracht 12: Vervang getal 50 op regel 8 eens door een groter of kleiner getal. Wat gebeurt er?\nOpdracht 13: Vervang getal 100 op regel 8 eens door een groter of kleiner getal. Wat gebeurt er?\nLissajous Als we twee sinussen in √©√©n formule combineren, dan kun je een Lissajous tekenen. Kijk eens naar de volgende code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from turtle import * from math import sin a = 4 b = 3 x = 0 y = 0 s = 300 for i in range(1000): goto(s * sin(x/150), s * sin(y/150)) x += a y += b done() Op regel 11 zie je de combinatie van twee sinussen in het goto commando. Met dit commando verschuif je de pen over het plaatje. Met de eerste parameter horizontaal en met de tweede verticaal. Door voor beiden een sinus te gebruiken, schuift de pen zowel horizontaal en verticaal.\nOpdracht 14: Neem de code over en voer het uit. Zie je hetzelfde plaatje als hierboven?\nOpdracht 15: Maak de waarde voor s (regel 8) eens kleiner? Wat gebeurt er? En als je het groter maakt?\nOpdracht 16: Variabelen a en b bepalen de vorm van de Lissajous. Probeer eens andere waarden, zoals bijvoorbeeld a = 18 en b = 19. Hoe ziet dat er uit? En als a en b 4 zijn? Of 1 en 2?\nTot slot Zoals je ziet kun je met Python Turtle leuke kunststukjes maken. Gebruik je fantasie, maar vooral: durf te proberen met allerlei getallen en kleuren. Wie weet wat je kunt maken?\nTer voorbereiding van deze instructie hebben we zelf ook wat kunst gemaakt. Probeer ze eens uit:\nart-1.py gekleurde lijnen\nart-2.py gekleurde lijnen\nart-3.py gekleurde lijnen\nart-4.py gekleurde cirkels\nart-5.py gekleurde veelhoeken\nart-6.py gekleurde en gedraaide vierkanten\nart-7.py lissajous\nart-8.py willekeurige gekleurde vijf- en zevenhoeken\nart-9.py willekeurig gekleurde gedraaide negenhoeken\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"October 18, 2021","permalink":"/instructies/python-art/","title":"Python - Art"},{"categories":null,"contents":"\nWat gaan we doen? Deze maand zijn we weer te gast bij bibliotheek Zwanenveld. Wat gaan we daar doen? Kunst maken met de computer!\nWe hebben instructies met Scratch, Python en p5.js.\nVoorbereiding Neem een laptop en een goed humeur mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nCoderDojo en Corona We houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 6 november van 12:00u tot 14:30u. We zitten in de bibliotheek Gelderland Zuid, vestiging Zwanenveld. Het adres is Zwanenveld 9098, 6538 SC Nijmegen.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"October 14, 2021","permalink":"/dojos/82-kunst-met-scratch-python-en-p5.js/","title":"#82: Kunst, met Scratch, Python en p5.js"},{"categories":null,"contents":"We gaan kunst maken met Scratch.\nIntroductie Naast een leuke achtergrond en het bewegen van de kat van Scratch kun je nog veel meer doen. Je kunt Scratch ook laten tekenen.\nHier zie je een paar voorbeelden van wat je met Scratch kunt:\nDeze instructie leert je stap-voor-stap vergelijkbare tekeningen te maken.\nBenodigdheden Om de instructie te volgen, heb je naast je computer niets nodig.\nGa naar https://scratch.mit.edu/projects/editor/ om aan de stappen te beginnen.\nDeze instructies gaan er vanuit dat je de pen uitbreiding gebruikt. Deze moet je eerst activeren:\nOpen het overzicht met uitbreidingen: Kies uit het overzicht de pen uitbreiding Er zijn nu groene pen blokken beschikbaar die verder in de instructies worden gebruikt Stappen Polygonen Een polygoon is een ander woord voor een veelhoek. Een veelhoek is een vorm in een plat vlak met een aantal hoeken. Een veelhoek met 3 hoeken is een driehoek. Maar ook een achthoek is een veelhoek. In dit hoofdstuk gaan we veelhoeken tekenen.\nDriehoek Een driehoek is een eenvoudige veelhoek. Het bestaat uit 3 hoeken en 3 lijnen. Je kunt deze makkelijk teken met Scratch:\nVoor elke hoek doe je twee dingen:\nneem 100 stappen om een lijn te tekenen draai de pen 120¬∞ En dat herhaal je dan 3 keer.\nOefening 1: Maak het voorbeeld eens na en experimenteer eens met het aantal stappen of de hoeken.\nVierhoek De vierhoek is nog een eenvoudige veelhoek. Het bestaat uit 4 hoeken en 4 lijnen. Ook deze kun je makkelijk teken met Scratch:\nVoor elke hoek doe je twee dingen:\nneem 100 stappen om een lijn te tekenen draai de pen 90¬∞ En dat herhaal je dan 4 keer.\nOefening 2: Neem je code van de driehoek en pas het aan zodat het een vierkant kan maken.\nOefening 3: Neem je code van de vierhoek en probeer er eens een vijfhoek van te maken. Wat moet er veranderen?\nMisschien valt het je op, dat de stappen voor de driehoek, vierhoek en vijfhoek erg vergelijkbaar zijn. Het aantal herhalingen is gelijk aan het aantal hoeken en de hoek van de te maken draai wordt wordt steeds groter.\nPolygoon functie Bij de vierhoek en vijfhoek zagen we al dat het tekenen ervan vooral bestaat uit herhaling van stappen. Ook is er eigenlijk maar √©√©n getalletje dat veranderd; het aantal hoeken.\nOm verschillende polygonen te tekenen, is het dus handig om √©√©n blokje te hebben waarbij je het aantal hoeken kunt opgeven.\nLet op: bij deze stap ga je zelf het blok \u0026ldquo;polygoon\u0026rdquo; samenstellen; deze bestaat nog niet. Om dit te doen ga je naar Mijn blokken \u0026gt; maak een blok. Hierdoor beland je op het volgende scherm:\nVerander hier de naam van het blok van bloknaam naar polygoon.\nSelecteer vervolgens Voeg een invoer toe: getal of tekst.\nNoem deze invoer vervolgens aantal hoeken en klik op OK.\nVanaf nu staat \u0026ldquo;polygoon\u0026rdquo; onder Mijn blokken vermeld.\nDaarnaast kan je de variabele \u0026ldquo;aantal hoeken\u0026rdquo; verkrijgen door deze uit het definieer polygoon blok te slepen.\nLinks staat het nieuwe blok dat polygonen tekent. Rechts staat hoe je het nieuwe blok kunt gebruiken.\nOefening 4: Maak het voorbeeld na. Wat wordt er getekend?\nOefening 5: Experimenteer eens wat met het aantal hoeken, wat gebeurt er als je een groot aantal hoeken (20?) kiest?\nOefening 6: Kun je het volgende figuur maken?\nLissajous Een lissajous is een vorm gemaakt met een wiskundige formule. Het is een combinatie van twee golven.\nDe combinatie van twee golven\nSinusgolf Voordat we de Lissajous maken, beginnen we met een enkele sinusgolf:\nHieronder de code die hiervoor gebruikt is. Het belangrijkste blokje is het groene, met daarin variabelen amplitude, frequentie en x. Dit blokje zorgt voor de golfvorm.\nOefening 7: Maak het voorbeeld na. Ziet het er hetzelfde uit als in het plaatje?\nOefening 8: Probeer eens wat te varieren met de waarden van variabele amplitude en een frequentie. Wat gebeurd er?\nLissajous functie Hieronder staan een paar voorbeelden van een Lissajous. Met twee getallen (a en b) kan je aanpassen hoe een Lissajous eruit ziet.\na = 1, b = 2\na = 3, b = 4\na = 5, b = 4\nDe code om er een te maken ziet er als volgt uit:\nEerst wordt de pen gereset. Dan wordt de Lissajous functie aangeroepen met drie waardes: maat, a en b. Daarna wordt er elke keer de X- en Y-positie berekend. Hiermee wordt de vorm getekend. Het groene blokje dat zorgt voor de golfvorm, wordt nu twee keer wordt gebruikt in het blauwe \u0026lsquo;ga naar\u0026rsquo; blok.\nOefening 9: Maak het voorbeeld na. Kun je de waarden a en b van de drie voorbeelden gebruiken? Zijn de getekende plaatjes dan hetzelfde als de drie voorbeelden?\nOefening 10: Probeer eens rare getallen uit voor maar, a en b en kijk wat er gebeurd.\nOefening 11: Maak de lissajous kleurrijk, zoals als oefening 6.\nConclusie Je hebt nu een indruk gekregen van hoe je met Scratch kunt tekenen. Eerst door veelhoeken of polygonen te tekenen en te herhalen en vervolgens door een Lissajous te maken.\nHeb je de smaak te pakken gekregen van het maken van kunst met Scratch? Kijk dan ook naar deze voorbeelden:\nScratch \u0026lsquo;art\u0026rsquo;: https://scratch.mit.edu/search/projects?q=art Scratch \u0026lsquo;kunst\u0026rsquo;: https://scratch.mit.edu/search/projects?q=kunst Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"October 13, 2021","permalink":"/instructies/scratch-art/","title":"Scratch - Art"},{"categories":null,"contents":"\nWat gaan we doen? Deze maand zijn we na lange tijd weer eens te gast bij de bibliotheek, en wel in de vestiging Zwanenveld. Wat gaan we daar doen? Programmeren met Python! En als Python nog wat moeilijk is, kunnen we je ook helpen met een leuke opdracht in Scratch.\nVoorbereiding Neem een laptop en een goed humeur mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (dit mag digitaal).\nCoderDojo en Corona We houden ons aan de regels die gelden in de bibliotheek.\nWanneer en waar? Zaterdag 2 oktober van 12:00u tot 14:30u. We zitten in de bibliotheek Gelderland Zuid, vestiging Zwanenveld. Het adres is Zwanenveld 9098, 6538 SC Nijmegen.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"September 21, 2021","permalink":"/dojos/81-python-en-scratch/","title":"#81: Python (en Scratch)"},{"categories":null,"contents":"\nWat gaan we doen? De vakantie is voorbij maar bij CoderDojo Nijmegen gaat de zomer nog even door met een live dojo in de buitenlucht. Deze maand kun je zowel zonder als met computer aan de slag. Dat betekent zowel wedstrijdjes levend programmeren, puzzelen op de Turing Tumble als de mogelijkheden van de micro:bit ontdekken.\nOpdrachten voor de micro:bit kun je op verschillende plekken vinden, bijvoorbeeld\ninstructies op de CoderDojo Nijmegen site instructies op de Raspberry Pi Foundation website Voorbereiding Als je met de micro:bit aan de slag wil neem dan een laptop mee.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\n- Had je een of meerdere van deze klachten in de afgelopen 24 uur, namelijk hoesten, verkoudheidsklachten, verhoging of koorts, benauwdheid, reuk- en/of smaakverles? - Heb je op dit moment een huisgenoot met milde klachten en koorts en/of benauwdheid? - Heb je het nieuwe coronavirus gehad en is dit de afgelopen 7 dagen vastgesteld (met een test)? - Ben je in quarantaine omdat je een huisgenoot of nauw contact bent van iemand bij wie het nieuwe coronavirus is vastgesteld, bent (terug)gekomen uit een COVID-19-risicogebied, of bent gewaarschuwd door de Coronamelder-app? was je handen regelmatig met water en zeep, zit niet met je handen aan je gezicht, schud geen handen, hoest of nies in je elleboog en gebruik papieren zakdoekjes om je neus te snuiten en gooi deze daarna weg. Wij zorgen voor handgel en schoonmaakdoekjes. kinderen t/m 12 jaar hoeven geen afstand te houden van elkaar en volwassenen jongeren boven de 12 hoeven geen afstand te houden van elkaar, wel van volwassenen volwassenen houden 1,5 m afstand van elkaar kom alleen als het antwoord op alle onderstaande vragen \u0026ldquo;nee\u0026rdquo; is: We zijn blij dat we weer bij elkaar kunnen komen, natuurlijk houden we ons wel aan de regels die er momenteel gelden. Dus:\nWanneer en waar? Zaterdag 4 september van 12:00u tot 14:30u. We gaan aan de slag vlak naast de Smeltkroes op het Honigterrein (Waalbandijk 16, 6541 AJ Nijmegen). De dojo is bij het overdekte deel.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"August 28, 2021","permalink":"/dojos/80-unplugged-+-microbit/","title":"#80: Unplugged + micro:bit"},{"categories":null,"contents":"\nWat gaan we doen? Een live dojo in de buitenlucht! Zoals ondertussen bijna traditie gaan we deze zomermaand unplugged dus zonder computers aan de slag. Dat betekent wedstrijdjes levend programmeren, puzzelen op de Turing Tumble en complete chaos met RoboRally.\nVoorbereiding Deze maand kun je de laptop thuislaten - je lijf en je hersenen moet je wel meenemen!\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\n- Had je een of meerdere van deze klachten in de afgelopen 24 uur, namelijk hoesten, verkoudheidsklachten, verhoging of koorts, benauwdheid, reuk- en/of smaakverles? - Heb je op dit moment een huisgenoot met milde klachten en koorts en/of benauwdheid? - Heb je het nieuwe coronavirus gehad en is dit de afgelopen 7 dagen vastgesteld (met een test)? - Ben je in quarantaine omdat je een huisgenoot of nauw contact bent van iemand bij wie het nieuwe coronavirus is vastgesteld, bent (terug)gekomen uit een COVID-19-risicogebied, of bent gewaarschuwd door de Coronamelder-app? was je handen regelmatig met water en zeep, zit niet met je handen aan je gezicht, schud geen handen, hoest of nies in je elleboog en gebruik papieren zakdoekjes om je neus te snuiten en gooi deze daarna weg. Wij zorgen voor handgel en schoonmaakdoekjes. kinderen t/m 12 jaar hoeven geen afstand te houden van elkaar en volwassenen jongeren boven de 12 hoeven geen afstand te houden van elkaar, wel van volwassenen volwassenen houden 1,5 m afstand van elkaar kom alleen als het antwoord op alle onderstaande vragen \u0026ldquo;nee\u0026rdquo; is: We zijn blij dat we weer bij elkaar kunnen komen, natuurlijk houden we ons wel aan de regels die er momenteel gelden. Dus:\nWanneer en waar? Zaterdag 7 augustus van 12:00u tot 14:30u. We gaan aan de slag vlak naast de Smeltkroes op het Honigterrein (Waalbandijk 16, 6541 AJ Nijmegen). De dojo is bij het overdekte deel.\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"July 26, 2021","permalink":"/dojos/79-unplugged/","title":"#79 Unplugged"},{"categories":null,"contents":"Alles wat je moet weten om gave dingen te maken\nWat is de Arduino? De Arduino is een microcontroller, wat betekent dat het een heel simpele computer is. Je kunt er sensoren op aansluiten om van alles waar te nemen in de omgeving, en er ook allerlei soorten ‚Äòoutputs‚Äô mee aansturen zoals motoren en lampen.\nEr bestaan verschillende soorten Arduino‚Äôs en veel vergelijkbare microcontrollers, maar de Arduino Uno die je hierboven ziet is het bekendst. Op de Arduino zie je nummers en markeringen staan die aangeven wat je erop kunt aansluiten. ‚Äò3.3V‚Äô en ‚Äò5V‚Äô zijn de pinnen waar je stroom met die voltages uit kunt halen. Je zou ze kunnen zien als de plus van een batterij. De min van het Arduinobordje vind je bij ‚ÄòGND‚Äô.\nVerder zie je 14 digitale pins en 6 analoge pins, die we allemaal kunnen gebruiken als inputs √©n als outputs.\nDe software installeren We hebben de Arduino-software nodig om het Arduino-bordje te kunnen programmeren. Om de software te downloaden ga je naar www.arduino.cc/en/software.\nKies je besturingssysteem (Windows, Linux of Mac) in het dondergroene vlak met de titel ‚ÄòDownload options‚Äô. (Heb je Windows? Kies dan de bovenste optie.) In het volgende scherm kun je klikken op ‚ÄòJust download‚Äô. Als het bestand gedownload is, kun je het Arduino-programma installeren en openen.\nJe eerste Arduino-programma De stukjes software die we maken voor de Arduino noemen we schetsen (in het Engels ‚Äòsketches‚Äô) of gewoon programma‚Äôs. Schetsen zijn tekstbestandjes waar instructies voor het Arduino-bordje in staan. Programmeurs noemen zulke instructies ook wel ‚Äòcode‚Äô. Je gaat nu je eerste Arduino-programma maken door een bestaand voorbeeld te openen en aan te passen.\nOpen het menu Bestand, dan Voorbeelden, Basics en klik dan op Blink. De schets dat zich nu opent in een nieuw venster gaan we uploaden naar de Arduino.\nSluit het Arduino-bordje aan op je computer met een USB-kabel.\nKlik op het tweede icoontje van links:\nHet Arduino-programma zal de schets nu op de chip van de Arduino gaan zetten.\nMogelijk krijg je de eerste keer een venster te zien waarin je moet aangeven waar de computer de Arduino kan vinden. Kies daar voor een adres met ‚Äòusb‚Äô, ‚Äòserial‚Äô of ‚ÄòCOM‚Äô erin, en niet voor ‚Äòbluetooth‚Äô.\nAls je linksonder in het scherm ‚ÄòUploaden voltooid‚Äô ziet, dan is het gelukt en is er nu op de Arduino een LED-lampje aan het knipperen!\nAls je een foutmelding krijgt, bekijk dan de pagina ‚ÄòProblemen oplossen‚Äô achteraan deze handleiding.\nOefening Kun je het LED-lampje sneller laten knipperen?\nLet op: als je iets in de schets verandert, moet je hem opnieuw uploaden. Kun je de LED in verschillende patronen laten knipperen?\nKun je bijvoorbeeld SOS knipperen? Hoe zit een Arduino-programma in elkaar? Belangrijk om door te hebben: bijna alle Arduino-schetsen hebben drie onderdelen.\nIn het eerste deel, helemaal bovenaan in de schets, worden vaak wat variabelen klaargezet. (Hoe variabelen werken kun je verderop in deze handleiding lezen.)\nIn het geval van Blink staat daar alleen wat commentaar. Alle regels met twee schuine strepen ervoor zijn toelichting. Zulke regels staan er om aan jou uit te leggen hoe het programma werkt. Alle regels tussen /* en */ zijn ook commentaar. (Je herkent commentaar ook aan de grijze kleur van de tekst.)\nHet tweede deel is een functie die ‚Äòsetup‚Äô heet. Alles wat daarin staat, wordt √©√©n keer uitgevoerd.\nvoid setup() { // alles wat tussen de accolades (de gekrulde haakjes) staat, hoort bij // setup en wordt in √©√©n keer uitgevoerd. // In Blink wordt bijvoorbeeld het ingebouwde LED-lampje op // het Arduino-bord aangemeld als output: pinMode(LED_BUILTIN, OUTPUT); } Het derde deel van de schets is de functie die ‚Äòloop‚Äô heet. Dit deel van het programma wordt steeds weer opnieuw gedaan, voor altijd.\nvoid loop() { digitalWrite(LED_BUILTIN, HIGH); // zet de LED aan (HIGH is het voltage niveau) delay(1000); // wacht een seconde digitalWrite(LED_BUILTIN, LOW); // zet de LED uit (bij LOW is de spanning uit) delay(1000); // wacht een seconde } De ingebouwde LED is op de Arduino Uno aangesloten op pin 13. ‚ÄòLED_BUILTIN‚Äô is een woord dat 2 Arduino herkent, maar je zou in plaats daarvan ook ‚Äò13‚Äô kunnen schrijven. In Blink bijvoorbeeld wordt in loop() het ingebouwde LED-lampje aangezet 2 (‚ÄòHIGH‚Äô), dan wordt er een seconde gewacht (duizend milliseconden), dan wordt de LED weer uitgezet (‚ÄòLOW‚Äô), dan wordt er weer een seconde gewacht, en dan begint loop() weer opnieuw.\nHoe een breadboard werkt Om sensors en andere componenten te verbinden met de Arduino (of met elkaar), is het vaak handig om een breadboard te gebruiken.\nDe gaatjes op het breadboard zijn binnenin het plastic bordje met metalen strips met elkaar verbonden. De gaatjes in het midden zijn verbonden in kolommen van vijf (zoals die in het groene kader hiernaast).\nDe letters en cijfers op het breadboard gebruiken we meestal niet. Die vijf gaatjes zijn alleen met elkaar verbonden, dus niet met gaatjes ernaast of met gaatjes aan de overkant van de kloof in het midden.\nDe horizontale rijen bovenaan en onderaan, met de rode en blauwe lijnen ernaast, gebruiken we om meerdere onderdelen van stroom te voorzien. Rood is plus en blauw (of zwart) is min, net zoals batterijen een plus en een min hebben. Die gaatjes zijn alleen verbonden met de andere gaatjes in dezelfde horizontale rij, dus niet niet met de gaatjes erboven of eronder.\nHet is daarom verstandig om je altijd aan de juiste kleuren te houden: de rode rij op het breadboard voor plus en de blauwe rij voor min. Gebruik ook zoveel mogelijk rode draadjes om componenten met de positieve kant te verbinden, en zwarte of blauwe draadjes voor de verbinding met de negatieve kant.\nDigitale sensors: een knop Een Arduino programmeren om lampjes te laten knipperen is leuk, maar eigenlijk willen we dat hij ook kan reageren op zijn omgeving. Laten we dat nu proberen.\nVerbind eerst een drukknop met de Arduino zoals op de tekening:\nZet de knop op het breadboard met twee pootjes aan elke kant van de gleuf in het midden (als het zo dadelijk niet werkt, moet je de knop misschien een kwartslag draaien). Verbind √©√©n kant van de knop met √©√©n van de gaatjes van de Arduino waar GND naast staat. De andere kant van de knop verbind je met het gaatje waar ‚Äò2‚Äô bij staat (niet ‚ÄòA2‚Äô). Open nu de schets die bij deze schakeling hoort, via het menu Bestand \u0026gt; Voorbeelden \u0026gt; Digital \u0026gt; DigitalInputPullup.\nUpload de schets naar de Arduino.\nProbeer de knop maar. Als het goed is, heb je nu je eerste werkende digitale sensor! Als je op de knop drukt, gaat de LED aan. Dit is dus al meteen een combinatie van input en output.\nHoe werkt het? In het programma zie je dat in de functie setup() pin nummer 2 als een ingang wordt ‚Äòopengezet‚Äô:\npinMode(2, INPUT_PULLUP); Op die pin heb je de knop aangesloten, en dankzij deze regel in de schets weet de Arduino dat ook.\nVervolgens wordt pin nummer 13 als een uitgang gedefini√´erd:\npinMode(13, OUTPUT); De ingebouwde LED op de Arduino is verbonden met pin 13, en dankzij deze regel weet de Arduino dat we die willen gaan gebruiken.\nNu gaan we in de gaten houden of de knop wordt ingedrukt. Dat doen we met de functie digitalRead():\nint sensorVal = digitalRead(2); Als je op de knopt drukt die is verbonden met pin 2 van de Arduino, levert digitalRead hier een 0 op. Als je de knop loslaat, wordt dat een 1. Die waarde wordt vervolgens bewaard in een variabele die ‚ÄòsensorVal‚Äô heet (meer uitleg over variabelen lees je verderop).\nDaarom is een knop een voorbeeld van een digitale sensor: er zijn maar twee mogelijkheden. Andere voorbeelden van digitale sensoren zijn bewegingsensors (zoals PIR-sensors die automatisch het licht aandoen in WC‚Äôs) en ‚Äòoogjes‚Äô zoals bovenaan roltrappen. Dit alles staat in de functie loop(), wat betekent dat digitalRead() steeds opnieuw wordt uitgevoerd en de knop dus continu in de gaten wordt gehouden. ‚ÄòsensorVal‚Äô bevat steeds de huidige stand van de knop, 1 of 0, aan of uit.\nOm iets te doen met de informatie die de sensor doorgeeft, staat in de schets vervolgens een if-statement. Hoe dat werkt, lees je hierna\nIf-statements Om de Arduino iets te laten doen als er iets verandert, moeten we hem leren om vragen te stellen. Een vraag in Arduino ziet er zo uit:\nif (sensorWaarde \u0026gt; 30) { // doe hier iets } Dit heet een if-statement. Je laat Arduino vragen: is de knop ingedrukt? Of, zoals in het voorbeeld hierboven: is het getal dat de sensor teruggeeft groter dan 30? Als het antwoord op zo‚Äôn vraag ‚Äòja‚Äô is, dan voert Arduino de code uit die tussen de gekrulde haken staat.\nIn de DigitalInputPullup-schets van zojuist ziet dat er zo uit:\nif (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } Door hoe we de knop hebben aangesloten, betekent ‚ÄòHIGH‚Äô in dit geval dat de knop niet wordt ingedrukt. Hier wordt eerst gevraagd: wordt de knop ingedrukt? Als dat niet zo is, dan zetten we het LEDje uit, en anders zetten we het aan. Dit is dus een uitbreiding op het if-statement: met ‚Äòelse‚Äô kunnen we instructies toevoegen voor het geval het antwoord op de vraag ‚Äònee‚Äô is.\nInterpunctie Merk op dat elke haakje openen een haakje sluiten nodig heeft, dus ‚Äò(‚Äô en ‚Äò)‚Äô, en ‚Äò{‚Äô en ‚Äò}‚Äô. Elk commando zoals digitalWrite() moet eindigen op een puntkomma. Programmeertalen zijn heel gevoelig op dit soort dingen en zullen niet meewerken als je dit soort dingen verkeerd doet. Als je toch foutmeldingen krijgt, kijk dan naar de paragraaf ‚ÄòProblemen met de code‚Äô aan het eind van deze handleiding.\nOefening Nu gaat de LED aan als je de knop indrukt. Kun je de code zo aanpassen dat de LED juist uitgaat als je de knop indrukt?\nZien wat er gebeurt: de seri√´le monitor Stel je voor dat er iets misgaat, bijvoorbeeld dat er n√≠et een LEDje gaat branden als je op de knop drukt. Dan zou het handig zijn als de Arduino zelf kon vertellen of hij ten minste ziet dat de knop wordt ingedrukt, want dat zou ons helpen te ontdekken wat het probleem is. Gelukkig kan de Arduino dat.\nWe kunnen een communicatieverbinding opzetten tussen de computer en het Arduino-bordje. Dat doen we door deze regel in setup() te zetten (in de DigitalInputPullup-schets staat dit er al):\nSerial.begin(9600); In loop() zetten we direct onder de regel waar we de sensor uitlezen deze regels:\nSerial.print(\u0026#34;sensor = \u0026#34;); Serial.println(sensorValue); Open vervolgens de seri√´le monitor door te klikken op het vergrootglasicoontje rechtsbovenaan in het venster.\nAls de schets van de knop (DigitalInputPullup) nog steeds op de chip van de Arduino staat, dan zou je nu in de seri√´le monitor moeten kunnen zien of de knop wordt ingedrukt. Als je niks ziet veranderen, dan weet je dus dat de knop het niet doet of niet goed is verbonden met pin 2.\nDe seri√´le verbinding is vaak enorm handig om te kijken of Arduino doet wat wij in gedachte hadden, en zo niet, waar het probleem dan zit.\nWe kunnen de verbinding ook gebruiken om sensordata uit de Arduino te gebruiken in andere software op de computer, bijvoorbeeld om interactieve animaties of muziek te maken.\nDie 9600 is de baud rate, de snelheid waarmee de computer en de Arduino met elkaar praten. Sommige schetsen gebruiken andere waardes zoals 115200. De baud rate in de seri√´le monitor moet overeen komen met die in de schets, anders zie je rare tekens of gewoon niets. Analoge sensors De knop die we tot nu toe gebruikt hebben, is een soort digitale sensor. Zulke sensoren kennen alleen 1 en 0, oftewel aan en uit, LOW en HIGH.\nEr zijn ook een heleboel analoge sensoren, die tussenwaardes kunnen geven. Een voorbeeld daarvan is een lichtsensor, die kan laten weten of het donker is of juist heel erg licht, maar die ook alle gradaties ertussenin kan meten.\nEen ander voorbeeld van een analoge sensor is de potmeter of potentiometer. Dat is een draaiknop die je het beste kent als volumeknop op versterkers. In Arduino kun je heel precies de positie zien van de draaiknop.\nSluit de potmeter aan zoals op de afbeelding: de middelste pin op de analoge poort A0, en de buitenste pinnen op 5V en GND.\nOpen vervolgens dit programma: Bestand \u0026gt; Voorbeelden \u0026gt; 03. Analog \u0026gt; AnalogInput.\nUpload de schets naar de Arduino. Als het goed is kun je nu de LED sneller en langzamer laten knipperen door aan de knop te draaien!\nOok leuk: probeer de waardes die van de potmeter komen te bekijken met de seri√´le plotter. Hoe dat moet, wordt onthuld op de volgende pagina.\nOefening Sluit een kleine speaker of ‚Äòbuzzer‚Äô aan op GND en pin 13 (via het breadboard). Dat is dus op dezelfde pin als de interne LED van de Arduino. Hoor je een verschil als je aan de knop draait?\nSeri√´le plotter Om analoge waarden goed te kunnen laten zien, heeft de Arduino-software een geweldige feature in huis.\nOpen het menu Hulpmiddelen en klik op Seri√´le plotter (sluit eerst de seri√´le monitor als dat venster nog openstaat). De sneltoets-combinatie voor de seri√´le plotter is shift+command+L.\nOpen de schets AnalogReadSerial via het menu Bestand \u0026gt; Voorbeelden \u0026gt; 01. Basics \u0026gt; AnalogReadSerial, en upload het naar de Arduino.\nJe zou in het venster van de seri√´le plotter nu een grafiek moeten zien van de veranderingen in de positie van de potmeter! (Of de resultaten van een andere analoge sensor, zoals bijvoorbeeld de lichtsensor.)\nMeerdere sensoren Als je de resultaten van meerdere sensoren in de seri√´le plotter wil zien, dan moet je zorgen dat die waardes gescheiden door tabs worden doorgestuurd:\nSerial.print(sensor1); // waarde van de eerste sensor Serial.print(\u0026#34;,\\t\u0026#34;); // waardes gescheiden door komma en tab Serial.print(sensor2); // waarde van de tweede sensor Serial.println(); // witregel Het helpt om verder geen print()‚Äôs in je programma te hebben die tekst schrijven naar de seriele verbinding (zoals je soms wel doet om feedback van je schets te zien in de seri√´le monitor). Als je zulke print()‚Äôs met tekst wel hebt in je schets, misschien moet je ze dan even tijdelijk uitschakelen door er met // commentaar van te maken.\nUltrasone afstandssensor Als je wil weten hoe ver iets of iemand is (bij je robot of kunstwerk vandaan bijvoorbeeld), dan is een ultrasone afstandssensor geweldig. Er zitten twee ronde dingen op, een speaker en een microfoon. De sensor werkt door met de speaker een ultrasoon geluid te maken, en vervolgens met de microfoon te meten hoe lang het duurt voordat de echo van dat geluid terugkomt. Door die tijd te delen door snelheid van het geluid, kan de Arduino uitrekenen hoe ver weg iets is.\n343 meter per seconde; de gevonden tijd wordt ook nog door 2 gedeeld, omdat het geluid twee keer de 6 afstand heeft afgelegd als de echo wordt opgevangen.\nJe sluit de sensor zo aan op de Arduino, eventueel via een breadboard:\nde pin op de sensor waar VCC bij staat naar 5V op de Arduino, GND op de sensor naar GND op de Arduino, Trigger naar digitale pin 12 van de Arduino, Echo naar pin 11 van de Arduino. Je kunt code voor dit type sensor overal online vinden, maar de NewPing-library is erg makkelijk te gebruiken. Die moet je dan wel even installeren‚Äîals je nog niet weet hoe dat moet, kijk dan even op de pagina ‚ÄòLibraries installeren‚Äô verderop.\nIn het voorbeeldprogramma NewPingExample (zie Bestand \u0026gt; Voorbeelden \u0026gt; NewPing) kun je zelf de maximale afstand instellen die je wil meten. Een meter of vier √† vijf is wel het maximaal haalbare met deze sensor.\nMeer informatie over de NewPing-library vind je hier: https://bitbucket.org/teckel12/arduino-new-ping\nUpload de code naar de Arduino, en open de seri√´le monitor om de afstand te zien die de sensor meet.\nUltrasone afstandssensors meten de afstand tot objecten in een smalle strook van 15 graden. Als je een breder gebied wil scannen, dan zou je meerdere ultrasone sensors naast elkaar kunnen zetten, of een enkele sensor op een motortje kunnen zetten om een draaiende radar te maken. Een meer complete oplossing is beeldherkenning, maar dat is ook een stuk ingewikkelder. Als je alleen maar wil weten √≥f iemand in de buurt is (en niet per se hoe ver weg ze zijn), gebruik dan een PIR-sensor. Variabelen Variabelen zijn woorden of letters waarmee we Arduino iets kunnen laten onthouden. Dat is belangrijk als we Arduino bijvoorbeeld willen laten bijhouden hoe vaak iets is gebeurd.\nEen variabele defini√´ren ziet er zo uit:\nint aantal = 100; Door ‚Äòint‚Äô ervoor te zetten zeggen we: de variabele is een heel getal, dus geen decimaal. Dan geven we de variabele zijn naam. In dit geval is dat ‚Äòaantal‚Äô, maar het zou net zo goed ‚Äòx‚Äô mogen zijn, of ‚ÄòsensorWaarde‚Äô. Meestal kiezen we een naam die goed duidelijk maakt wat voor informatie we willen opslaan in die variabele. Vervolgens vertellen we de variabele wat zijn beginwaarde wordt‚Äîin dit geval 100. Tot slot wordt de regel afgesloten met een puntkomma, net als alle commando\u0026rsquo;s in Arduino.\nAndere typen variabelen zijn bijvoorbeeld float (dat is wel een decimaal getal) en bool (alleen ‚Äòtrue‚Äô of 8 ‚Äòfalse‚Äô). Je vindt alle typen op https://www.arduino.cc/reference/en/ onder ‚ÄòData Types‚Äô.\nAls je een variabele eenmaal op die manier gedefini√´erd hebt, dan kun je met die variabele gaan rekenen. Als we dit doen‚Ä¶\naantal = aantal + 100; ‚Ä¶ dan heeft ‚Äòaantal‚Äô nu een waarde van 200.\nOefening Met variabelen kun je bijvoorbeeld ook bijhouden hoe vaak een knop is ingedrukt. Je kunt daarvoor de schets DigitalInputPullup gebruiken (zie eventueel de pagina over digitale sensors). Probeer het eerst zelf, en lees eventueel daarna de oplossing.\nmogelijke oplossing Voeg een variabele toe bovenaan in de schets (dus nog boven setup()). Tel vervolgens steeds 1 bij op, op 9 de plek waar de schets iets doet op het moment dat de knop wordt ingedrukt. Verplaats de Serial.println naar diezelfde plek om in plaats van ‚ÄòsensorVal‚Äô de waarde van jouw variabele naar de seri√´le monitor te schrijven. Als je onder die regel ook nog ‚Äòdelay(500);‚Äô toevoegt, dan wacht de Arduino een halve seconde voordat hij verdergaat. Op die manier telt hij steeds maar √©√©n druk op de knip in plaats van dat hij doortelt zolang als de knop is ingedrukt :-) Inputs en outputs combineren Vaak willen we met de Arduino meerdere inputs en outputs tegelijk gebruiken √©n ze laten samenwerken. Je kunt bijvoorbeeld een potentiometer gebruiken om de snelheid van een motor te veranderen, of een lichtsensor gebruiken om de toonhoogte van een buzzer te verhogen of te verlagen. Hier lees je hoe dat moet.\nStap 1 Als je twee componenten met elkaar wil laten samenwerken, laat ze dan altijd eerst apart werken. Als er dan later iets niet werkt, weet je dat het in ieder geval niet ligt aan de individuele componenten en dat maakt het zoeken naar een oplossing veel makkelijker. Dus bijvoorbeeld:\nSluit de potmeter aan op de Arduino Upload het programma voor de potmeter naar de Arduino, en zorg dat je de waarden van de potmeter te zien krijgt in de seri√´le monitor. Sluit vervolgens de buzzer aan (laat de potmeter aangesloten!). Zet de software voor de buzzer op de Arduino (laat het venster met de code met de potmeter openstaan), en ga pas verder als je de buzzer hoort. Stap 2 Nu heb je dus twee werkende programma‚Äôs, en die kun je gaan combineren tot √©√©n programma. Zet ze naast elkaar, zodat je beide vensters op je beeldscherm hebt.\nDigitalInputPullup void setup() { Serial.begin(9600); pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); } void loop() { int sensorVal = digitalRead(2); if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } } Sweep #include \u0026lt;Servo.h\u0026gt; Servo myservo; void setup() { myservo.attach(9); } void loop() { myservo.write(10); delay(1000); myservo.write(160); delay(1000); } In Arduino-schetsen mogen setup() en loop() maar √©√©n keer voorkomen. We kunnen de schetsen dus niet combineren door ze simpelweg de ene onder de andere te plakken.\nKopi√´er daarom de inhoud van de ene setup() naar de andere. Let op dat je geen accolades (gekrulde haken) meekopi√´ert. Let ook goed op dat je geen code boven of onder de accolades van setup() plaatst‚Äîde code hoort tussen { en } want anders werkt het niet.\nDoe hetzelfde voor loop() en eventuele regels die nog b√≥ven setup staan.\nVoor de afgebeelde schetsen ziet dat er zo uit:\nGecombineerd #include \u0026lt;Servo.h\u0026gt; Servo myservo; void setup() { Serial.begin(9600); pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); myservo.attach(9); } void loop() { int sensorVal = digitalRead(2); if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } myservo.write(10); delay(1000); myservo.write(160); delay(1000); } Stap 3 Laat je nieuwe schets controleren door Arduino. Gebruik daarvoor het eerste icoontje, links bovenaan. Als je linksonderin ziet ‚ÄòCompileren voltooid‚Äô dan heb je het samenvoegen goed gedaan! Als je een foutmelding krijgt, los het probleem dan op. Gebruik eventueel de checklist aan het eind van deze handleiding. Sla je gecombineerde schets op op je computer, via Bestand \u0026gt; ‚ÄòOpslaan als‚Ä¶‚Äô.\nSoms wil je twee schetsen combineren die allebei dezelfde pin in gebruik hebben. Als je die schetsen samenvoegt, zul je dus voor √©√©n van die twee inputs of outputs een andere pin moeten gebruiken en dat onderdeel dan dus ook op die andere pin op de Arduino moeten aansluiten. Stap 4 Nu heb je een schets die met twee componenten werkt. Als je hem uploadt naar de Arduino, dan zouden dus beide onderdelen het moeten doen.\nMaar je wil natuurlijk dat beide componenten s√°menwerken! Het makkelijkste is een if-statement gebruiken (zie de pagina daarover). Een andere mogelijkheid is de sensor-data direct gebruiken voor een output; je zou bijvoorbeeld waardes uit een lichtsensor direct kunnen gebruiken als de graden voor een servo-motor.\nIn Arduino-schetsen wordt vaak gebruik gemaakt van de functie delay(). Dat levert echter nogal eens problemen op als je de Arduino twee of meer dingen tegelijk willen laten doen. De oplossing daarvoor is een timer zetten; hoe dat moet, lees je op de pagina‚Äôs verderop over timers en millis(). Bestaande code gebruiken Wat je √≥√≥k kunt doen, is code van anderen gebruiken. Stel dat je een kleurensensor wil gebruiken samen met een paar LED-lampjes, dan kun je bij Google iets intypen als ‚ÄòArduino kleurensensor LEDs‚Äô. Je vindt ongetwijfeld een heleboel handleidingen die laten zien welke onderdelen ze gebruikten en hoe, inclusief de nodige code.\nAls je zulke code overneemt, lees die code dan in ieder geval goed door en probeer te begrijpen wat elk stukje doet. Als de code niet werkt, gebruik dan de checklist aan het eind van deze handleiding om het probleem op te lossen.\nDingen laten bewegen met servo-motors De simpelste manier om met de Arduino iets te laten bewegen (robotjes, plotters, bloempotten die naar het licht draaien) is een servo. Er zijn twee soorten: servo‚Äôs die draaien tussen 0 en 180 graden, en servo‚Äôs die door kunnen blijven draaien.\nZulke ‚Äòcontinuous‚Äô servo‚Äôs vertalen de richting die je ze opgeeft in een draairichting en snelheid. ‚Äò0‚Äô is 10 bijvoorbeeld volle snelheid naar links, ‚Äò90‚Äô is stilstaan en ‚Äò110‚Äô betekent ‚Äòdraai langzaam naar rechts‚Äô. Als je bij zo‚Äôn servo toch wil weten hoe ver hij is gedraaid, heb je een ‚Äòrotary encoder‚Äô of ‚Äòencoder wheel‚Äô nodig.\nDe meeste kleine servo-motors hebben drie draadjes:\nbruin is ground, dus min rood is voltage, dus plus geel is de pin waarop de Arduino de servo aanstuurt. Sluit de servo aan, met de gele draad op pin 9. Als je deze schets uploadt, gaat het motortje heen en weer draaien: Bestand \u0026gt; Voorbeelden \u0026gt; Servo \u0026gt; Sweep\nZoals je ziet in de code, wordt de servo naar een bepaalde plek gestuurd met de functie myservo.write(). In de schets gebeurt dat in een for-loop om hem stapsgewijs heen en weer te laten draaien, maar je kunt de servo bijvoorbeeld ook naar de middenpositie sturen met het commando\nGrotere servo‚Äôs De servo zoals op de foto is klein en niet erg sterk. Er zijn ook (veel) sterkere servo‚Äôs. Die kun je ook met de Arduino aansturen, maar om ze van stroom te voorzien is een externe batterij nodig:\nOefening Stuur de servo een paar keer naar verschillende standen, en laat hem tussendoor een seconde wachten. Hint: de for-loops heb je hiervoor niet nodig, want aan een paar myservo.write‚Äôs en delay()‚Äôs heb je genoeg.\nTot slot Je kunt met de Arduino ontelbaar veel combinaties maken met verschillende inputs en outputs. Je kunt bijvoorbeeld een MP3-speler geluiden laten horen als een bewegingssensor beweging detecteert, of LED-strips van kleur laten veranderen op basis van een hartslag die je meet met een hartslagsensor.\nWat je kunt maken met elektronica wordt praktisch nergens meer door beperkt. Onderdelen zijn ontzettend goedkoop geworden, en de informatie over hoe je ze moet aansluiten en kunt gebruiken is altijd online te vinden. Zoek bijvoorbeeld op Google naar ‚ÄòArduino planten vochtsensor‚Äô en je vindt duizenden handleidingen die niet alleen laten zien hoe je zo‚Äôn sensor aansluit op je Arduino, maar die ook de nodige code delen.\nEen paar sites zijn met name aan te raden voor inspiratie en praktische informatie:\nInstructables: https://www.instructables.com/circuits/arduino/projects/ Arduino: https://blog.arduino.cc/ en https://www.arduino.cc/reference/en/ Hackster.io: https://www.hackster.io/arduino Het belangrijkste is dat je ziet dat iedereen kan programmeren en toffe dingen kan maken met elektronica. Niemand kan of weet alles meteen, maar met oefening en gewoon blijven proberen kom je heel ver. Er is ontzettend veel mogelijk, en jij hoort bij de mensen die gave dingen kunnen maken.\nExtra Problemen oplossen Problemen met verbinding Dit is een lijst van mogelijke oplossingen als je er niet in slaagt om code te uploaden naar de Arduino. Als de eerste oplossing niet helpt, probeer dan de volgende oplossingen, in de volgorde waarop ze genoemd worden.\nSelecteer de juiste poort. Als je een foutmelding krijgt bij het uploaden, dan is het meestal omdat de computer niet weet op welke USB-poort de Arduino te vinden is:\nJe kunt dat oplossen door de juiste poort te selecteren in het menu Hulpmiddelen onder ‚ÄòPoort‚Äô. Soms staat er al bij waar de Arduino is verbonden, maar de kans bestaat dat je zelf moet raden. Het zou een adres moeten zijn met ‚Äòusb‚Äô erin, ‚Äòserial‚Äô of ‚ÄòCOM‚Äô. Zorg dat onder ‚ÄòBoard‚Äô de juiste Arduino is geselecteerd (meestal Arduino Uno). Zit de USB-kabel er aan beide kanten goed in? Probeer eens een andere USB-poort (en dan weer stap 1). Herstart de Arduino-software. Probeer het uploaden zonder dat er iets met de Arduino verbonden is. (Als dit helpt dan is er ergens kortsluiting √≥f is er iets verbonden met de verkeerde pin.) Herstart de computer (en zie dan weer stap 1). Als je computer de Arduino niet kan vinden onder ‚ÄòPoort‚Äô, dan kan het nodig zijn om een driver installeren. Voer de instructies uit op https://docs.arduino.cc/tutorials/generic/DriverInstallation/ (en doe dan weer stap 1). Probeer een andere Arduino Problemen met de code De foutmeldingen die Arduino geeft onderin beeld zijn vaak behoorlijk helder. Probeer ze te begrijpen zodat je sneller een probleem kunt opsporen en oplossen.\nWaar zit de fout? Vind de regel die rood is gemaakt. De fout kan ook direct boven die regel zitten. De meest voorkomende fout is dat een functie of commando niet goed afgesloten wordt. Staat er een ‚Äò}‚Äô te veel of te weinig? Zorg dat er voor elke ‚Äò(‚Äô een ‚Äò)‚Äô is en voor elke ‚Äò{‚Äô ook een afsluitende ‚Äò}‚Äô en dat elk commando wordt afgesloten met een puntkomma. Staat alle code wel echt √≠n setup() of loop()? Dus binnen de gekrulde haken van een van beide functies? Als je schets een library aanroept die niet gevonden kan worden, dan krijg je de foutmelding ‚ÄòNo such file or directory‚Äô. Installeer in dat geval alsnog de bijbehorende library; zie daarvoor de pagina ‚ÄòLibraries installeren‚Äô in deze handleiding. Zoek online naar oplossingen voor de foutmelding die je krijgt. Zoek naar ‚ÄòArduino ‚Äúexacte foutmelding tussen aanhalingstekens‚Äù‚Äô. Gebruik een heel andere schets. Probeer een van de voorbeeldschetsen in Arduino en pas die aan, of probeer online code te vinden die doet wat jij wil. Geen foutmelding, maar toch niet de werking die je verwacht? Check of de componenten echt met de juiste pinnen zijn verbonden en dat dat ook de pinnen zijn die genoemd worden in de code. Bij gebruik van een breadboard: zitten de componenten √©cht op het goede rijtje? Gebruik Serial.println()‚Äôs om te weten wat de Arduino aan het doen is (zie de uitleg daarover op de pagina over de seri√´le plotter). Probeer een ander exemplaar van het onderdeel dat je probeert aan te sluiten, om te zien of dat misschien het probeem is. Probeer eventueel ook andere draadjes of zelfs een ander breadboard. Libraries installeren Je hoeft lang niet alles helemaal zelf te programmeren. Er is al heel veel software geschreven door mensen die hun werk graag met je delen (dat heet open-source software en het is geweldig!).\nAls zulke software uitgebreider is dan een enkele schets, dan heet zo‚Äôn software-pakketje een bibliotheek, of library. Het Arduino-programma heeft een aantal libraries al voor-ge√Ønstalleerd, maar soms zul je dat zelf moeten doen.\nStel dat je een infrarood-sensor wil uitproberen om met een afstandsbediening je Arduino-project te kunnen bedienen. Dat wordt je makkelijk gemaakt door een library die IRremote heet.\nGa naar het menu Hulpmiddelen \u0026gt; Bibliotheken beheren. Zoek op ‚ÄòIRremote‚Äô in het zoekvenster, en dan staat hij waarschijnlijk als tweede in de lijst resultaten.\nKlik op ‚ÄòInstalleren‚Äô en dan ‚Äòsluiten‚Äô.\nAls je een library ge√Ønstalleerd hebt, kun je via Bestand \u0026gt; Voorbeelden de voorbeeldschetsen openen die bij de library horen. Met die schetsen kun je snel leren hoe je de library kunt gebruiken in je eigen project.\nIn het geval van IRremote: Bestand \u0026gt; Voorbeelden \u0026gt; IRremote \u0026gt; IR receiveDemo. Meer uitleg over 12 afstandsbedieningen en hoe je de library gebruikt vind je hier: https://www.circuitbasics.com/arduino-ir-remote-receiver-tutorial/\nNiet √°lle bibliotheken kun je op deze manier installeren. Soms moet je een map met bestanden downloaden en die dan handmatig toevoegen aan de map waar Arduino de bibliotheken bewaart. De locatie van die map vind je via het menu Arduino \u0026gt; Preferences. Een timer voor Arduino-programma‚Äôs: millis() Als je Arduino twee dingen tegelijk wil laten doen, zoals een lampje laten knipperen en ondertussen in de gaten houden of een knop wordt ingedrukt, dan is het belangrijk om g√©√©n delay() te gebruiken. De functie delay() zorgt ervoor dat de de Arduino een tijdje wacht, en ondertussen staat alles stil. Als hij bijvoorbeeld wacht tot de LED weer aan of uitgezet kan worden, kan hij dus niet tegelijk in de gaten houden of de knop wordt ingedrukt.\nOm zoiets wel tegelijk te kunnen doen, laten we Arduino een soort stopwatch gebruiken. Die stopwatch heet millis(). Met die functie kunnen we in de gaten houden hoe lang onze schets al loopt, en op gezette tijden iets doen.\nHieronder zie je bijvoorbeeld een schets die elke drie seconden een LED aan- of uitzet, z√≥nder in de tussentijd alles te blokkeren met delay().\nIn het Engels heet deze oplossing ook ‚Äònon-blocking code‚Äô, code die niet blokkeert. Er is een handige library voor, die arduino-timer heet. Daarmee kun je meerdere ‚Äòstopwatches‚Äô in √©√©n schets hebben. Als je hem installeert (zie ‚ÄòLibraries installeren‚Äô), zie je de mogelijkheden in de bijbehorende voorbeeldschetsen.\n// Begintijd is het aantal milliseconden sinds het script begon. int begintijd = millis(); void setup() { pinMode(LED_BUILTIN, OUTPUT); // Het ingebouwde LEDje op de Arduino activeren } void loop() { if ((millis() - begintijd) \u0026gt; 3000) { // Zijn er al 3 seconden verstreken? // Zo ja, doe dan dit: // verander de LED naar aan of uit // (het uitroepteken betekent \u0026#39;maak er van wat hij nu NIET is\u0026#39;) digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN) ); // reset de stopwatch: verander begintijd naar het aantal milliseconden NU begintijd = millis(); } // Nu kunnen we hier andere dingen doen, zoals motortjes laten draaien, of in // de gaten houden of knoppen worden ingedrukt, z√≥nder te wachten op delays. } Wat je kunt meten en doen met Arduino Inputs Outputs Afstandssensor Licht: lampen, lasers, LEDs, EL wire, glasvezel Accelerometer Geluid: speakers, transducers, versterkers, MP3-spelers\nEr zijn er verschillende, maar deze is goedkoop en gemakkelijk aan te sluiten: https://wiki.dfrobot.com/DFPlayer_Mini_SKU_DFR0299 Gyroscoop Motoren: servo‚Äôs, heel precieze stappenmotoren, hele snelle DCmotoren, heel sterke gear motors, trilmotors, lineaire actuatoren, ventilatoren. Kompas Solenoids Temperatuur Elektromagneten, ferrofluids Relatieve luchtvochtigheid Video (animaties, video‚Äôs, VR/AR) Vochtsensor (planten water geven!) LCD-display (zoals in snoepautomaten) Barometer Pomp (bijv. om het te laten regenen of een beeld te laten huilen) Lichtsensor Metaal dat van vorm verandert Kleurensensor Warmte- en koel-elementen Draaiknoppen en lineaire potmeters (zoals de schuiven op mengpanelen) Rookmachine Microfoons (of andere audio-signalen) Website of sociale media (automatisch informatie posten op basis van sensorgegevens) Aanraking Schakelaars Keyboard en muis Vingerafdruk Camera‚Äôs Bewegingssensor Infrarood-ontvanger (je project besturen met afstandsbediening!) Hartslag\nSommige hartslagsensors werken amper. Deze is wat duurder, maar geeft wel redelijk goede meetresultaten: https://www.kiwi-electronics.com/nl/max30101-breakout-heart-rate-oximeter-smoke-sensor-4073 Rook Gas Straling Vlammendetector Magneetvelden Trilling Buigsensor Stroming Hersenactiviteit Dit is zeker geen complete lijst, maar je ziet vast zo al dat de mogelijkheden eindeloos zijn. Welke combinaties van inputs en outputs lijken jou interessant?\nLicentie Deze handleiding is geschreven door Jaap Meijers (instructeur/beheerder van het Hacklab van de Koninklijke Academie van Beeldende Kunsten in Den Haag en mentor van CoderDojo Nijmegen) en gepubliceerd in mei 2021 onder de Creative Commons Attribution 4.0 Internationallicentie. Dat betekent dat je deze handleiding vrij mag verspreiden en aanpassen, mits je de bron vermeldt en verwijst naar de licentie.\nDe broncode voor deze instructie vind je hier https://github.com/coderdojonijmegen/arduino-snelle-introductie.\nVerantwoording foto‚Äôs Arduino met relais en lamp: Adilson Thomsen/FilipeFlop/Wikimedia Breadboard: Victoria.nunez2/Wikimedia LDR: Arnau 944/Wikimedia Potmeter: Iainf/Wikimedia Piezo buzzer: Adafruit/Flickr Ultrasone afstandssensor: Nowforever/Wikimedia Microservo: eigen foto Arduino met bloemen: madshobye/Instructables.com Diagram IR-remote bij ‚ÄòLibraries installeren‚Äô: Benne de Bakker/makerguides.com Stopwatch: Matthew/Flickr Losse onderdelen: Robin Glauser/Unsplash Diagrammen met potmeter, ultrasone afstandssensor en servo: Fritzing.org Alle screenshots van Arduino IDE, diagram bij ‚ÄòDigitale sensors‚Äô en de foto van Arduino-bord bij ‚ÄòWat is de Arduino‚Äô: Arduino.cc ","date":"June 27, 2021","permalink":"/instructies/arduino-snelle-introductie/","title":"Arduino - een snelle introductie"},{"categories":null,"contents":"\nWat gaan we doen? Het is al weer heel lang geleden, maar we kunnen eindelijk weer live! We gaan dan ook met een onderwerp aan de gang dat we online niet konden behandelen: de Arduino programmeren!\nVoorbereiding Neem een laptop mee, en installeer om snel aan de slag te kunnen de Arduino IDE.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nCorona We zijn blij dat we weer bij elkaar kunnen komen, natuurlijk houden we ons wel aan de regels die er momenteel gelden. Dus:\nwas je handen regelmatig met water en zeep, zit niet met je handen aan je gezicht, schud geen handen, hoest of nies in je elleboog en gebruik papieren zakdoekjes om je neus te snuiten en gooi deze daarna weg. Wij zorgen voor handgel en schoonmaakdoekjes. kinderen t/m 12 jaar hoeven geen afstand te houden van elkaar en volwassenen jongeren boven de 12 hoeven geen afstand te houden van elkaar, wel van volwassenen volwassenen houden 1,5 m afstand van elkaar kom alleen als het antwoord op alle onderstaande vragen \u0026ldquo;nee\u0026rdquo; is: - Had je een of meerdere van deze klachten in de afgelopen 24 uur, namelijk hoesten, verkoudheidsklachten, verhoging of koorts, benauwdheid, reuk- en/of smaakverles? - Heb je op dit moment een huisgenoot met milde klachten en koorts en/of benauwdheid? - Heb je het nieuwe coronavirus gehad en is dit de afgelopen 7 dagen vastgesteld (met een test)? - Ben je in quarantaine omdat je een huisgenoot of nauw contact bent van iemand bij wie het nieuwe coronavirus is vastgesteld, bent (terug)gekomen uit een COVID-19-risicogebied, of bent gewaarschuwd door de Coronamelder-app? Wanneer en waar? 3 juli van 12:15u tot 14:30u (let op: starttijd is iets anders!). Locatie is vlakbij de Smeltkroes op het Honigterrein (Waalbandijk 16, 6541 AJ Nijmegen), onder de overkapping.¬†No show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"June 21, 2021","permalink":"/dojos/78-live-arduino/","title":"#78 LIVE: Arduino"},{"categories":null,"contents":"We gaan een chat programma maken!\nBenodigdheden Voordat we aan de slag kunnen, moeten we eerst een paar dingen regelen. We hebben een checklist gemaakt van alles wat je nodig hebt, daaronder volgt per stap de uitleg.\nChecklist De skeleton app Een tekst editor Een web browser Een web server De chat server URL De developers tools De skeleton app Klik hier om de skeleton app te downloaden. Pak dit bestand uit naar een map, bijvoorbeeld op je bureaublad.\nDit zijn de bestanden die je nodig hebt om te beginnen: een html file, een css file en een javascript file. Elk bestand heeft z\u0026rsquo;n eigen hoofdstuk, waarin je dat bestand gaat bewerken en je eigen dingen toe voegt.\nAls je ergens een foutje maakt, kun je de bestanden altijd opnieuw uitpakken.\nEen tekst editor Als je nog geen tekst editor hebt, adviseren wij Visual Studio Code. Gebruik je een Chromebook? Dan kun je de Text app gebruiken. Als het goed is, staat die al op je Chromebook.\nDownload, installeer en open VS Code. In VS Code klik je op \u0026ldquo;Open Folder\u0026rdquo;, selecteer dan de map waar je de skeleton app hebt uitgepakt.\nAndere tekst editors zijn ook prima, als je aan iets anders gewend bent. Bijvoorbeeld: Notepad++ of Sublime Text.\nEen webbrowser In alle voorbeelden gebruiken wij Google Chrome. Andere browsers, zoals Firefox of Edge, zijn ook prima, mogelijk zien de app en developers tools er dan wel anders uit dan in Chrome.\nControleer ook of je de nieuwste versie hebt van de browser, om zeker te weten dat de app goed werkt.\nEen webserver Om je app te zien, moet je een webserver hebben die je browser de app laat openen. Als je een Chromebook gebruikt, ga dan naar Webserver voor Chromebooks.\nEen eenvoudig programma om op je eigen computer een webserver te draaien is Caddy. Je kunt Caddy downloaden voor Windows, MacOS en Linux.\nPak Caddy uit en zet het in de map waar je eerder client.zip hebt uitgepakt. Nadat je het bestand hebt uitgepakt, heb je slechts √©√©n bestand: caddy (of caddy.exe voor Windows).\nOpen een command prompt (cmd) of terminal en start Caddy met het volgende commando: caddy file-server --browse --listen :8123\nOpen vervolgens je browser en ga naar http://localhost:8123.\nAls alles goed is gegaan, zie je dit:\nAls iets fout is gegaan, kun je iets zien zoals dit:\nVraag dan een mentor even mee te kijken.\nWebserver voor Chromebooks Dit stukje sla je over als je geen Chromebook gebruikt en Caddy hebt ge√Ønstalleerd.\nWij adviseren Web Server for Chrome. Installeer de web server en open de app. Je ziet dan een instellingen pagina. Selecteer hier de uitgepakte map en stel de server in zoals op deze afbeelding:\nLet op: De CORS headers zijn heel belangrijk om de chat werkend te krijgen.\nKlik vervolgens op de link onder \u0026ldquo;Web Server URL(s)\u0026rdquo; of open je browser en ga naar http://localhost:8887.\nLukt het niet? Vraag dan een mentor even mee te kijken.\nDe chat server URL Je app moet weten waar de chat server is, zodat je met anderen berichtjes kunt uitwisselen.\nZoek serverIpAddresEnPoort in je index.html bestand om te zien waar de server is:\n\u0026lt;script\u0026gt; var serverIpAdresEnPoort = \u0026#34;https://chat.coderdojo-nijmegen.nl\u0026#34;; \u0026lt;/script\u0026gt; De developers tools Als het goed is, heb je nu alles om je app te bouwen. Open de link van je webserver in Chrome, als het goed is zie je dan drie gekleurde balken.\nKlik met je rechter muisknop op √®√®n van die balken en klik op \u0026ldquo;Inspect\u0026rdquo;. Hiermee open je de developers tools van Chrome, waar je kan sleutelen aan alle onderdelen van de app. De aanpassingen die je in de developer tools maakt, worden niet opgeslagen en zijn weer weg zodra je de chat app ververst in Chrome.\nVoor de chat app is het fijn om de developers tools rechts van je scherm te zetten met deze knop, rechts van je tools.\nSleep de rand van de tools dan zo, dat het ongeveer de helft van je scherm in beslag neemt.\nStructuur (HTML) Deze instructies bestaan uit drie hoofdstukken:\nStructuur (HTML) - hier gaan we de app onderdelen in elkaar zetten. Stijl (CSS) - hier gaan we veranderen hoe de onderdelen eruit zien. Scripts (Javascript) - hier gaan we veranderen hoe de app werkt. Bij elk hoofdstuk hoort een bestand. Voor dit hoofdstuk werken we in de index.html.\nHTML: blokjes en tekst In het begin zul je nog niet alles snappen wat in de bestanden staat. Dat is ok√®! Laten we eerst rond kijken en dan gaan we onze eigen onderdelen toevoegen:\nOpen de app en de developers tools (zie Benodigdheden). Klik op de Inspect knop (zie afbeelding), zodat deze blauw wordt.\nBeweeg de muis over de groene, gele en grijze balken in de app. Je ziet de \u0026lsquo;div\u0026rsquo; elementen in de Developers Tools oplichten. Dat zijn de \u0026lsquo;blokjes\u0026rsquo; waarmee je begint. Een paar dingen moet je weten over die blokjes:\nEen blok begint met \u0026lt;div\u0026gt; en eindigt met \u0026lt;/div\u0026gt;. Met class=\u0026quot;\u0026quot; krijgt het blokje een class naam. De class wordt in de CSS (hoofdstuk 2) gebruikt om te bepalen hoe het eruit ziet. De class wordt ook in de Javascript (hoofdstuk 3) gebruikt om te bepalen hoe het werkt. Blokjes kunnen in elkaar en blokjes kunnen naast elkaar. HTML tekst In de HTML kun je tekst typen. Afhankelijk van waar je die tekst typt, komt het ergens anders op het scherm (of misschien zelfs helemaal niet).\nZoek de div blokjes op in de index.html, het zijn er vier. De \u0026lsquo;container\u0026rsquo; class zorgt ervoor dat de blokjes die er in zitten onder elkaar komen. In de container zie je drie andere divs. Kun je raden waar die voor zijn? Schrijf wat tekst, bijvoorbeeld \u0026ldquo;Hallo wereld!\u0026rdquo;, in het blokje met de class \u0026lsquo;midden\u0026rsquo;. Ververs je pagina. Staat je tekst in het middelste blokje? Zo niet, dan is er misschien iets mis gegaan. Probeer ook tekst te typen in de boven en onder blokjes. Verschijnt die tekst ook op de juiste plek in je scherm? Wat gebeurt er als je tekst typt in de container, maar buiten de boven/midden/onder blokjes? Wat gebeurt er als je tekst typt buiten de container (maar wel in de \u0026lt;body\u0026gt;)? Chat berichten Nu dat je snapt hoe de HTML blokjes werken, kun je je eigen blokjes toe voegen.\nVoeg deze code in, in het blokje \u0026ldquo;midden\u0026rdquo;:\n\u0026lt;div class=\u0026#34;berichten\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Ververs de pagina. Als het goed is, verschijnen nu de chat berichten op je scherm! Zo makkelijk kan het zijn om onderdelen toe te voegen.\nBerichten typen We willen natuurlijk ook berichten kunnen sturen.\nVoeg deze code in, in het blokje \u0026ldquo;onder\u0026rdquo;:\n\u0026lt;div class=\u0026#34;berichtInput\u0026#34;\u0026gt;Type hier...\u0026lt;/div\u0026gt; Als het goed is, zie je \u0026ldquo;Type hier\u0026hellip;\u0026rdquo; op je scherm, maar als je daar klikt, kun je nog niet typen. Dat komt, omdat div daar niet voor is gemaakt. Verander het woord div in textarea, en ineens ziet het er heel anders uit:\n\u0026lt;textarea class=\u0026#34;berichtInput\u0026#34; placeholder=\u0026#34;Type hier...\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; Je kunt nu tekst typen. Als je op enter drukt, wordt je bericht verstuurd!\nMeer onderdelen Laten we nog wat meer onderdelen toevoegen. Kopieer deze blokjes en plak ze in de boven/midden/onder blokjes. Je mag zelf bepalen waar deze blokjes in je app komen en in welke volgorde. Je kan ook ons voorbeeld onderin deze pagina na maken.\nTips:\nProbeer niet alles tegelijk te doen. Plak een blokje in de index.html, sla op en ververs de pagina in chrome. Staat een blokje niet op de plek die je had verwacht? Gebruik de Inspect Element knop om te ontdekken wat er mis is gegaan! De boven/midden/onder classes heb elk hun eigen manier van blokjes plaatsen. Hier gaan we in het volgende hoofdstuk verder op in. Verander teksten en de type blokjes, je kan er vanalles van maken. Zolang de \u0026lsquo;class\u0026rsquo; klopt, zou het moeten blijven werken. De blokjes \u0026lt;h1\u0026gt;Ninja chat\u0026lt;/h1\u0026gt; Met h1 plaats je een titel, de letters zijn dan groter en dikker. Het heeft verder geen speciale effecten, dus h1 is net als een div. Probeer ook h2 en h3 voor verschillende grooottes.\n\u0026lt;div\u0026gt;Naam: \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;naamInput\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Een input is een speciaal soort blokje, waar je iets kan typen of aanklikken. Een input hoeft niet afgesloten te worden, want er kan nooit html in een input staan. Met type=\u0026ldquo;text\u0026rdquo; wordt gezegd dat je tekst kan typen. De class \u0026rsquo;naamInput\u0026rsquo; is voor het invoeren van je naam. We hebben de input in een div blokje geplaatst, zodat de tekst \u0026ldquo;Naam\u0026rdquo; er mooi bij komt te staan. Verander de standaard naam in je eigen naam, omdat bij de berichten terug te zien.\n\u0026lt;div\u0026gt;Kanaal: \u0026lt;input type=\u0026#34;number\u0026#34; class=\u0026#34;kanaalInput\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Ook dit is een input, nu met type \u0026rsquo;number\u0026rsquo;, zodat je alleen een getal kan invullen. Elk bericht hoort bij een kanaal en je kanaal is standaard \u0026lsquo;1\u0026rsquo;.\n\u0026lt;button class=\u0026#34;stuurBericht\u0026#34;\u0026gt;Stuur bericht\u0026lt;/button\u0026gt; Button is Engels voor het woord \u0026lsquo;knop\u0026rsquo;. Tot nu toe stuurde je berichten door op \u0026rsquo;enter\u0026rsquo; te drukken, nu kan het ook door op deze knop te klikken.\n\u0026lt;div class=\u0026#34;deelnemers\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Deze div is nog leeg, het doet niets totdat er op de deelnemers knop wordt gedrukt. Maar die knop heb je nog niet, dus die volgt nu:\n\u0026lt;button class=\u0026#34;bekijkDeelnemers\u0026#34;\u0026gt;Bekijk deelnemers\u0026lt;/button\u0026gt; Je krijgt dus een knop waarmee je deelnemers kan bekijken, zodra daar op wordt geklikt wordt de \u0026lsquo;deelnemers\u0026rsquo; div gevuld met de namen van de andere ninja\u0026rsquo;s en mentoren. Deze knop mag ook in de \u0026lsquo;deelnemers\u0026rsquo; div staan, zodat de namen en de knop mooi bij elkaar staan.\nHTML in berichten Wat de ninja-chat zo bijzonder maakt, is dat je HTML in je berichten kan gebruiken. Type maar eens als bericht in de chat:\n\u0026lt;h1\u0026gt;Hallo wereld!\u0026lt;h1\u0026gt; Zoals eerder gezegd, is h1 een blokje zoals de div. Maar niet elke HTML code is een eigen blokje. Je kan ook HTML gebruiken om een woord of meerdere woorden op te maken. Type dit als bericht in de chat:\nHier is woord \u0026lt;strong\u0026gt;dikgedrukt\u0026lt;/strong\u0026gt; en twee woorden \u0026lt;em\u0026gt;schuin gedrukt\u0026lt;/em\u0026gt;!\nProbeer ook andere HTML code die je hebt geleerd in je berichten. Alles mag!\nAfbeeldingen Het mooiste HTML blokje hebben we bewaard voor het laatst: je kan plaatjes zien in je app!\n\u0026lt;img src=\u0026#34;coderdojo.png\u0026#34;\u0026gt; Het plaatje is erg groot, eigenlijk te groot om mooi in de app te passen. Dit is makkelijk op te lossen door een width (= breedte) en een height (= hoogte) bij te voegen:\n\u0026lt;img src=\u0026#34;coderdojo.png\u0026#34; width=\u0026#34;32\u0026#34; height=\u0026#34;32\u0026#34;\u0026gt; Net als een input blokje, hoeft de img niet afgesloten te worden. De link voor het plaatje schrijf je in src=\u0026quot;\u0026quot;. We gebruiken nu de bijgesloten coderdojo.png als voorbeeld, maar het kan elk plaatje zijn wat je maar wilt.\nZo kies je je eigen plaatjes:\nZoek op internet een plaatje dat je in de app wilt hebben. Klik met rechtermuisknop op het plaatje en selecteer \u0026ldquo;afbeeldingsadres kopi√´ren\u0026rdquo;. Type een nieuw img blok in je index.html en ze je cursor in de aanhalingstekens van de src. Gebruik rechtermuisknop en klik op plakken, of type CTRL-V om te plakken. Sla op en bekijk je plaatje in de app. Tip: Op deze manier kun je ook plaatjes in je chat berichten plaatsen.\nStijl (CSS) Je weet nu hoe je HTML blokjes kan plaatsen en je weet hoe je die een class naam kan geven. Die class namen gaan we nu gebruiken om ze te stylen: je kan helemaal veranderen hoe ze eruit zien!\nVoor dit hoofdstuk werk je voornamelijk in het bestand basic-chat.css.\nKleuren en lettertypes Laten we eerst kleuren aanpassen:\nZoek het div blokje \u0026lsquo;midden\u0026rsquo; in de Developers Tools, gebruik eventueel Inspect Element op de gele achtergrond. Rechts zie je een tabblad \u0026ldquo;Styles\u0026rdquo;, hier staan alle CSS regels voor dit blokje. Schrik niet, het zijn er veel! Zoek de regel background-color: lightyellow (TODO: screenshot met een pijl ofzo). Klik op het woord lightyellow en druk op backspace. De browser toont al een lijst van kleuren, klik of type cadetblue. Zie hoe de kleur van het midden blok is veranderd! Verander van andere blokjes ook de background-color. Probeer verschillende kleuren uit. De kleuren die je nu in stelt worden nog niet opgeslagen. De volgende keer dat je refresht is alles weer terug naar hoe het was.\nStyling opslaan Dit is hoe je je kleuren kan opslaan:\nNoteer of kopieer de naam van de kleur die je wilt opslaan. Je kunt ook een kleur kiezen op deze website: csscolornames.com Open de basic-chat.css. Zoek de regel .midden {, hier staan de stijl regels voor het midden blok. Verander de background-color in een kleur naar keuze en sla het bestand op. Refresh je browser en zie de kleur die je hebt gekozen in het midden blok. Op deze manier kun je alle achtergrond kleuren instellen die je wilt. Zoek de andere onderdelen van je app op in het CSS bestand en geef ze een kleur die je leuk vindt.\nTekst Je kunt ook teksten er anders uit laten zien. Voeg deze regels eens toe, bijvoorbeeld bij .bericht:\ncolor: yellow; font-family: \u0026#39;Indie Flower\u0026#39;, cursive; color verandert de kleur van de tekst. Je kunt dezelfde kleuren gebruiken als voor background-color.\nfont-family verandert het lettertype. Kun je ontdekken welk lettertype nog meer wordt gebruikt in de app?\nProbeer deze kleuren eens na te maken. Tip: Geef de titel een nieuwe class naam en gebruik die class naam om in de CSS het lettertype in te stellen.\nVormen en randen Alles op het scherm kunnen we groter of kleiner maken. Probeer dit eens uit:\nKlik op √©√©n van de berichten, met Inspect Element. Bij de styles zie je onder andere padding, border en margin. Verander de getallen √©√©n voor √©√©n en kijk wat er gebeurt: maak ze 40px, of 1px, of 0. Je ziet ook border-radius, verander daarvan ook het getal. Verander de kleur van \u0026lsquo;border\u0026rsquo; (border is Engels voor \u0026lsquo;rand\u0026rsquo;). Verander bij de border het woord \u0026lsquo;solid\u0026rsquo; in \u0026lsquo;dotted\u0026rsquo; en kijk wat er gebeurt. Het is makkelijker om te zien wat het doet, dan om het uit te leggen. In het kort:\n10px betekent 10 pixels. Een pixels is een punt op je scherm. border is de rand van een blokje. Het is een lijn of stippels, heeft een kleur en een dikte. padding is hoeveel ruimte er IN het blokje is, voordat de tekst begint. margin is hoeveel ruimte er OM het blokje heen is. border-radius is om te rand rond te maken. Tip: Probeer eens een blokje helemaal rond te maken met border-radius.\nMeer CSS Met CSS kun je van elk blokje zeggen hoe het eruit moet zien. Als je het leuk vindt, kun je in de basic-chat.css nog andere blokjes aanpassen met de border en padding enzo. Je kunt ook kijken welke CSS opdrachten er nog meer in staan. We hebben zoveel mogelijk in het bestand beschreven wat we doen, als je twijfelt kun je altijd nog op internet zoeken. Succes!\nStyling in berichten Je kunt ook CSS in je berichten gebruiken! Schrijf bijvoorbeeld eens:\nHier is een stukje tekst \u0026lt;span style=\u0026#34;color:blue;\u0026#34;\u0026gt;blauw\u0026lt;/span\u0026gt; Met style=\u0026quot;\u0026quot; kun je CSS in een HTML blokje stoppen. Dat werkt dan alleen voor dat ene blokje, maar dat is perfect voor in berichten. Probeer ook eens de andere CSS commando\u0026rsquo;s die je hebt geleerd, zoals border en font-family.\nTip: als je meerdere CSS commando\u0026rsquo;s in √©√©n blokje wilt, zet je er een ; tussen. Bijvoorbeeld:\n\u0026lt;span style=\u0026#34;color:white;background-color:black\u0026#34;\u0026gt;Dit bericht is zwart/wit.\u0026lt;/span\u0026gt; Scripts (JavaScript) Nu dat je een complete app hebt en zelf heb bepaald hoe het eruit ziet, gaan we een kijkje onder de motorkap nemen: hoe worden de berichten verstuurd en ontvangen?\nVoor dit hoofdstuk werk je in het bestand basic-chat.js.\nJavascript: de basis Javascript is de programmeertaal van het web. Alle HTML blokjes die je nu in je app hebt, kun je met Javascript aan sturen. Je kunt ook berichten sturen naar de server en ontvangen van de server. Daar gaan we mee aan de slag.\nKlik bovenin de Developers Tools op het tabblad \u0026ldquo;Console\u0026rdquo;. Je ziet een groot vlak en misschien een paar berichten. Onder de berichten, zie je een blauwe \u0026gt;, klik daar naast zodat je kan typen. Type de onderstaande berichten. Druk na elk bericht op enter en zie wat er gebeurt: console.log(\u0026#34;Hallo console!\u0026#34;) socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo websocket!\u0026#34;) Je hebt nu een berichtje in de console √©n je hebt een berichtje via de chat verstuurd! Allebei kunnen ze heel handig zijn! Laten we zien wat we nog meer kunnen met Javascript.\nAls je iets wilt weten van je app, kun je een commando geven dat iets terug geeft om te onthouden. Type eens:\n$(\u0026#34;.naamInput\u0026#34;).val() Je ziet je naam nu terug in de console! Deze commando ziet er misschien gek uit, dit is wat er gebeurt:\n$(\u0026quot;.naamInput\u0026quot;) zoekt de blokjes op met de class \u0026rsquo;naamInput\u0026rsquo;. .val() vraagt om de tekst die staat ingevuld bij het eerst gevonden blokje. Kun je op die manier ook het kanaal op vragen? Of een bericht in de chat?\nVariabelen Met variabelen (var) kan de browser dingen onthouden:\nvar naam = $(\u0026#34;.naamInput\u0026#34;).val() socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo, mijn naam is \u0026#34; + naam) Je hebt nu een bericht verstuurd met je naam er in! Kun je hetzelfde doen met je kanaal?\nBerekeningen Computers zijn ook heel goed in rekenen. Het woord computer is zelfs Engels voor \u0026ldquo;berekenaar\u0026rdquo;! Type het volgende maar eens om uit te proberen:\nvar kanaal = $(\u0026#34;.kanaalInput\u0026#34;).val() kanaal + 2 Dit gaat nog niet goed: het getal 2 is achter het kanaal nummer geplaatst. Dat komt omdat javascript niet gelijk snapt dat het een getal is:\nparseInt(kanaal) + 2 Nu zie je je kanaal, met twee erbij opgeteld. Om de oefening af te maken, laten we de server vertellen dat we een nieuw kanaal willen:\nsocket.emit(\u0026#34;zetKanaal\u0026#34;, parseInt(kanaal) + 2) Functies en parameters Je hebt al verschillende commando\u0026rsquo;s aangeroepen, zoals socket.emit en parseInt, maar je kan ook je eigen commando\u0026rsquo;s maken. Dat noemen we functions. Type dit eens in je console:\nfunction hallo(naam) { socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;Hallo \u0026#34; + naam + \u0026#34;!\u0026#34;) } Er gebeurt nog niets. Dat komt omdat je de function eerst moet aanroepen, voordat er iets gebeurt:\nhallo(\u0026#34;ninjas\u0026#34;) hallo(\u0026#34;ikzelf\u0026#34;) hallo(\u0026#34;javascript\u0026#34;) Je kan de functie zo vaak aanroepen als je maar wilt.\nJe eigen bot Je weet nu al veel over hoe je commando\u0026rsquo;s geeft en maakt in Javascript. Met functions kun je ook reageren op dingen die gebeuren. Zo kun je een function schrijven die reageert op berichten in de chat:\nfunction hoiDoei(bericht) { if (bericht.tekst == \u0026#34;hoi\u0026#34;) { socket.emit(\u0026#34;maakBericht\u0026#34;, \u0026#34;doei\u0026#34;) } } Het woord if is Engels voor \u0026lsquo;als\u0026rsquo;. Er staat dus: als het bericht \u0026ldquo;hoi\u0026rdquo; is, zeg dan \u0026ldquo;doei\u0026rdquo;. Maar hoe ontvangen we berichten?\nsocket.on(\u0026#34;krijgBericht\u0026#34;, hoiDoei) Elke keer als er een bericht binnen komt, wordt de commando hoiDoei aangeroepen. Type maar eens het woord \u0026ldquo;hoi\u0026rdquo; in de chat!\nNog veel meer Met HTML, CSS en Javascript kun je hele programma\u0026rsquo;s bouwen, zoals je ziet. Er valt nog ontzettend veel te leren! De eerst volgende stap is om de basic-chat.js te lezen en je kan dat bestand ook aanpassen, om andere dingen te doen: automatisch van kanaal wisselen bij een bericht, je naam veranderen via een bericht, enzovoorts. Je kunt ook altijd op internet zoeken naar wat je nog meer kan met HTML, CSS en Javascript, de website https://www.w3schools.com/ is een leuke plek om te beginnen. Heel veel plezier en heel veel succes!\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"May 24, 2021","permalink":"/instructies/javascript-ninja-chat/","title":"Javascript - Ninja-Chat"},{"categories":null,"contents":"\nWat gaan we doen? Deze dojo ga je zelf een chatprogramma maken! Iets preciezer: je gaat aan de slag met het deel van het programma dat op jouw eigenlijk computer draait. Je leert hierbij hoe de talen van het web HTML, CSS en JavaScript werken.\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus!\nOp de informatiepagina van het online evenement plaatsen we de link naar de Jitsi sessie en de instructies die we voor deze dojo gaan gebruiken.\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Als je vooraf een opdracht uitzoekt, kijk dan alvast of je hier software voor moet installeren - dat scheelt tijd tijdens de dojo!\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het fijn als een ouder of verzorger je kan begeleiden tijdens de dojo.\nWanneer en waar? Zaterdag 5 juni van 12:30u tot 14:30u.\nVoor deze dojo blijf je THUIS, achter de computer.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"May 24, 2021","permalink":"/dojos/77-online-bouw-je-eigen-chat-app/","title":"#77 online: bouw je eigen chat app!"},{"categories":null,"contents":"\nWat gaan we doen? Bij deze dojo bepaal je zelf waar je mee aan de slag gaat, en helpen wij je daarbij (als je niet kunt kiezen kunnen we je daar ook bij helpen)! Dus wil je programmeren met Scratch, Python, of Love, een webpagina maken of bijvoorbeeld een spel in MakeCode Arcade - schrijf je in voor de dojo en we helpen je met je uitdaging of opdracht. Zie bijvoorbeeld de projecten van de Raspberry Pi Foundation of die CoderDojo Nijmegen hier en hier heeft staan. Let wel: opdrachten met Arduino, micro:bit e.d. zijn op afstand natuurlijk lastig te ondersteunen.\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus! Zie de pagina van het online evenement voor de link naar de sessie.\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Als je vooraf een opdracht uitzoekt, kijk dan alvast of je hier software voor moet installeren - dat scheelt tijd tijdens de dojo!\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het fijn als een ouder of verzorger je kan begeleiden tijdens de dojo.\nWanneer en waar? Zaterdag 1 mei van 12:30u tot 14:30u.\nVoor deze dojo blijf je THUIS, achter de computer.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"April 25, 2021","permalink":"/dojos/76-online-kies-je-eigen-onderwerp/","title":"#76 online: Kies je eigen onderwerp"},{"categories":null,"contents":"\nWat gaan we doen? Deze maand gaan we met een onderwerp aan de slag dat we nog niet eerder hebben behandeld, namelijk machine learning. Grote kans dat je geen idee hebt wat je je hierbij moet voorstellen, het doel van de dojo is dan ook om daar een beetje verandering in te brengen. Kort gezegd gaat het erom dat we de machine, dus computer gaan proberen iets te learnen, dus leren - maar dan niet met opdrachten als \u0026ldquo;als dit gebeurt doe dan dat\u0026rdquo;. We gaan dit doen in Scratch dus het is handig als je daar al mee kunt werken.\nKijk hier voor de introductie die we bij deze dojo hebben gegeven, hier staan ook een aantal links in om meer over machine learning te weten te komen.\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus! De link voor de Jitsi-sessie vind je voor aanvang van de dojo op de online pagina van dit evenement.\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Op de pagina van dit evenement zullen we nog extra informatie zetten over over hoe je op de workshop kunt voorbereiden.\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het fijn als een ouder of verzorger je kan begeleiden tijdens de dojo.\nWanneer en waar? Zaterdag 3 april van 12:30u tot 14:30u.\nVoor deze dojo blijf je lekker THUIS, achter de computer.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"March 24, 2021","permalink":"/dojos/75-online-machine-learning/","title":"#75 online: Machine Learning"},{"categories":null,"contents":"\nWat gaan we doen? Deze maand gaan we met de talen van het Internet aan de gang: HTML, CSS en JavaScript om meer te leren over hoe je inhoud geeft aan een webpagina, hoe je deze er mooi uit kunt laten zien en hoe je er acties aan kunt toevoegen.\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus! De link voor de Jitsi-sessie vind je voor aanvang van de dojo op de online pagina van dit evenement.\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Op de pagina van dit evenement zullen we nog extra informatie zetten over over hoe je op de workshop kunt voorbereiden.\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Ben je 12 jaar of jonger? Dan is het fijn als een ouder of verzorger je kan begeleiden tijdens de dojo.\nWanneer en waar? Zaterdag 6 maart van 12:30u tot 14:30u.\nVoor deze dojo blijf je lekker THUIS, achter de computer.\nNo show? Heb je je ingeschreven maar kun je toch niet, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of een mentor een vrije zaterdag geven. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"March 3, 2021","permalink":"/dojos/74-online-websites-maken/","title":"#74 online: Websites maken"},{"categories":null,"contents":"\nWat gaan we doen? Net als bij de afgelopen dojo bepaal je zelf waar je mee aan de slag gaat, en helpen wij je daarbij (als je niet kunt kiezen kunnen we je daar ook bij helpen)!\nDus wil je programmeren met Scratch, Python, of L√∂ve, een webpagina maken of bijvoorbeeld een spel in MakeCode Arcade - schrijf je in voor de dojo en we helpen je met je uitdaging of opdracht. Zie bijvoorbeeld de projecten van de Raspberry Pi Foundation of die CoderDojo Nijmegen hier en hier heeft staan. Let wel: opdrachten met Arduino, micro:bit e.d. zijn op afstand natuurlijk lastig te ondersteunen.\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus! Zie de pagina van het online evenement voor de link naar de sessie.\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Als je vooraf een opdracht uitzoekt, kijk dan alvast of je hier software voor moet installeren - dat scheelt tijd tijdens de dojo!\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Het enige wat je nodig hebt om mee te kunnen doen is een laptop met werkende wifi waarop je software mag installeren. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"January 23, 2021","permalink":"/dojos/73-online-kies-je-eigen-onderwerp/","title":"#73 Online: Kies Je Eigen Onderwerp"},{"categories":null,"contents":"\nWat gaan we doen? We konden weer eens niet kiezen en daarom mag jij dat dit keer doen!\nDus wil je programmeren met Scratch, Python, of L√∂ve, een webpagina maken of bijvoorbeeld een spel in MakeCode Arcade - schrijf je in voor de dojo en we helpen je met je uitdaging of opdracht. Zie bijvoorbeeld de projecten van de Raspberry Pi Foundation of die CoderDojo Nijmegen hier en hier heeft staan. Let wel: opdrachten met Arduino, micro:bit e.d. zijn op afstand natuurlijk lastig te ondersteunen.\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus! Zie de pagina van het online evenement voor de link naar de sessie.\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Als je vooraf een opdracht uitzoekt, kijk dan alvast of je hier software voor moet installeren - dat scheelt tijd tijdens de dojo!\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Het enige wat je nodig hebt om mee te kunnen doen is een laptop met werkende wifi waarop je software mag installeren. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"January 5, 2021","permalink":"/dojos/72-online-kies-je-eigen-onderwerp/","title":"#72 Online: Kies Je Eigen Onderwerp"},{"categories":null,"contents":"\nWat gaan we doen? We sluiten het jaar muzikaal af: de laatste dojo van het jaar gaan we aan de slag met Sonic Pi. De code die je in dit programma schrijft, knalt vervolgens uit je luidsprekers!\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus!\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Op de pagina van dit evenement zullen we nog extra informatie zetten over hoe je op de workshop kunt voorbereiden.\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Het enige wat je nodig hebt om mee te kunnen doen is een laptop met werkende wifi waarop je software mag installeren. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"December 15, 2020","permalink":"/dojos/71-online-muziek-maken-met-sonic-pi/","title":"#71 Online: Muziek Maken Met Sonic Pi"},{"categories":null,"contents":"We gaan programmeren met PHP.\nIntroductie De meestgebruikte programmeertaal voor websites is PHP. Het is een heel handige taal waarmee je een eigen slimme website kunt bouwen.\nJe gaat nu leren hoe PHP werkt, en dat doe je door een online vriendenboek te maken. Je leert informatie op te slaan, hoe je uitrekend hoeveel dagen oud je vrienden zijn, en hoe je een plaatje maakt met hun lievelingskleur.\nBenodigdheden Als je websites wil bouwen met PHP, heb je een plek nodig waar je software kunt schrijven. We gebruiken nu CodeAnywhere. Daar kun je oefenen met PHP, en zie je ook meteen hoe het resultaat eruitziet.\nAls je je niet eerder hebt aangemeld, ga dan naar https://codeanywhere.com/signup. Vul je mailadres in, een wachtwoord, kruis het hokje aan, en klik op \u0026lsquo;register\u0026rsquo;. Open het mailtje dat CodeAnywhere je gestuurd heeft om op de link te klikken. Ga door naar de editor: https://codeanywhere.com/editor.\nIn het scherm dat je daar ziet, vul je eerst je naam in. Bij \u0026lsquo;Search stack\u0026rsquo; vul je PHP7 in, en dan klik je op PHP 7 in de lijst daaronder. Klik onderaan op \u0026lsquo;create\u0026rsquo; en wacht af.\nStappen Je eerste webpagina Als het goed is, zie je nu een omgeving waarin je kunt beginnen aan het maken van je eigen website.\nMaak de eerste pagina aan door in het menu bovenaan te klikken op File, en dan \u0026lsquo;New File\u0026rsquo;. Nu kun je in het grote zwarte vlak in het midden beginnen met je eerste webpagina.\nEen webpagina ziet er in het begin altijd zo uit als hieronder. Kopi√´er en plak dit voorbeeld in het zwarte vlak:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welkom\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; In het blokje \u0026lsquo;head\u0026rsquo; staat informatie over je site, zoals de titel. In het blok daaronder, de body, staat alles dat te zien is op de pagina, zoals de kop, tekst en plaatjes.\nDeze indeling met \u0026lt;\u0026gt;-tekens noemen we HTML. Dat is de taal waarmee je opgeeft wat waar op de pagina komt te staan en hoe het eruit ziet.\n\u0026lt;h1\u0026gt; is bijvoorbeeld een HTML-code waarmee je opgeeft dat het een dikgedrukte kop bovenaan de tekst is.\nBewaar je pagina door in het File-menu op \u0026lsquo;Save\u0026rsquo; te klikken. Klik in het venster dat je dan ziet op \u0026lsquo;file name\u0026rsquo; en vul daar in: index.php Klik daaronder op je naam en dan onderaan het venster op \u0026lsquo;Save\u0026rsquo;.\nNu kun je je webpagina bekijken. Klik op de \u0026lsquo;play\u0026rsquo;-knop bovenaan:\nPHP mee laten doen Je website is nu nog heel eenvoudig - en niet zo slim. Hij laat alleen zien wat jij hebt ingetypt.\nJe kunt je webpagina er ook steeds anders uit laten zien, door PHP te gebruiken. De programmacodes van PHP kun je gewoon tussen de HTML-code zetten.\nVoeg deze regel toe aan je webpagina, direct onder de regel met :\n\u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hallo wereld\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt; Zo dus:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welkom\u0026lt;/h1\u0026gt; \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hallo wereld\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Je laat weten waar de PHP-code begint met \u003c?php en sluit het blokje weer af met ?\u003e. is HTML en geeft aan waar een nieuwe alinea begint. Zoals de meeste codes in HTML sluit je die ook weer af, met . En klik weer op \u0026lsquo;play\u0026rsquo;.\nHet enige dat je PHP nu laat doen, is iets laten zien in de browser (het programma waarmee je de website bekijkt). Gelukkig kun je met PHP nog veel slimmere dingen maken, en dat gaan we nu doen.\nWebsites slimmer maken E√©n van de manieren waarop je een webpagina wat slimmer kunt maken, is door PHP een beetje te laten meedenken.\nJe kunt bijvoorbeeld steeds iets anders laten zien op basis van het adres (de url) dat een bezoeker intypt om bij jouw webpagina te komen.\nVerander de PHP-regel uit het vorige voorbeeld zodat dit er komt te staan:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Mijn website\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;?php echo \u0026#39;Hallo \u0026#39; . $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#39;!\u0026#39;; ?\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Let erop dat je ook de -codes uit het vorige voorbeeld weghaalt. Let ook op dat de H1-kop pas afsluit n√° de PHP-code. De PHP code moet dus tussen en staan.\nPHP zegt nu met het commando echo \u0026lsquo;Hallo\u0026rsquo; tegen een naam die in het webadres van je pagina wordt genoemd. We laten dat zo zien.\nSla je pagina op (via File en Save) en druk weer op \u0026lsquo;play\u0026rsquo;.\nJe ziet nu dat de kop van de pagina is veranderd in \u0026lsquo;Hallo !\u0026rsquo;. Meer niet, want we hebben nog geen naam genoemd in het webadres.\nTik in de adresbalk achter het adres van je site ?naam= en dan je naam. Het zou er ongeveer zo uit moeten zien:\n\u0026lt;sitenaam\u0026gt;/?naam=Steven of zo:\n\u0026lt;sitenaam\u0026gt;/index.php?naam=Steven Druk op enter om de pagina opnieuw te laden. Probeer het daarna nog een paar keer met een andere naam in het adres.\nFormulieren Wat je nu zou kunnen doen, is een persoonlijke pagina maken voor elk van je vrienden en familieleden. Door een formulier op die pagina te zetten, kunnen zij meer informatie over zichzelf invullen. Zo maak je je eigen online vriendenboek.\nMaak dit formulier:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;?php echo \u0026#39;Hallo \u0026#39; . $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#39;!\u0026#39;; ?\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;resultaten.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt; Je voornaam: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;naam\u0026#34; value=\u0026#34;\u0026lt;?php echo $_REQUEST[\u0026#34;naam\u0026#34;]; ?\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Hoe oud ben je? \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;leeftijd\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Opsturen\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Vul hier je eigen naam in. [bij de titel]\n[als we de naam al weten, dan vult PHP die hier alvast in]\nVoeg zelf nog twee vragen toe voor het vriendenboek: hoe lang ze zijn (in centimeters) en nog iets, zoals bijvoorbeeld wat hun favoriete film is. Let erop dat je elk input-veld een unieke \u0026rsquo;name\u0026rsquo; geeft, dus bijvoorbeeld \u0026rsquo;name=\u0026ldquo;lengte\u0026rdquo;\u0026rsquo;.\nResultaten van het formulier In de code kun je zien dat het formulier de ingevulde informatie doorgeeft aan een andere pagina die resultaten.php heet. Die pagina gaan we nu aanmaken.\nGa bij CodeAnywhere naar File en klik op \u0026lsquo;New file\u0026rsquo;.\nMaak een pagina die ongeveer lijkt op die hieronder. Denk eraan dat je het antwoord op je zelfbedachte vraag ook nog moet opvangen.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Resultaten\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Hoi \u0026lt;?=$_REQUEST[\u0026#34;naam\u0026#34;]?\u0026gt;, je bent dus \u0026lt;?=$_REQUEST[\u0026#34;leeftijd\u0026#34;]?\u0026gt; jaar oud en \u0026lt;?=$_REQUEST[\u0026#34;lengte\u0026#34;]?\u0026gt; centimeter lang.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [dit is een iets andere manier om PHP even snel iets in te laten vullen]\nSla je nieuwe pagina op (File, en dan Save) en vul bij \u0026lsquo;file name\u0026rsquo; in resultaten.php Klik daaronder op je naam en klik onderaan op Save. Klik weer op \u0026lsquo;play\u0026rsquo;. Rekenen met PHP De informatie die iemand invult, wordt door PHP opgeslagen in variabelen. Variabel betekent dat iets steeds anders kan zijn. In dit geval kan de variabele \u0026rsquo;leeftijd\u0026rsquo; 4 zijn of 12, maar ook 125 of zelfs een woord zoals \u0026lsquo;slagroomtaart\u0026rsquo;.\nJe kunt ook rekenen met die variabelen.\nDus stel dat iemand heeft ingevuld dat ze 12 is, dan kunnen we uitrekenen wat haar geboortejaar is.\nVoeg deze regels toe aan resultaten.php:\n\u0026lt;?php $leeftijd = $_REQUEST[\u0026#34;leeftijd\u0026#34;]; $jaar = 2018; echo \u0026#34;\u0026lt;p\u0026gt;Dat betekent dat je geboren bent in \u0026#34;; echo $jaar - $leeftijd; echo \u0026#34;.\u0026lt;/p\u0026gt;\u0026#34;; ?\u0026gt; En bekijken het resultaat door deze pagina op te slaan en je eerste pagina weer te starten.\nVoeg nu zelf de code toe om met PHP te laten zien hoeveel centimeter deze vriend of vriendin langer of korter is dan jij bent. Informatie bewaren: cookies Informatie verzamelen met formuleren en die gegevens opslaan in variabelen is leuk, maar het probleem is dat die informatie weg is als je de browser sluit of naar een andere website gaat. Je bezoeker zal dus elke keer dat hij of zij terugkomt opnieuw het formulier moeten invullen.\nWe kunnen dat voorkomen door de informatie op te slaan in cookies (het Engelse woord voor koekjes).\nZet deze code bovenaan in resultaten.php:\n\u0026lt;?php $_COOKIE[\u0026#39;bezoek\u0026#39;]++; setcookie(\u0026#39;bezoek\u0026#39;, $_COOKIE[\u0026#39;bezoek\u0026#39;]); ?\u0026gt; Het werkt alleen als je deze code v√≥√≥r zet, dus dat er niks voor de code naar de browser wordt gestuurd om te laten zien. Zet nu deze regel onderaan de pagina, net boven : \u0026lt;small\u0026gt; Je hebt deze pagina nu \u0026lt;?=$_COOKIE[\u0026#39;bezoek\u0026#39;]?\u0026gt; keer bekeken. \u0026lt;/small\u0026gt; [de -code maakt de tekst iets kleiner dan de rest]\nVernieuw de pagina een paar keer en je zult zien dat de informatie uit de cookie steeds opnieuw wordt bijgewerkt en onthouden.\nZoals het er nu staat, wordt de cookie ook weer weggegooid als de bezoeker de browser afsluit. Als je wil dat hij of zij de informatie nog wat langer zal kunnen zien, dan moet je de cookie zo opslaan: setcookie(\u0026#39;bezoek\u0026#39;, $_COOKIE[\u0026#39;bezoek\u0026#39;], time() + 600000); Op die manier blijft de informatie bewaard tot 600.000 seconden na nu, oftewel een week.\nInformatie bewaren: tekstbestandjes Als we echt een vriendenboek willen maken, dan moet de site informatie kunnen opslaan, zodat jij de informatie van je vrienden ook kunt lezen.\nProgrammeurs die websites bouwen, gebruiken meestal een database om informatie te bewaren, maar je kunt daar ook een simpel tekstbestandje voor gebruiken.\nDat werkt als volgt. In resultaten.php, onder de regel met setcookie, zetten we de antwoorden uit het formulier achter elkaar en zetten we die in een tekstbestandje:\n$tekstbestandje = \u0026#39;/tmp/vrienden.txt\u0026#39;; $antwoorden = $_REQUEST[\u0026#34;naam\u0026#34;] . \u0026#34;;\u0026#34; . $_REQUEST[\u0026#34;leeftijd\u0026#34;] . \u0026#34;;\u0026#34; . $_REQUEST[\u0026#34;lengte\u0026#34;] . \u0026#34;\\n\u0026#34;; file_put_contents($tekstbestandje, $antwoorden, FILE_APPEND); [Met de punt (.) plakken we in PHP variabelen en tekst aan elkaar. De \\n op het eind zorgt ervoor dat er na deze rij een nieuwe regel komt.]\n[FILE_APPEND zorgt ervoor dat we steeds een nieuwe regel toevoegen aan het tekstbestandje, in plaats van dat de antwoorden het enige zijn dat erin komt te staan]\nVoeg je eigen variabelen toe aan $antwoorden (die van de extra vragen die je in het formulier hebt gezet). Zorg er wel voor dat er steeds weer een puntkomma tussen komt te staan, want zo houden we de variabelen uit elkaar.\nTekstbestand lezen Nu gaan we een pagina maken waar je ziet wie jouw vragenlijst hebben ingevuld.\nGa bij CodeAnywhere naar File en klik op \u0026lsquo;New file\u0026rsquo;. Zet deze code erin om het tekstbestand te lezen en te laten zien wat erin staat:\n\u0026lt;html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Vriendenboek van Jaap\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Vrienden\u0026lt;/h1\u0026gt; \u0026lt;?php $tekstbestand = fopen(\u0026#34;/tmp/vrienden.txt\u0026#34;, \u0026#34;r\u0026#34;); while( ! feof($tekstbestand) ) { $vriend = explode(\u0026#34;;\u0026#34;, fgets($tekstbestand)); echo $vriend[0] . \u0026#34; is \u0026#34; . $vriend[1] . \u0026#34; jaar en $vriend[2] cm lang.\u0026lt;br\u0026gt;\u0026#34;; } fclose($tekstbestand); ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; [Het uitroepteken betekent \u0026rsquo;niet\u0026rsquo;, feof betekent \u0026lsquo;het eind van het bestand\u0026rsquo; en fgets betekent \u0026lsquo;haal een nieuwe regel van het bestand op\u0026rsquo;. Hier staat dus: laat een nieuwe regel zien zolang we nog niet onderaan het tekstbestand zijn.]\n[Met \u0026rsquo;explode\u0026rsquo; hakken we de regel in stukjes. Waar een puntkomma staat begint een nieuwe variabele. $vriend wordt zo een lijst en dat noemen we in PHP een array. De lijst is genummerd en begint bij 0, en daarom vinden we de naam met $vriend[0]. ]\nSla je nieuwe pagina op (File, en dan Save) en vul bij \u0026lsquo;file name\u0026rsquo; in vrienden.php Klik daaronder op je naam en klik onderaan op Save. Klik weer op \u0026lsquo;play\u0026rsquo;.\nGa naar je nieuwste pagina door achter het webadres /vrienden.php te zetten en op enter te drukken.\nHet adres zou er ongeveer zo uit moeten zien:\n\u0026lt;sitenaam\u0026gt;/vrienden.php Als je ziet wat je zelf daarstraks hebt ingevuld in het formulier, dan werkt het! Ga terug naar de eerste pagina om het formulier nog een paar keer in te vullen, om alles te testen.\nJaren en dagen Dit deel is nog niet af :(\n[Aantal dagen uitrekenen tot je verjaardag, hoeveel dagen je al leeft, hoeveel Saturnus-jaren je al bent, hoeveel dagen je ouder of jonger bent dan je vriend. \u0026gt; formulier aanpassen zodat we ook de dag van de maand en de maand hebben voor de geboortedatum \u0026gt; Datetime-object maken \u0026gt; link naar info over rekenen met data (zodat we ook leren hoe je documentatie over functies kunt vinden op PHP.org) ] Hyperlinks Dit deel is nog niet af :(\n[unordered list maken met voor elke vriend een aparte link naar een nieuw bestand, waar we alle info laten zien over die vriend op basis van de meegegeven naam-parameter. Op die pagina moeten we dus met while en if bekijken welke regel van het bestand we moeten gebruiken.] Plaatjes maken met PHP Dit deel is nog niet af :(\n[plaatje met lievelingskleur genereren \u0026gt; formulier aanpassen zodat we ook de lievelingskleur weten \u0026gt; To do: een mail sturen met iemands eigen url (zou je ook kunnen doen als iemand jarig is of een nieuwe entry wordt gedaan) mensen in laten loggen met een wachtwoord tekst aanpassen aan of het ochtend of middag is Vervolg Meer informatie:\nhttps://www.phphulp.nl/php/tutorial/overig/php-beginners-handleiding/575/variabelen/1482/ https://www.phphulp.nl/php/tutorials/php-functies/6/ https://www.w3resource.com/php-exercises/php-basic-exercises.php Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"November 18, 2020","permalink":"/instructies/web-development-php/","title":"Web - Development - Php"},{"categories":null,"contents":"\nWat gaan we doen? Deze maand gaan we met de talen van het Internet aan de gang: HTML, CSS en JavaScript om meer te leren over hoe je inhoud geeft aan een webpagina, hoe je deze er mooi uit kunt laten zien en hoe je er acties aan kunt toevoegen.\nWe gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus!\nVoorbereiding Je hebt een computer met een webbrowser nodig, bij voorkeur Google Chrome. Op de pagina van dit evenement zullen we nog extra informatie zetten over over hoe je op de workshop kunt voorbereiden.\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Het enige wat je nodig hebt om mee te kunnen doen is een laptop met werkende wifi waarop je software mag installeren. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"October 27, 2020","permalink":"/dojos/70-online-web-development/","title":"#70 Online: Web Development"},{"categories":null,"contents":"Er zijn een paar verschillende talen die samen voor een belangrijk deel bepalen wat er op websites staat (HTML), hoe ze eruit zien (CSS) en hoe ze werken (JavaScript).\nIntroductie Deze instructies leggen eerst de basisonderdelen van HTML uit, en gaan daarna in op CSS en JavaScript. Afhankelijk je ervaring met deze talen kun je het best bij het begin starten, of ervoor kiezen dit over te slaan. De instructies bestaan uit een deel uitleg met tussendoor opdrachten om te oefenen met alle onderdelen.\nBenodigdheden Voor deze instructies gebruiken we Visual Studio Code (VS Code) om de code te schrijven, en om het resultaat te bekijken. Download en installeer eerst VS Code: Download Visual Studio Code\nGa nu naar het Extensions menu. Zoek naar de extensie HTML Preview. Installeer de extensie en herstart VS Code. Om een html-pagina te laten zien in VS Code moet je op het preview icoon klikken, dit bevindt zich rechtsboven in het scherm (let op: het is alleen zichtbaar als je een bestand van het soort .html open hebt, niet bij bijvoorbeeld een .txt bestand):\nJe bent nu klaar om te beginnen met de instructies!\nOnderdelen van een HTML-pagina (basis) Structuur van een pagina Websites worden geschreven in de taal van het internet: HTML. Er zijn veel verschillende \u0026ldquo;woorden\u0026rdquo;, of \u0026ldquo;bouwblokken\u0026rdquo;, in HTML. Een aantal van de meest gebruikte leer je hier kennen.\nEen HTML-pagina heeft een paar standaard onderdelen:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Dit is een kop\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Dit is een alinea.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML onderdelen worden aangegeven met tags: de naam van het onderdeel tussen \u0026lt;\u0026gt; haakjes. De meeste onderdelen hebben een start en een eind tag. De eind tag heeft een forward slash dus / voor de naam, bijvoorbeeld \u0026lt;/html\u0026gt;. Tags worden altijd geschreven met kleine letters. Opdracht Kopieer en plak de basisonderdelen in een nieuw bestand en sla dit op als html-bestand (bijvoorbeeld ninja.html). Let op: pas nadat je het bestand hebt opgeslagen krijgt de tekst ook verschillende kleuren. Als je deze kleuren niet ziet kan het zijn dat je het bestand als tekst, dus eindigend op .txt hebt opgeslagen. Zet nu ook de preview aan. Het resultaat zou er ongeveer zo uit moeten zien:\nDit is een kop Dit is een alinea.\nDe standaard onderdelen \u0026lt;html\u0026gt;: dit is het hoofdonderdeel van een pagina. Alle andere onderdelen komen binnen de \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;head\u0026gt;: binnen dit onderdeel wordt informatie over de pagina gezet, bijvoorbeeld de titel. \u0026lt;body\u0026gt;: binnen dit onderdeel staat alle tekst die zichtbaar is op de pagina, in het voorbeeld een kop \u0026lt;h1\u0026gt; en een alinea \u0026lt;p\u0026gt;. Opdracht Voeg eens een alinea met als tekst je naam in de \u0026lt;body\u0026gt; van de pagina toe. Zie je je naam verschijnen?\nKoppen Om verschillende niveau\u0026rsquo;s aan te geven op een pagina kun je koppen gebruiken. Hiervoor zijn de \u0026lt;h1\u0026gt;, \u0026lt;h2\u0026gt;, \u0026lt;h3\u0026gt; (enzovoort) tags. Met deze tags kun je je pagina een duidelijke indeling geven, zoals je kunt zien in het voorbeeld hierboven.\nOpdracht Tot hoe ver gaan de niveau\u0026rsquo;s eigenlijk? Bestaat \u0026lt;h20\u0026gt;?\nOpdracht Maak een pagina die er zo uitziet:\nHeelal Melkwegstelsel Zonnestelsel Aarde De stijl van tekst Je kunt op een aantal manieren tekst extra benadrukken: door woorden dik te maken, of schuin. Hiervoor kun je bijvoorbeeld de tags \u0026lt;b\u0026gt; (voor dik) en \u0026lt;i\u0026gt; (voor schuin) gebruiken. Een aantal andere tags om extra effect aan je tekst te geven zijn \u0026lt;mark\u0026gt; en \u0026lt;del\u0026gt;. De HTML-code\nDit is \u0026lt;b\u0026gt;dik\u0026lt;/b\u0026gt; wordt dus\nDit is dik Opdracht Gebruik de onderdelen die hierboven genoemd zijn eens uit en maak deze zin na (zet deze bijvoorbeeld onder de kop Aarde):\nDe dikke gele bij vloog schuin over mijn kop hoofd. Links Een superbelangrijk onderdeel van webpagina\u0026rsquo;s zijn natuurlijk links die verwijzen naar andere pagina\u0026rsquo;s, op dezelfde site of op een andere. Denk maar eens aan zoekmachines! Voor het maken van een link gebruik je de \u0026lt;a\u0026gt; tag. Het adres van de link, dus waar deze naar verwijst, voeg je toe door het attribuut href in de tag te zetten met als waarde het adres, op deze manier:\n\u0026lt;a href=\u0026#34;https://scratch.mit.edu\u0026#34;\u0026gt;Klik hier!\u0026lt;/a\u0026gt; Opdracht Probeer op deze manier maar eens een link naar je favoriete website te maken. Let op: vergeet niet de aanhalingstekens om het adres van de website.\nZie je de link niet? Dat komt omdat je nog niets hebt toegevoegd om op te klikken! Dit komt tussen de start- en eindtag en mag tekst zijn, maar ook bijvoorbeeld een afbeelding.\nOpdracht Maak op de pagina een link naar je favoriete website met de tekst \u0026ldquo;Mijn favoriete website!\u0026rdquo; (let op: de tekst is dik gedrukt, hoe moest dat ook weer?). Werkt de link? Tip: zet in de link https:// voor de naam van de website.\nPlaatjes Met alleen maar tekst zouden veel websites er maar saai uit zien. Plaatjes kun je toevoegen aan je pagina met de \u0026lt;img\u0026gt; tag. Ook hier heb je weer een attribuut nodig, dat heet src (van source, Engels voor bron):\n\u0026lt;img src=\u0026#34;naam-van-het-plaatje.png\u0026#34;\u0026gt; Opdracht: Pas de link van de vorige opdracht zo aan dat je het CoderDojo logo hieronder gebruikt in plaats van de tekst die er staat. Download Hiervoor het plaatje en sla het op in de map waar ook je html-pagina staat. Werkt de link nu ook weer? Let op: je moet de hele naam van het plaatje gebruiken, in dit geval is het een png-bestand.\nStijl toevoegen met CSS (basis) Zonder stijl heeft tekst op een webpagina een standaardkleur (zwarte letters op een witte achtergrond), standaardgrootte en standaardlettertype. Je kunt eindeloos vari√´ren met stijl, en er zijn verschillende manieren om stijl toe te voegen aan je HTML.\nDe opdrachten in deze instructie beginnen met deze HTML-code:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; Dit is de best gestijlde regel HTML ooit! \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Hoewel, misschien is deze nog wel mooier... \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dit zou er in de preview zo uit moeten zien:\nDit is de best gestijlde regel HTML ooit! Hoewel, misschien is deze nog wel mooier... Stijl toevoegen De makkelijkste manier om stijl toe te voegen aan je HTML is door een style attribuut toe te voegen aan een HTML-element, bijvoorbeeld:\n\u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;Wat zou de kleur van deze tekst zijn?\u0026lt;/p\u0026gt; In dit voorbeeld is color de eigenschap die je wilt instellen, namelijk de kleur van de tekst. De waarde die je de tekst geeft is hier red, dus rood.\nSpelen met kleur De kleur van tekst bepaal je met de eigenschap color: \u0026lt;p style=\u0026quot;color:green\u0026quot;\u0026gt;. Kleuren instellen kan op verschillende manieren, bekijk hiervoor het onderdeel :ref:html-kleuren.\nOpdracht Maak de tekst van de eerste alinea groen, en die van de tweede paars:\nDit is de best gestijlde regel HTML ooit!\nHoewel, misschien is deze nog wel mooier...\nJe kunt niet alleen de kleur van de tekst zelf, maar ook de achtergrond veranderen, dit doe je met de eigenschap background-color: \u0026lt;p style=\u0026quot;background-color:....\u0026quot;\u0026gt;.\nOpdracht Maak de tekst van de eerste alinea rood met een zwarte achtergrond, en die van de wit met een oranje achtergrond:\nDit is de best gestijlde regel HTML ooit!\nHoewel, misschien is deze nog wel mooier...\nTekstgrootte aanpassen E√©n manier om letters van verschillende grootte te maken is door :ref:koppen te gebruiken. Dat is niet altijd handig (waarom is nu niet belangrijk) en het kan ook met de eigenschap font-size. Een voorbeeld:\n\u0026lt;p style=\u0026#34;font-size:25px\u0026#34;\u0026gt;Groot!\u0026lt;/p\u0026gt; geeft dit resultaat\nGroot!\nIn dit voorbeeld is px gebruikt om aan te geven hoe groot de tekst moet zijn, dit is de grootte in pixels op het scherm. Je kunt ook procenten gebruiken, waarbij 100% de \u0026ldquo;standaard\u0026rdquo; grootte is: \u0026lt;p style=\u0026quot;font-size:100%\u0026quot;\u0026gt;.\nOpdracht Maak de eerste zin van je pagina zo groot dat ie nog net op √©√©n regel past, en de tweede zo klein dat je \u0026rsquo;m nog n√©t kunt lezen.\nVerschillende soorten letters gebruiken Naast de kleur en de grootte kun je ook nog het soort letters veranderen. Dit doe je met de eigenschap font-family: \u0026lt;style=\u0026quot;font-family:naam,backup-naam\u0026quot;\u0026gt;\nJe ziet dat er naam en backup-naam als waarde staat ingevuld. De soort letter backup-naam is niet verplicht, maar wordt gebruikt als de computer de soort letter naam niet kent. Een voorbeeld:\n\u0026lt;p style=\u0026#34;font-family:broadway,serif\u0026#34;\u0026gt;Broadway is niet zo goed te lezen.\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-family:verdana,sans-serif\u0026#34;\u0026gt;Verdana een stuk beter.\u0026lt;/p\u0026gt; geeft dit resultaat\nBroadway is niet zo goed te lezen.\nVerdana een stuk beter.\nStijlen combineren Je kun meer dan √©√©n eigenschap tegelijk instellen door ze met een punt-komma achter elkaar te zetten, bijvoorbeeld: \u0026lt;p style=\u0026quot;color:red;font-size:20px\u0026quot;\u0026gt;\nOpdracht Combineer nu in de twee zinnen verschillende kleuren, lettergroottes en soorten letters. Leef je uit!\nToegankelijkheid Je hebt nu gezien dat je tekst op je webpagina er op heel veel verschillende manieren kunt laten uitzien. Dat het k√°n betekent natuurlijk nog niet dat het ook m√≥√©t! Om te zorgen dat websites ook voor mensen die bijvoorbeeld minder goed zien te gebruiken zijn is het belangrijk (en voor sommige websites verplicht!) om bijvoorbeeld\nde letters groot genoeg te maken de kleur van de letters en die van de achtergrond verschillend genoeg te maken genoeg ruimte tussen regels tekst te laten. Actie toevoegen met JavaScript (basis) De HTML die je net hebt geleerd is statisch. Om hier acties aan toe te voegen, zoals het klikken van een knop gebruiken we JavaScript (JS). Net zoals HTML kent ook JS veel verschillende \u0026ldquo;woorden\u0026rdquo;. Hier behandelen we er een aantal.\nToevoegen aan een HTML bestand JS wordt voor HTML bestanden geschreven in een speciaal blok:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; JavaScript code hier! \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dit ziet er als volgt uit met code (De code wordt verder toegelicht):\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; const telOp = function(getal1, getal2) { return getal1+getal2; } const resultaat = telOp(1,2); console.log(resultaat); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Functies Een functie in JS ziet er als volgt uit:\nconst telOp = function(getal1, getal2) { return getal1+getal2; } Hierbij zie je dat function aangeeft dat het een \u0026lsquo;functie\u0026rsquo; is. Vervolgens geven we de parameters op. Bij ons zijn dat getal1 en getal2. Als laatst gebruiken we deze twee variabelen om een optelling te doen. We geven dit getal terug door return te gebruiken.\nAls we dit stukje code als volgt aanroepen:\nconst resultaat = telOp(1,2); console.log(resultaat) Dan zien we dat er 3 wordt geprint! We slaan hierbij het resultaat op in resultaat en printen die vervolgens met console.log(). Om nu de output te zien van de console.log() functie moeten we de console openen. Je kunt dit doen op verschillende manieren:\nWindows:\nF12 Rechtermuisknop + inspecteer Control+Shift+J MacOs:\nCommand+Option+J Variabelen Variabelen in JS gebruiken net als andere talen een speciale syntax. In JS kennen we var, const en let. Een goede tip om problemen tegen te gaan is om alleen const en let te gebruiken.\nconst gebruiken we als een variabelen niet meer veranderd, en let als we de variabelen later nog aan willen passen.\nEen variabele resultaat maken doen we als volgt:\nlet resultaat = 6; //Zo const resultaatConst = 6; //Of zo In variabelen kunnen we data opslaan, dat is heel handig!\nVoorbeeld 1: Knop Bij een knop gaan we HTML en JS combineren!\nOpdracht Zorg allereest dat je een HTML pagina hebt met een knop.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Wat gebeurt er nu als je op de knop klikt?\nOpdracht Om nu interactie toe te voegen aan de knop gaan we JS en html combineren.\nOp de knop kunnen we de volgende HTML toevoegen: onclick=\u0026quot;\u0026quot;. Nu werkt het echter nog niet..! Nu moeten we een JS functie schrijven die de knop aan gaat roepen, weet jij nog waar dit moet staan in het HTML bestand?: const buttonClicked = function() { alert(\u0026#34;Je hebt op de knop geklikt!\u0026#34;); } Als laatste gaan we deze twee elementen aan elkaar koppelen door de onclick=\u0026quot;\u0026quot; aan te passen (Hier moet je wel de JS nog toevoegen!): \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;buttonClicked()\u0026#34;\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Voorbeeld 2: Een element toevoegen op de pagina We kunnen in JS nog veel meer doen dan interactie toevoegen, bijvoorbeeld aan knoppen. Ook kunnen we HTML toevoegen aan de HTML pagina!\nWe hebben hier een aantal functies voor in JS.\nconst element = document.getElementById(\u0026#34;\u0026lt;id\u0026gt;\u0026#34;); element.insertAdjacentHTML(\u0026#34;afterend\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;My text\u0026lt;/p\u0026gt;\u0026#34;); Er zijn nog veel meer mogelijkheden, maar dit is een van de simpelste.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; const voegElementToe = function() { const element = document.getElementById(\u0026#34;mijnDivId\u0026#34;); element.insertAdjacentHTML(\u0026#34;afterend\u0026#34;, \u0026#34;\u0026lt;p\u0026gt;My text\u0026lt;/p\u0026gt;\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button onclick=\u0026#34;voegElementToe()\u0026#34;\u0026gt; Klik op mij! \u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;mijnDivId\u0026#34;\u0026gt; Dit is een div\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Opdracht Kun jij nu met jouw kennis van JS en HTML een element toevoegen als je op een knop klikt?\nVoorbeeld 3: Reageren op berichten van een gebruiker Met de volgende HTML code hebben we een invoer veld waar de gebruiker iets in kan typen:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; #inputId { width: 300px; height: 40px; font-size: xx-large; } .container { display: flex; height: 100vh; justify-content: center; align-items: center; background-color: blue; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; //JavaScript code hier! \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;span\u0026gt; Wat is je naam? \u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;inputId\u0026#34;\u0026gt; \u0026lt;/input\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Als de gebruiker nu iets typt, zie je alleen de tekst staan. Er gebeurt verder nog niet zo veel. Kun jij ervoor zorgen dat de computer terugpraat?\nVoeg een knop toe aan de HTML pagina Als je op de knop klikt, log dan de text die in het input veld staat met console.log. Om de tekst uit het invoer veld te halen kun je gebruik maken van: const input = document.getElementById(\u0026quot;inputId\u0026quot;).value; Kun jij nu de computer Hallo \u0026lt;naam\u0026gt; laten zeggen? Je kan dit doen met de functie alert(), hier moet je nog wel text aan meegeven. Dit is een voorbeeld: alert(\u0026quot;Hoi Kevin!\u0026quot;) Stijl toevoegen met CSS (vervolg) Maak voor de opdrachten in deze instructie een HTML-bestand met deze inhoud:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; /* hier komt je styling! */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Deze pagina gaan we stylen!\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;Dit is een h2 kop\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Dit is ook een h2 kop!\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;Wat zullen we met \u0026lt;span\u0026gt;deze\u0026lt;/span\u0026gt; alinea gaan doen?\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Deze alinea wordt nog mooier dan de vorige.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;De vorige alinea\u0026#39;s zijn \u0026lt;span\u0026gt;jaloers\u0026lt;/span\u0026gt; op mij.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Jaloers op mij zul je bedoelen!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tot nu toe heb je stijl toegevoegd door style=\u0026quot;...\u0026quot; te gebruiken in de HTML-onderdelen. Dat heeft voordelen en nadelen. Het is handig dat je meteen kunt zien hoe de inhoud van je webpagina eruit komt te zien. Minder handig is dat je aan ieder stukje HTML op deze manier een stijl moet toevoegen. Dat is √©n veel werk, √©n wordt al snel onoverzichtelijk als je veel stijlen hebt.\nHet is daarom gebruikelijk bij webpagina\u0026rsquo;s om de inhoud en stijl op verschillende plekken neer te zetten. Een manier om dit te doen is binnen het \u0026lt;style\u0026gt; onderdeel. De code binnen het \u0026lt;style\u0026gt; onderdeel ziet er wat anders uit dan je tot nu toe gezien hebt. Om tekst rood te maken gebruikte je\n\u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;Dit stukje tekst is rood\u0026lt;/p\u0026gt; Binnen \u0026lt;style\u0026gt; moet je deze code schrijven, een soort regel voor hoe de HTML zich moet gedragen:\np { color: red; } Opdracht Wat denk je dat er gebeurt als je dit stukje code in het \u0026lt;style\u0026gt; onderdeel zet? Probeer het eens. Had je gelijk?\nStijl toevoegen aan sommige, maar niet alle elementen Als je de opdracht van net hebt uitgevoerd, heb je gezien dat alle \u0026lt;p\u0026gt; onderdelen, dus alle alinea\u0026rsquo;s, rode tekst hebben. Dit is dus wat deze code doet:\nde eigenschap kleur krijgt de waarde rood voor alle \u0026lt;p\u0026gt; onderdelen Maar stel nou dat je alleen bepaalde alinea\u0026rsquo;s rood wilt maken?\nClass Dat kan bijvoorbeeld door het HTML-onderdeel lid te maken van een zogenaamde class:\n\u0026lt;p class=\u0026#34;naamvandeclass\u0026#34;\u0026gt;Welke kleur is dit?\u0026lt;/p\u0026gt; In de CSS maak je een class door een punt aan het begin te gebruiken:\n.naamvandeclass { color: red; } Opdracht Gebruik een class met de naam \u0026ldquo;rodealinea\u0026rdquo; om de 1e en 4e alinea rood te maken, dus zo:\n\u003c!DOCTYPE html\u003e Deze pagina gaan we stylen! Dit is een h2 kop Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\nDe vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\nID Een andere manier is om een HTML-onderdeel een uniek id te geven:\n\u0026lt;p id=\u0026#34;ikbenuniek\u0026#34;\u0026gt;Welke kleur is dit?\u0026lt;/p\u0026gt; In de CSS verwijs je naar een id door een hashtag aan het begin te gebruiken:\n#ikbenuniek { color: red; } Opdracht Maak de tekst van de eerste h1 kop blauw, en de 1e h2 kop groen (tip: je hebt hiervoor twee id\u0026rsquo;s nodig, \u0026ldquo;ikbenblauw\u0026rdquo; en \u0026ldquo;ikbengroen\u0026rdquo;):\n\u003c!DOCTYPE html\u003e Deze pagina gaan we stylen! Dit is een h2 kop Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\nDe vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\nSamengevat heb je nu gezien dat je stijl kunt geven aan\nalle onderdelen van een bepaalde soort bepaalde onderdelen door ze lid te maken van een class losse onderdelen door ze een (uniek) id te geven Combineren van stijlen Een grote kracht van CSS is dat je stijlen ook kunt combineren. Zo kun je meerdere eigenschappen tegelijk instellen in een CSS regel:\np { color: red; font-weight: bold; } Opdracht Voeg een tweede eigenschap toe aan de \u0026ldquo;rodealinea\u0026rdquo;, bijvoorbeeld background-color of font-family.\nJe kunt een onderdeel ook lid maken van meer dan √©√©n class (in dit voorbeeld heten die \u0026ldquo;rodealinea\u0026rdquo; en \u0026ldquo;box\u0026rdquo;):\n\u0026lt;p class=\u0026#34;rodealinea box\u0026#34; Opdracht Maak een class \u0026ldquo;box\u0026rdquo; die de eigenschap border instelt op 1px solid black, en voeg deze toe aan een van de rode alinea\u0026rsquo;s:\n\u003c!DOCTYPE html\u003e Deze pagina gaan we stylen! Dit is een h2 kop Dit is ook een h2 kop! Wat zullen we met deze alinea gaan doen?\nDeze alinea wordt nog mooier dan de vorige.\nDe vorige alinea's zijn jaloers op mij.\nJaloers op mij zul je bedoelen!\nActie toevoegen met JavaScript (vervolg) Nu je de basis van JS hebt gezien, gaan we wat verder met moeilijker onderdelen.\nEen klok maken We gaan een klok maken op een HTML pagina. Je kan de volgende HTML gebruiken:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style\u0026gt; body { background: linear-gradient(45deg, #1870ed 0, #f18f88 100%); font-family: \u0026#39;Montserrat\u0026#39;, \u0026#39;sans-serif\u0026#39;; min-height: 100vh; display: flex; align-items: center; justify-content: center; } .clock-container { margin-top: 30px; margin-bottom: 30px; background-color: #080808; border-radius: 5px; padding: 60px 20px; box-shadow: 1px 1px 5px rgba(255, 255, 255, .15), 0 15px 90px 30px rgba(0, 0, 0, .25); display: flex; } .clock-col { text-align: center; margin-right: 40px; margin-left: 40px; min-width: 90px; position: relative; } .clock-col:not(:last-child):before, .clock-col:not(:last-child):after { content: \u0026#34;\u0026#34;; background-color: rgba(201, 166, 166, 0.3); height: 5px; width: 5px; border-radius: 50%; display: block; position: absolute; right: -42px; } .clock-col:not(:last-child):before { top: 35%; } .clock-col:not(:last-child):after { top: 50%; } .clock-timer { color: #fff; font-size: 4.2rem; text-transform: uppercase; } .clock-label { color: rgba(255, 255, 255, .35); text-transform: uppercase; font-size: 0.7rem; margin-top: 10px; } @media (max-width: 825px) { .clock-container { flex-direction: column; padding-top: 40px; padding-bottom: 40px; } .clock-col+.clock-col { margin-top: 20px; } .clock-col:before, .clock-col:after { display: none !important; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;clock-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-hours clock-timer\u0026#34; id=\u0026#34;clock-day\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Dag \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-hours clock-timer\u0026#34; id=\u0026#34;clock-hour\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Uren \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-minutes clock-timer\u0026#34; id=\u0026#34;clock-minute\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Minuten \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;clock-col\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;clock-seconds clock-timer\u0026#34; id=\u0026#34;clock-second\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;clock-label\u0026#34;\u0026gt; Seconden \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //Hier moet jij je code gaan schrijven voor de clock! let dagElement = document.getElementById(\u0026#34;clock-day\u0026#34;); let urenElement = document.getElementById(\u0026#34;clock-hour\u0026#34;); let minutenElement = document.getElementById(\u0026#34;clock-minute\u0026#34;); let secondenElement = document.getElementById(\u0026#34;clock-second\u0026#34;); const dagenInText = [\u0026#34;Zo\u0026#34;, \u0026#34;Ma\u0026#34;, \u0026#34;Di\u0026#34;, \u0026#34;Wo\u0026#34;, \u0026#34;Do\u0026#34;, \u0026#34;Vr\u0026#34;, \u0026#34;Za\u0026#34;]; function updateTime() { var today = new Date(); //Dit geeft je een datum terug, //hier kun je de uren, minuten en seconden van halen. //Met getHours() krijg je de uren //Met getMinutes() krijg je de minuten //Met getSeconds() krijg je de seconden //De dag hebben wij voor je gedaan! dagElement.innerText = dagenInText[today.getDay()]; urenElement.innerText = \u0026#34;1\u0026#34;; minutenElement.innerText = \u0026#34;1\u0026#34;; secondenElement.innerText = \u0026#34;1\u0026#34;; } //Dit voert de functie iedere seconde opnieuw uit, //De tijd gaat natuurlijk met 1 seconde per keer vooruit! setInterval(updateTime, 1000); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; De klok werkt nu nog niet.. Kan jij dit oplossen? In het \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; blok moet jij de code gaan aanpassen, daarmee kun je de klok weer aanslingeren ;) !\nHet instellen van kleuren op je webpagina Er zijn een een heel aantal manieren om een kleur in te stellen voor onderdelen van je pagina, bijvoorbeeld\nmet namen_ \u0026lt;p style=\u0026quot;color:red\u0026quot;\u0026gt; met RGB-waarden_ \u0026lt;p style=\u0026quot;color:rgb(255, 0, 0)\u0026quot;\u0026gt; met HEX-waarden_ \u0026lt;p style=\u0026quot;color:#FF0000\u0026quot;\u0026gt; Namen Er zijn 140 kleuren die een eigen naam hebben:\nRGB-waarden RGB staat voor Rood Groen Blauw. Dit is ook de volgorde waarmee je ze instelt in de code. De waarde gaat van 0 (helemaal niks van deze kleur) tot 255 (alles van deze kleur). Een paar voorbeelden:\nRGB code Rood Groen Blauw Kleur (0, 255, 0) 0 255 0 groen (255, 0, 255) 255 0 255 magenta (173, 216, 230) 173 216 230 lichtblauw HEX-waarden HEX is een afkorting voor hexadecimaal, wat een manier van tellen is die vaak wordt gebruikt bij computers. In plaats van de 10 cijfers (0 t/m 9) waar we meestal mee tellen tel je hier met 16 \u0026ldquo;cijfers\u0026rdquo;, namelijk 0 t/m 9 en A t/m F. De HEX code voor een kleur is zes cijfers lang: de linker twee bepalen hoeveel rood er in de kleur zit, de middelste twee hoeveel groen en de rechter twee hoeveel blauw. 00 is de laagste waarde (omgerekend 0), FF is de hoogste waarde (omgerekend 255). De zescijferige code staat in de HTML-code na een #. De kleuren van de RGB-voorbeelden zijn in HEX code\nHEX code Kleur 00FF00 groen FF00FF magenta ADD8E6 lichtblauw Bronvermelding afbeeldingen HTML logo by W3C CSS logo by Rudloff JS logo by Omed Habib SVG_Recognized_color_keyword_names by Monaneko Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"October 22, 2020","permalink":"/instructies/web-development/","title":"Web - Development"},{"categories":null,"contents":"Je gaat met Scratch een \u0026ldquo;space shooter\u0026rdquo; bouwen.\nBenodigdheden Ga naar https://scratch.mit.edu/ en klik op \u0026lsquo;Aan de slag\u0026rsquo;.\nAls je Scratch nog niet eerder hebt uitgeprobeerd, bekijk dan eerst de video onderaan die pagina. Klik daarna op het groene pijltje naast de video om stap-voor-stap te leren hoe Scratch werkt. Als je meer wil leren, klik dan bovenaan op \u0026lsquo;Lessen\u0026rsquo;, of ga hier verder met de handleiding. Inleiding In deze opdracht ga je een \u0026ldquo;space shooter\u0026rdquo; spel bouwen, waarbij je een ruimteschip bestuurt dat meteorieten kapot moet schieten of ontwijken. Het spel is gebaseerd op dit project.\nDit zijn de stappen die je gaat programmeren:\nLaat een ruimteschip bewegen met de pijltjestoetsen Maak een bewegende achtergrond waardoor het lijkt alsof je door de ruimte vliegt Laat meteorieten verschijnen en naar het ruimteschip vliegen Zorg dat het ruimteschip op de meteorieten kan schieten Als je hierna nog zin (en tijd) hebt dan zijn er nog allerlei uitbreidingen mogelijk, denk bijvoorbeeld aan het spel steeds iets moeilijker maken of geluid en andere special effects toevoegen.\nLaat een ruimteschip bewegen met de pijltjestoetsen Eerst moet je een sprite hebben voor je ruimteschip. Je kunt dit natuurlijk zelf ontwerpen, maar ook een bestaande sprite kiezen (bijvoorbeeld het Rocketship). Noem deze sprite ruimteschip.\nZorg er eerst voor dat de sprite niet te groot is ten opzichte van het speelveld. Je kunt dit doen door het blok maak grootte te gebruiken dat je vindt in het menu Uiterlijken.\nSpeel een beetje met het percentage om de goede grootte te vinden. Zorg ook dat het ruimteschip in het midden onderaan begint door het op x = 0 te plaatsen (x loopt van links naar rechts) en y zo in te stellen dat het nog net in beeld is.\nJe programma zou er nu ongeveer zo uit moeten zien:\nwanneer groene vlag wordt aangeklikt maak grootte (25) % ga naar x: (0) y: (-150) De beweging van het ruimteschip kun je op verschillende manieren programmeren. Je kunt bijvoorbeeld iedere keer bij het indrukken van pijltje links de sprite een stukje laten opschuiven. Bij dit spel gaat het iets anders: als je op een pijltjestoets drukt dan geef je het ruimteschip een bepaalde snelheid, die vervolgens weer naar 0 (dus stilstaan) gaat. Op deze manier zal het ruimteschip een mooie vloeiende beweging maken. Neem de volgende stappen:\nMaak een variabele x-snelheid aan (in het menu Variabelen). Zet deze snelheid aan het begin van het spel op 0. Verander de snelheid naar een getal groter dan 0 als pijltje rechts wordt ingedrukt, en kleiner dan 0 voor pijltje links. Verander vervolgens de (x-)positie van het ruimteschip met de waarde van de variabele x-snelheid. Laat de snelheid steeds iets verder afnemen tot deze uiteindelijk weer 0 is. Tip 1: de laatste drie stappen in de lijst hierboven moet je in een herhaal blok zetten.\nTip 2: je kunt de snelheid bijvoorbeeld laten afnemen door er een getal van af te trekken. Een andere manier is om de waarde te vermenigvuldigen met een getal kleiner dan 1.\nKlik om te laten zien hoe je programma er nu ongeveer uit zou moeten zien. wanneer groene vlag wordt aangeklikt maak grootte (25) % ga naar x: (0) y: (-150) maak [snelheid_x] (0) herhaal als \u0026lt;toets [pijltje links v] ingedrukt?\u0026gt; dan maak [snelheid_x] (5) end als \u0026lt;toets [pijltje rechts v] ingedrukt?\u0026gt; dan maak [snelheid_x] (-5) end verander x met: (snelheid_x) maak [snelheid_x] ((snelheid_x) * (0.9)) end Maak een bewegende achtergrond Sla dit plaatje voor de achtergrond van het spel op je computer op:\nMaak door de volgende stappen te volgen een sprite van dit plaatje:\nKlik op het icoon voor een nieuwe sprite (rechtsonder, plaatje van de kat) en kies voor Upload sprite. Upload het ruimte-plaatje. Ga naar het tabblad Uiterlijken (linksboven, rechts naast het Code tabblad). Maak in de editor het plaatje net zo groot als het hele speelveld door het op te rekken. Plaats de ruimte-achtergrond aan het begin van het spel in het midden van het speelveld. Vraag: wat zijn x en y dan?\nKlik om de code te bekijken wanneer groene vlag wordt aangeklikt ga naar x: (0) y: (0) Nu ga je de achtergrond laten bewegen zodat het net is of je schip door de ruimte vliegt. Vraag: als je wil dat je schip vooruit vliegt, welke kant moet de achtergrond dan op gaan?\nNet als bij de snelheid van je ruimteschip moet je hier een variabele maken, nu voor de \u0026ldquo;scroll\u0026rdquo; snelheid van de ruimte. Vervolgens verander je steeds de positie van de achtergrond met de snelheid die je hebt ingesteld. Vraag: moet je nu de x of de y veranderen? En moet x of y steeds groter worden? Of juist kleiner?\nKlik om de code te bekijken wanneer groene vlag wordt aangeklikt ga naar x: (0) y: (0) maak [snelheid_scrollen] (4) herhaal verander y met ((snelheid_scrollen) * (-1)) end Als je nu het programma start, dan zie je dat er twee dingen fout gaan:\nje achtergrond verdwijnt uit beeld en komt niet meer terug er verschijnt een steeds groter wit vlak! Een manier om deze twee problemen op te lossen staat beschreven in deze afbeelding:\nWat je ziet is dat je voor deze manier twee achtergronden gebruikt: de sprite, en een kloon van de sprite. De blauwe pijl (1) geeft aan dat de sprite en kloon allebei naar beneden schuiven. De rode pijl (2) laat zien dat zodra een achtergrond beneden uit beeld is verdwenen, je deze moet verplaatsen naar boven het speelveld. Op deze manier zorg je ervoor dat je geen wit vlak meer zult zien! Je moet nu dus een stuk code schrijven dat als de sprite uit beeld is, deze weer naar boven verplaatst. En je moet deze code niet alleen voor de sprite zelf, maar ook voor de kloon van de sprite schrijven.\nTip 1: dit is best een lastig stuk code, probeer het daarom eerst eens alleen voor de sprite, en daarna ook voor de kloon.\nTip 2: denk even goed na over de waarde die y heeft als de achtergrond boven en onder het speelveld is.\nUiteindelijk is dit de code die zorgt voor een bewegende achtergrond. wanneer groene vlag wordt aangeklikt ga naar x: (0) y: (0) maak een kloon van [mijzelf v] maak [snelheid_scrollen] (4) herhaal als \u0026lt;(y-positie) \u003e (-340)\u0026gt; dan verander y met ((snelheid_scrollen) * (-1)) anders ga naar x: (0) y: (345) end end wanneer ik als kloon start ga naar x: (0) y: (345) maak [snelheid_scrollen] (4) herhaal als \u0026lt;(y-positie) \u003e (-340)\u0026gt; dan verander y met ((snelheid_scrollen) * (-1)) anders ga naar x: (0) y: (345) end end Laat meteorieten verschijnen en naar het ruimteschip vliegen Je hebt nu een ruimteschip dat door de ruimte vliegt en naar links en rechts kan bewegen. De hoogste tijd om de meteorieten te laten verschijnen! Dit ga je doen door steeds een nieuwe kloon van de \u0026ldquo;echte\u0026rdquo; sprite te maken.\nMaak eerst een nieuwe sprite door een plaatje van een meteoriet in Scratch te laden, er zelf een te tekenen of een bestaande sprite te gebruiken (bijvoorbeeld een bal). Noem de sprite meteoriet.\nHet belangrijkste wat deze sprite doet is het elke paar seconden (of zo snel als je wilt) maken van een kloon van zichzelf.\nKlik om de code te bekijken wanneer groene vlag wordt aangeklikt herhaal wacht (4) sec. maak een kloon van (mijzelf v) end Als je de sprite zelf niet ziet, dan komt dat omdat deze achter de bewegende achtergrond zit. Dat geeft niets want alleen de klonen moeten zichtbaar zijn, maar het is wat onhandig als je wil zien wat je code doet. Je kunt hiervoor het blok ga naar laag voorgrond toevoegen.\nOok als je de sprite en klonen wel ziet, gebeurt er nog vrij weinig. Dat komt omdat ze allemaal bovenop elkaar verschijnen. De volgende stap is dan ook om de klonen op allerlei plaatsen te laten verschijnen.\nTip 1: er is een speciaal wanneer ik als kloon start blok waar je deze code onder kunt zetten.\nTip 2: laat de meteorieten ergens bovenin verschijnen (dus zet y bijvoorbeeld op 180).\nTip 3: gebruik voor de x het blok willekeurig getal tussen \u0026hellip;.\nDe code voor een kloon zou er ongeveer zo uit moeten zien wanneer ik als kloon start ga naar laag [voorgrond v] ga naar x: (willekeurig getal tussen (-200) en (200)) y: (180) verschijn Je bent er bijna! De een-na-laatste stap is om de klonen naar beneden te laten bewegen. Je kunt hiervoor weer een variabele voor de beweegsnelheid maken, een herhaal blok waarin je elke keer de plek van de sprite een beetje verandert werkt ook goed.\nEn waarom ben je nu nog niet helemaal klaar? Omdat het slim is je klonen ook weer te laten verdwijnen als ze onderaan het veld zijn aangekomen. Op deze manier blijft het spel soepel lopen.\nDe code voor een kloon ziet er dan zo uit wanneer ik als kloon start ga naar laag [voorgrond v] ga naar x: (willekeurig getal tussen (-200) en (200)) y: (180) verschijn herhaal tot \u0026lt; (y-positie) \u003c (-180)\u0026gt; verander y met (-2) end verwijder deze kloon Schieten op de meteorieten Het is tijd om de meteorieten uit de weg te ruimen. Kies of maak een sprite die de kogel wordt, en noem deze ook kogel. Laat vervolgens een kogel \u0026ldquo;uit\u0026rdquo; het ruimteschip komen (bijvoorbeeld als je op de spatiebalk drukt) en naar het ruimteschip vliegen.\nTip 1: de code voor deze sprite lijkt wat op die voor de meteoriet; ook hier moet je klonen maken en die naar de meteorieten laten bewegen.\nTip 2: het blok ga naar is handig om de startplek van de kogel te bepalen.\nTip 3: als de kogel niets raakt is het wel slim de kloon te verwijderen als deze uit beeld verdwijnt.\nCode om kogels af te schieten wanneer groene vlag wordt aangeklikt verdwijn herhaal als \u0026lt;toets [spatiebalk v] ingedrukt?\u0026gt; dan maak een kloon van (mijzelf v) end end wanneer ik als kloon start verschijn ga naar laag [voorgrond v] ga naar (ruimteschip v) herhaal tot \u0026lt;raak ik (rand v)?\u0026gt; verander y met (10) end verwijder deze kloon Winnen en verliezen Natuurlijk wil je ook punten verdienen wanneer je een meteoriet raakt met je kogels, en bijvoorbeeld weer verliezen wanneer het ruimteschip door een meteoriet geraakt wordt. Maak voor de puntentelling een variabele score aan en zet die op 0 aan het begin van het spel (doe dit bij de code voor het ruimteschip).\nNu moeten we nog een paar stukken code toevoegen, namelijk:\nom op te merken wanneer een een meteoriet door een kogel geraakt wordt om hierna de meteoriet en de kogel te laten verdwijnen om op te merken wanneer een meteoriet het ruimteschip raakt Tip: de meeste code hoort bij klonen van de meteoriet sprite.\nCode voor het raken van een meteoriet met een kogel wanneer ik als kloon start herhaal als \u0026lt; raak ik (kogel v)?\u0026gt; dan verander [score v] met (1) verwijder deze kloon end Code voor het laten verdwijnen van de kogel (deze hoort bij de kogel sprite!) wanneer ik als kloon start wacht tot \u0026lt; raak ik (meteoriet v)?\u0026gt; wacht (0.1) sec. verwijder deze kloon Code voor het raken van het ruimteschip met een meteoriet wanneer ik als kloon start herhaal als \u0026lt; raak ik (ruimteschip v)?\u0026gt; dan maak [score v] (0) verwijder deze kloon end Dit was het, veel speelplezier!\nUitbreidingen Je kunt het spel natuurlijk nog veel mooier, spannender en moeilijker maken. Hier heb je alvast een lijstje met idee√´n als je nog verder wil programmeren:\nzorg dat je minder vaak kogels kunt afschieten laat de meteorieten niet alleen naar beneden komen maar ook echt op je ruimteschip af laat de meteorieten sneller bewegen als je meer punten hebt gehaald voeg geluiden en andere effecten toe Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"October 6, 2020","permalink":"/instructies/scratch-space-shooter/","title":"Scratch - Space shooter"},{"categories":null,"contents":"\nWat gaan we doen? Na twee maanden \u0026ldquo;live\u0026rdquo; deze maand weer een online dojo, dit keer met de ruimte als thema! Je kunt deze dojo aan de slag met opdrachten in Scratch, Python of MakeCode Arcade:\nals je nog geen of weinig programmeerervaring hebt is Scratch de beste keuze als je klaar bent om \u0026ldquo;echte\u0026rdquo; code te schrijven kun je gaan programmeren in Python - doe dan bijvoorbeeld mee aan de Astro Pi challenge en laat jouw eigen geschreven computercode uitvoeren op het ruimtestation ISS! Met MakeCode Arcade kun je \u0026ldquo;retro\u0026rdquo; spelletjes programmeren (vraag maar aan je ouders) op zowel een Scratch-achtige manier als met Python. Voorbereiding Heb je je aangemeld voor Scratch en/of MakeCode Arcade, dan kun je uit deze opdrachten kiezen:\nScratch:\nVerdwaald in de ruimte Space-shooter MakeCode Arcade (in het Engels!)\nga naar Tutorials -\u0026gt; Galga (dit spel is zowel met blokken als met Python te programmeren) ga naar Blocks Games -\u0026gt; Space Destroyer ga naar Game Concepts -\u0026gt; Star Field Heb je je aangemeld voor Python, dan zijn dit de opdrachten voor deze keer:\nAstro-Pi Waar is het ruimtestation? Jitsi We gebruiken voor de dojo het online chatprogramma Jitsi, waardoor de mentoren je gewoon kunnen helpen als je vast komt te zitten bij een opdracht - eigenlijk net als anders dus! Jitsi werkt het best met de webbrowser Google Chrome. Voorafgaand aan de dojo sturen we je meer details.\nSpelregels voor de online dojo Graag willen we vooraf een aantal afspraken met elkaar maken over hoe we online samenwerken.\nDe webcam van de deelnemers blijft uit. De kinderen kunnen de mentoren wel zien. Zet je microfoon is uit als je niet aan het woord bent Deel geen persoonlijke informatie Als je een vraag hebt, stel die dan eerst in de chat. Als je hulp nodig hebt met je code, dan vragen we je je scherm te delen en helpen we je verder. Algemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Het enige wat je nodig hebt om mee te kunnen doen is een laptop met werkende wifi waarop je software mag installeren. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"October 2, 2020","permalink":"/dojos/69-online/","title":"#69 Online: Python, Scratch \u0026 MakeCode"},{"categories":null,"contents":"We gaan werken met programmeeromgeving mBlock.\nIntroductie Met Scratch hebben we al ervaring opgedaan met programmeren met blokjes. Nu gaan we verder en gebruiken dezelfde techniek om met het programma mBlock om mBots en Arduino\u0026rsquo;s te programmeren.\nmBot De mBot is een klein robotje gebaseerd op een Arduino bordje dat je kunt programmeren met het mBlock programma. Het mBot moet je zelf opbouwen met allerlei onderdelen, waaronder sensoren en motoren.\nmBot instructies\nArduino Arduino bordjes zijn er in verschillende varianten, maar zijn allemaal opgebouwd rond een printplaatje met daarop een microprocessor. Daarnaast zijn er diverse aansluitingen aanwezig om het bordje met USB of een netwerkkabel te verbinden met de computer of om stroompjes te schakelen en te meten. De Arduino bordjes kunnen net als de mBotjes geprogrammeerd worden met mBlock.\nArduino instructies\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"August 29, 2020","permalink":"/instructies/mblock/","title":"mBlock"},{"categories":null,"contents":"Micro:Bit is een piepklein computertje met superveel mogelijkheden om te programmeren.\nWat zit er zoal op 25 LEDs die je allemaal los kunt programmeren 2 knoppen een licht- en temperatuursensor bewegingssensoren Zie de micro:bit website voor een volledig overzicht.\nBenodigdheden De micro:bit Een USB kabel Een accu (doosje met batterijen) voor als je de micro:bit los van de computer wilt gebruiken de micro:bit editor De micro:bit verbinden met de computer De micro:bit gedraagt zich als een USB schijf/stick wanneer je deze aan de computer verbindt. Als je Google Chrome gebruikt dan kun je rechtstreeks verbinding maken met de micro:bit om je code er naar toe te schrijven, bij andere browsers moet je het bestand nog zelf kopi√´ren naar de micro:bit.\nMateriaal Steen papier schaar Gebruik de micro:bit als controller in Scratch Stoplicht (voor dit project heb je o.a. een paar LEDS nodig) Maqueen (voor dit project heb je de Maqueen robot nodig) Op de micro:bit website staan ook een groot aantal opdrachten met verschillende moeilijkheidsniveaus, en ook de Raspberry Pi Foundation heeft een paar projecten met de micro:bit gedeeld. Als je Engels als taal kiest zijn er soms nog wat extra uitdagingen die niet in het Nederlands beschikbaar zijn. Let op: sommige opdrachten maken gebruik van functies die alleen de micro:bit versie 2 heeft, zoals een microfoon en speaker. Jouw micro:bit kan wel geluid maken maar dan moet er een luidsprekertje op worden aangesloten.\nprojecten op de micro:bit website projecten op de Raspberry Pi Foundation website Wil je de micro:bit met Python programmeren, er is een online editor voor Python. Deze editor is (nog) niet in het Nederlands vertaald. Op de oude website van micro:bit zijn ook nog wat idee√´n te vinden voor inspiratie.\nHieronder staan een heleboel verschillende opdrachten om uit te proberen. Het materiaal is allemaal in het Nederlands.\nUitdagingen vertaald door Sanneke v.d. Meer om als inspiratie te gebruiken (*let op: de codeblokken zien er iets anders uit omdat deze instructies al wat ouder zijn)\nTruth or Dare Magnetische knop Liefdesmeter Theremin Meteoren Vuurvliegjes Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"August 27, 2020","permalink":"/instructies/microbit/","title":"Micro:Bit"},{"categories":null,"contents":"We gaan aan de slag met Scratch en video sensing.\nJe hebt een computer nodig met een webcam (ingebouwd of los).\nJe kunt in Scratch programma\u0026rsquo;s schrijven die reageren wat er gebeurt op wat de webcam \u0026ldquo;ziet\u0026rdquo;, zoals de kleur van wat \u0026lsquo;ie ziet. Daar zijn allerlei spelletjes mee te verzinnen. Hieronder staan wat bouwblokken en idee√´n die je kunt gebruiken voor je eigen spel.\nVideo sensing Ga naar https://scratch.mit.edu/ en klik op \u0026lsquo;Aan de slag\u0026rsquo;.\nBegin met het aanzetten van de webcam. De blokken die je hiervoor nodig hebt moet je eerst toevoegen door linksonder te klikken op de knop \u0026ldquo;Voeg een uitbreiding toe\u0026rdquo; en daarna \u0026ldquo;Video\u0026rdquo; te kiezen. Scratch zal je nu waarschijnlijk vragen om toestemming om de webcam te gebruiken.\nDoor nu op het blok \u0026ldquo;zet video aan\u0026rdquo; te klikken zal je op de achtergrond van Scratch zien wat de webcam ziet. Het is nog een beetje onduidelijk, als je het blok \u0026ldquo;zet video transparantie\u0026rdquo; instelt op 0 en erop klikt zie je het beter.\nKleur instellen Om ervoor te zorgen dat Scratch reageert op de kleur die de webcam ziet moet je deze eerst instellen. Zet eerst de webcam aan in Scratch Dit doe je door op de kleur van het blok \u0026ldquo;raak ik kleur\u0026rdquo; te klikken en daarna op het icoon in de rode cirkel. Je kunt nu een kleur in het beeld van de webcam aanklikken.\nBouwblokken Sprite beweegt tegen een kleur aan\nDit bouwblok is het makkelijkst te gebruiken als je een losse webcam hebt die je op tafel kunt richten. In dit geval liggen de gekleurde voorwerpen (papiertjes, legoblokjes, M\u0026amp;M\u0026rsquo;s, noem maar op) en beweegt een sprite tegen de voorwerpen aan. Je kunt dan programmeren wat er moet gebeuren als de sprite een kleur raakt: hij verandert van uiterlijk, er klinkt een geluid, je poppetje is \u0026ldquo;af\u0026rdquo;, enzovoorts.\nKleur beweegt tegen een sprite aan\nIn dit geval gaat het er om dat een kleur op een bepaalde plek op het scherm verschijnt en Scratch daarop reageert.\nOm dat voor elkaar te krijgen doe je eigenlijk hetzelfde als in het vorige voorbeeld - bijvoorbeeld \u0026ldquo;als deze sprite kleur rood raakt\u0026rdquo;, maar zit de sprite vast op √©√©n plek, bijvoorbeeld het linker- of rechterdeel van het scherm.\nHet kan voor je spelletje handig zijn om deze sprites te verbergen. Dit kun je doen door eerst op een sprite te klikken en daarna op het blok \u0026ldquo;verberg\u0026rdquo;.\nMogelijke spelletjes Speed color: wie houdt het snelst de goede kleur in beeld\nIn dit spelletje speel je met twee spelers, en heeft elke speler √©√©n helft van het scherm (links en rechts). Tel af en laat dan een kleur zien, de spelers moeten nu de goede kleur papier omhoog houden. Tip: gebruik hiervoor de functie \u0026ldquo;willekeurig getal tussen 1 en \u0026hellip;\u0026rdquo; Extra moeilijk: laat de kleur die spelers omhoog moeten houden zien als woord met de letters in een andere kleur, bijvoorbeeld \u0026ldquo;blauw\u0026rdquo; maar dan met rode letters. Kleurenmuziek\nDit is een spelletje om muziek te maken met kleuren die je in beeld laat zien. Dit kan met een ingebouwde en losse webcam. Als je gekleurde voorwerpen op tafel legt kun je bijvoorbeeld een bewegende \u0026ldquo;streep\u0026rdquo; maken die steeds over het beeld schuift. Gekleurde platformen\nIn dit spel maak je een platform van gekleurde voorwerpen en moet een sprite daar overheen lopen/rennen. Begin met programmeren van de beweging van de sprite met een platform dat je in Sprite hebt getekend. Bepaal dan wat de kleuren moeten doen als je ze raakt (bijvoorbeeld opnieuw beginnen). Vervang dan het getekende platform door voorwerpen die de webcam ziet. Bonus: hieronder vind je een aantal tips om de beweging van de sprite minder schokkerig te maken. Belangrijk: sla je programma\u0026rsquo;s steeds op zodat je geen werk verliest. Je kunt bovenaan in Scratch klikken op \u0026lsquo;Bestand\u0026rsquo; en dan \u0026lsquo;Opslaan op je computer\u0026rsquo;. Je kunt opgeslagen programma\u0026rsquo;s ook weer uploaden via hetzelfde menu.\nPlatform spel Het maken van een vloeiende beweging\nIn Scratch kun je bewegen van links naar rechts, en van boven naar onder. De plek van links naar rechts wordt bepaald door de waarde van x, en die van boven naar onder door y. Deze waarden noem je de co√∂rdinaten.\nDe makkelijkste manier om dit te doen is door een knop aan een verandering in de waarde van x en y te verbinden: Dit kun je ook voor beweging de andere kant op, naar boven en beneden doen. Deze beweging is nogal schokkerig. Je kunt deze beweging op meerdere manieren vloeiender maken. Een manier is de volgende. Als eerste moet je hiervoor de waarde van x niet meteen als getal intypen, maar dit doen via een variabele die de snelheid van de sprite bepaalt (zie het menu \u0026lsquo;variabelen\u0026rsquo;):\nDe volgende stap is om deze stap in een herhaal lus te zetten, daardoor blijft de snelheid veranderen zo lang je de knop ingedrukt houdt:\nWat er nu gebeurt is dat de sprite na het loslaten van de knop net zo snel blijft gaan. Je moet dus instellen dat de snelheid omlaag gaat als je de knop niet indrukt:\nJe zult nu zien dat de snelheid na een tijdje onder de 0 gaat en de sprite dus de andere kant op zal gaan bewegen. O dit te voorkomen moet een je een voorwaarde toevoegen dat de snelheid niet onder de 0 mag komen.\nBeweging naar links kun je op dezelfde manier programmeren, uiteindelijk ziet het er dan zo uit:\nJe kunt de beweging nog verder verbeteren door een maximale snelheid te bepalen en de snelheid alleen te verhogen als die nog niet is bereikt. Je voegt dan een extra voorwaarde toe:\nNatuurlijk hoort springen (en daarna weer vallen) ook bij een platform spel. Een manier om dit voor elkaar te krijgen zie je in het blok hieronder, waarbij Het blok hieronder een paar dingen doet:\nals je een onderdeel van het platform raakt is je snelheid in de y-richting 0 als je op het platform staat en springt gaat je snelheid omhoog als je niet op het platform staat wordt je snelheid y-snelheid steeds hoger (je gaat naar beneden dus die wordt steeds meer negatief). Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"August 27, 2020","permalink":"/instructies/scratch-videosensing/","title":"Scratch - Videosensing"},{"categories":null,"contents":"We gaan met 2D game \u0026ldquo;framework\u0026rdquo; L√∂ve2D een shooter bouwen.\nWe gaan een eenvoudige shooter maken. Deze instructie is een vertaling en bewerking van een tutorial door \u0026gt;_OSMSTUDIOS.\nWat leer je? Tijdens de Dojo\u0026rsquo;s over Scratch hebben jullie kennis gemaakt met variabelen en functies (blokken). Daar gaan we mee verder.\nIn Scratch kun je met drag-and-drop variabelen en functies combineren tot een programma, maar bij de meeste programmeertalen wordt het programma in tekst geschreven. Dat is ook het geval bij L√∂ve. We gaan dus typen.\nOmdat we er geen typecursus van willen maken, zijn een aantal functies, net als bij Scratch, al voor jullie gemaakt. Je hoeft deze dus niet helemaal zelf meer te maken. Je hoeft ze alleen maar te gebruiken. Dit zijn de functies: xRechterRand, yOnderRand, xWillekeurig, tekenVijanden, tekenKogels, maakNieuweVijand, maakNieuweKogel, spelerHeeftVijandGeraakt en kogelHeeftVijandGeraakt.\nAls je deze in de uitleg tegenkomt, hoef je ze dus niet zelf te implementeren!\nBenodigdheden Om deze instructie te kunnen volgen, moet je L√∂ve en een goede editor ge√Ønstalleerd hebben. Verder moet je wat code downloaden om verder op te bouwen, maar dit wordt in stap 0 uitgelegd.\nInstallatie L√∂ve Hopelijk heb je de installatie al voorbereid na het ontvangen van de uitnodiging voor deze Dojo. Als dat zo is, kun je dit hoofdstukje overslaan en doorgaan naar Stap 1.\nWindows L√∂ve is op Windows gemakkelijk te installeren via √©√©n van de installers. Als alternatief kun je kiezen voor √©√©n van de zipbestanden en deze op een gewenste locatie unzippen. Maak het jezelf gemakkelijk door L√∂ve op een eenvoudig te onthouden plek te installeren, bijvoorbeeld in de map\nc:\\love\\ Zie de L√∂ve download pagina voor de installatie bestanden. Als je twijfelt tussen de 32- of 64-bits versie, kun je voor de zekerheid kiezen voor 32-bits versie of gewoon even checken welke versie je hebt.\nMac Download het zip bestand voor Mac en unzip het op de gewenste locatie.\nLinux Voor Ubuntu kun je kiezen voor het toevoegen van de L√∂ve PPA of voor de installatie van √©√©n van de .deb bestanden.\nOnderstaand vind je de instructies voor het gebruiken van de AppImage:\nInstructies voor het gebruiken van de L√∂ve AppImage Download de L√∂ve appimage x86_64. Zet deze bijvoorbeeld in je ~/Downloads directory.\nVoer hier vervolgens de volgende commands op uit (vanuit ~/Downloads). Je .AppImage kan een andere versie/naam hebben dan in het voorbeeld!\nchmod u+x love-11.4-x86_64.AppImage 3. Zorg nu dat je weet waar je `.lua` bestanden staan (zie onderstaande stap 1). In ons voorbeeld is dit in `~/Documents/love2d-shooter-master/src/`. Je voert de code dan op de volgende manier uit: ~/Downloads/love-11.4-x86_64.AppImage ~/Documents/love2d-shooter-master/src/ Let op dat het scherm in eerste instantie zwart is, omdat we nog geen code geschreven hebben.\nMocht het niet lukken om de code op deze manier uit te voeren, vraag dan gerust om hulp!\nTekst editor Als je gaat programmeren is het handig om een editor te installeren met meer mogelijkheden dan \u0026lsquo;kladblok\u0026rsquo;. Sublime Text snapt Lua en dus L√∂ve. Als alternatief kun je kiezen voor Notepad++.\nStappen TIP: de onderstaande stukken code hoef je niet over te typen. Je kunt ze natuurlijk gewoon copy-pasten in je editor.\nStap 0: installatie voorbereidde code Download the code van GitHub: L√∂ve 2D shooter code De zip-file bevat een src/ folder. Kopieer de inhoud daarvan naar c:\\games\\shooter. Om de voorbereidde code uit te voeren, druk je op de Windows knop en typ je cmd. Je krijgt dan een zwart venster. Typ dan cd c:\\games\\shooter om naar de folder te gaan waar je de code hebt neergezet. Typ tenslotte c:\\love\\love.exe .\\ om het programma te starten. Als alles goed gaat, krijg je een zwart venster.\nStap 1: teken het vliegtuig van de speler In deze stap laden we het plaatje van het vliegtuig van de speler en tekenen we het plaatje op het scherm. Open main.lua in je tekst editor en type het volgende:\n-- variabele om het plaatje in op te slaan spelersVliegtuig = nil function love.load(arg) -- laad het plaatje in de variabele spelersVliegtuig = love.graphics.newImage(\u0026#39;plaatjes/spelersVliegtuig.png\u0026#39;) end En vervolgens om op het scherm te tekenen:\nfunction love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(spelersVliegtuig, 100, 100) end Start je programmaatje en zie het resultaat:\nx en y as In de code hebben we bij het aanroepen van functie love.graphics.draw twee keer het getal 100 gebruikt. Dit getal gebruiken we om de positie van het plaatje in het scherm te bepalen. Daarbij is positie (0,0) links bovenin. Bij (100,100) is het plaatje dus 100 stappen naar beneden en 100 naar rechts verschoven ten opzichte van (0,0). Voor de horizontale positie wordt vaak variabele naam x gebruikt en voor de verticale positie y. Een handige manier van opschrijven is (x, y), bijvoorbeeld (50, 30) als x = 50 en y = 30.\nIn Scratch komen x en y waarden voor de plaats van een Sprite ook terug. Hieronder staat Scratch op x = 31 en y = -36\nStap 2: eigenschappen van de speler Het vliegtuig van de speler staat nu nog stil op positie (100,100), maar zal natuurlijk van links naar rechts gaan bewegen als we wat verder zijn. Je zou kunnen zeggen dat de speler een aantal eigenschappen heeft:\nhet plaatje de positie Om die informatie bij elkaar te houden, vervangen we variabele spelersVliegtuig door een nieuwe variabele waarin meerdere eigenschappen opgeslagen kunnen worden. Deze variabele noemen we speler:\n-- variabele om eigenschappen van de speler in op te slaan speler = { x = 200, y = 560, plaatje = nil } function love.load(arg) -- laad het plaatje in eigenschap plaatje van de variabele speler speler.plaatje = love.graphics.newImage(\u0026#39;plaatjes/spelersVliegtuig.png\u0026#39;) end Het tekenen van het plaatje moet ook aangepast worden, zodat we de eigenschappen van de nieuwe variabele speler gebruiken:\nfunction love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) end Start het programma opnieuw op, en je zal zien dat het vliegtuig nu onderin het venster staat. De wijzigingen die je hebt gemaakt zorgen dat we het plaatje later kunnen laten bewegen.\nStap 3: de speler bewegen Je programma toont nu alleen een stilstaand plaatje. Dat is natuurlijk niet erg interessant. In deze stap ga je het plaatje laten bewegen.\nBewegen met pijltjes Om het plaatje horizontaal te laten bewegen, moet de speler.x eigenschap worden aangepast. De waarde van speler.x moet kleiner worden om naar links te bewegen en groter om naar rechts te bewegen. Je kunt dit ook eenvoudig uitproberen door de waarde 200 in de code groter of kleiner te maken en je programma te starten.\nOm het plaatje te laten bewegen terwijl het programma draait, moet het programma gaan reageren op toetsen van je toetsenbord. De pijl naar links zorgt voor een beweging naar links en de pijl naar rechts zorgt voor een beweging naar rechts:\nfunction love.update(dt) -- als pijltje naar links wordt ingedrukt if love.keyboard.isDown(\u0026#39;left\u0026#39;) then -- dan doe een stap naar links speler.x = speler.x - 1 -- als pijltje naar rechts wordt ingedrukt elseif love.keyboard.isDown(\u0026#39;right\u0026#39;) then -- dan doe een stap naar rechts speler.x = speler.x + 1 end end Als je voor het eerst dit soort code leest ziet het bovenstaande voorbeeld er ingewikkeld uit. Maar: vergelijk het eens met het bewegen via pijltjes in Scratch. love.update(dt) wordt steeds opnieuw uitgevoerd en is daarom vergelijkbaar met de herhaal loop in Scratch. if ... then is gelijk aan de als ... dan keuze in Scratch. In Scratch zou dit er ongeveer als volgt hebben uitgezien:\nwanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje links v] ingedrukt?\u0026gt; dan verander x met (-1) end als \u0026lt;toets [pijltje rechts v] ingedrukt?\u0026gt; dan verander x met (1) end end Als je de code hebt ingevoerd (in L√∂ve2D, niet in Scratch üòÄ), kun je het programma starten om uit te proberen of het werkt.\nProbeer ook eens een andere stapgrootte dan 1. Doet dat wat je ervan verwacht? Wat gebeurt er als je er een negatief getal van maakt? Kun je de code aanpassen, zodat je ook naar boven en beneden kunt bewegen (gebruik toetsen up voor naar boven en down voor naar beneden)? Wat gebeurt er als je bijvoorbeeld het pijltje naar rechts lang ingedrukt houdt?\nStoppen bij de rand Om te voorkomen dat het plaatje het venster kan verlaten, moeten we voorkomen dat het verder beweegt als het aan de randen van het venster komt. Aan de linker kant is dat makkelijk: beweeg niet verder als speler.x gelijk is aan 0. In code ziet dat er als volgt uit:\n-- als pijltje naar links ingedrukt if love.keyboard.isDown(\u0026#39;left\u0026#39;) then -- en linker rand is nog niet bereikt if speler.x \u0026gt; 0 then -- dan doe een stap naar links speler.x = speler.x - 1 end Aan de rechter zijde is dat lastiger. Daar hangt de maximale x af van de breedte van het venster. De maximale waarde voor x is gelijk aan de breedte van het venster, of xRechterRand(). Let op: xRechterRand is een van de kant en klare functies!\n-- als pijltje naar rechts ingedrukt elseif love.keyboard.isDown(\u0026#39;right\u0026#39;) then -- en de rechter rand is nog niet bereikt if speler.x \u0026lt; xRechterRand() then -- dan doe een stap naar rechts speler.x = speler.x + 1 end end Pas de code die je eerder bij stap 3 (bewegen met pijltjes) hebt geschreven aan, zodat je stopt bij de rand. Controleer ook of het plaatje nu niet aan de rechterkant verdwijnt. Voor de duidelijkheid hebben we de Scratch code ook aangepast en bijgevoegd:\nwanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje links v] ingedrukt?\u0026gt; dan als \u0026lt;(x-positie) \u003e (0)\u0026gt; dan verander x met (-1) end end als \u0026lt;toets [pijltje rechts v] ingedrukt?\u0026gt; dan als \u0026lt;(x-positie) \u003c (240)\u0026gt; dan verander x met (1) end end end Stap 4: de vijand Het spel draait natuurlijk niet alleen om het heen en weer bewegen van een vliegtuigje. Er zijn ook vijanden. In deze stap gaan we die vijanden maken.\nWe beginnen met het tekenen van √©√©n vijand. Daarvoor voegen we √©√©n regel toe (bijna bovenaan je code) en we voegen een regel code toe aan de love.load() en love.draw() functies:\n-- variabelen om eigenschappen van de speler en vijand in op te slaan speler = { x = 200, y = 560, plaatje = nil } vijand = { x = 200, y = 0, plaatje = nil } function love.load(arg) -- laad het plaatje in eigenschap plaatje van de variabele speler speler.plaatje = love.graphics.newImage(\u0026#39;plaatjes/spelersVliegtuig.png\u0026#39;) vijand.plaatje = love.graphics.newImage(\u0026#39;plaatjes/vijandsVliegtuig.png\u0026#39;) end function love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) love.graphics.draw(vijand.plaatje, vijand.x, vijand.y) end Probeer bovenstaande code uit.\nEr is nu √©√©n vijand en deze staat recht tegenover de speler. Een stilstaande vijand is niet zo interessant, dus we laten \u0026rsquo;m naar de speler bewegen. Dat kan vrij eenvoudig door het volgende aan de code toe te voegen aan je love.update(dt) functie:\nfunction love.update(dt) -- laat de vijand een stapje naar beneden doen vijand.y = vijand.y + 1 Bovenstaande code werkt hetzelfde als het verplaatsen van de speler. Nu bewegen we echter verticaal, van boven naar beneden. Daarom moeten we de y-positie in plaats van de x-positie veranderen. De positie van de vijand wordt steeds met 1 stapje naar beneden verzet. Zo beweegt de vijand naar de speler toe.\nOm het plaatje van buiten het venster tevoorschijn te laten komen, moet de y-positie aangepast worden naar -100. Pas de code bovenin je script aan door y = 0 te veranderen naar y = -100:\nvijand = { x = 200, y = -100, plaatje = nil } Onder aan het scherm vliegt de vijand het venster uit en is dan verdwenen. Het is natuurlijk leuker als er aan de bovenkant een nieuwe vijand verschijnt. Daarvoor moet je, net als bij het bewegend maken van de vijand, onderstaande code toevoegen aan love.update(dt):\n-- als de vijand de onderrand heeft bereikt if vijand.y \u0026gt; yOnderRand() then -- verplaats het dan uit het zicht boven het venster vijand.y = -100 end Om je te helpen met het begrijpen van de code: het verplaatsen van de vijand in Scratch zou er ongeveer zo uitzien:\nverander y met (1) als \u0026lt;(y-positie) \u003e (180)\u0026gt; dan maak y (-200) end Om het nog interessanter te maken, zou het leuk zijn als de vijand niet steeds op dezelfde plaats van boven naar beneden beweegt. De waarde van vijand.x (horizontale positie) zou iedere keer anders moeten zijn. Gebruik daarvoor de functie xWillekeurig():\n-- als de vijand de onderrand heeft bereikt if vijand.y \u0026gt; yOnderRand() then -- verplaats het dan uit het zicht boven het venster vijand.y = -100 -- en zet de horizontale positie naar een willekeurige waarde vijand.x = xWillekeurig() end Wat je in Scratch zou doen:\nverander y met (1) als \u0026lt;(y-positie) \u003e (180)\u0026gt; dan maak y (-200) maak x (willekeurig getal tussen (-240) en (240)) end Stap 5: meerdere vijanden We hebben nu een enkele vijand. Die is natuurlijk makkelijk te ontwijken. Het wordt veel spannender met meerdere vijanden. Daarvoor moeten we het √©√©n en ander aanpassen, de code die je eerder hebt geschreven voor √©√©n vijand, gaan we vervangen met code voor meerdere vijanden. Je moet hier en daar dus code verwijderen!\nAllereerst hebben we een lijst met vijanden nodig, die voegen we bovenaan de code toe, bij speler. Variabelen staan vaak bovenaan in code:\n-- variabelen om eigenschappen van de speler in op te slaan speler = { x = 200, y = 560, plaatje = nil } -- lijst om vijanden in op te slaan vijanden = {} Een andere variabele die we nodig hebben is het plaatje van de vijand. Eerder deden we dat in de functie love.draw(dt) met speler.plaatje. Die regel mag nu verwijderd worden en in plaats daarvan zetten we bij de variabelen speler en vijanden ook het plaatje voor de vijand:\n-- laad het plaatje van de vijand vijandPlaatje = love.graphics.newImage(\u0026#39;plaatjes/vijandsVliegtuig.png\u0026#39;) De vijanden moeten ook getekend worden, zorg ervoor dat jouw love.draw(dt) functie eruit ziet zoals hieronder:\nfunction love.draw(dt) -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) -- teken de vijanden in de lijst tekenVijanden(vijanden) end Er worden alleen vijanden getekend die bestaan, daarom moeten vijanden ook aangemaakt worden:\nfunction love.update(dt) maakNieuweVijand(vijanden) In de vorige stap hebben we de vijand laten bewegen. Deze code moeten we nu voor iedere vijand in de lijst uitvoeren:\nfunction love.update(dt) maakNieuweVijand(vijanden) -- voor elke vijand in de lijst for index, vijand in ipairs(vijanden) do -- laat de vijand een stapje naar beneden doen vijand.y = vijand.y + 2 -- als de vijand de onderrand heeft bereikt if vijand.y \u0026gt; yOnderRand() then -- verwijder de vijand table.remove(vijanden, index) end end Het maken en verwijderen van vijanden zoals we dat hierboven doen is in Scratch heel lastig. We geven daarom geen voorbeeld van het bovenstaande in Scratch. Waar het kan doen we dat wel.\nVoer het programma uit. Als het goed is ziet het eruit als in onderstaande plaatje:\nStap 6: de vijand ontwijken Als de speler een vijand raakt, is het spel afgelopen. Om te zien of de speler een vijand geraakt heeft, hebben we functie spelerHeeftVijandGeraakt().\nAls het resultaat van de functie waar (true) is, dan moet het spel gestopt worden.\nVoeg daarvoor de volgende code toe aan functie love.update(dt):\n-- als de speler een vijand geraakt heeft if spelerHeeftVijandGeraakt() then -- is het spel afgelopen spelIsAfgelopen = true end In Scratch zou het er zo uitzien:\nals \u0026lt;raak ik [Vijand v]?\u0026gt; dan maak[spelIsAfgelopen v] (1) end In variabele spelIsAfgelopen wordt bijgehouden of het spel nog loopt of al is afgelopen. Als het is afgelopen, wordt de speler niet langer getekend. Pas daarvoor de functie love.draw(dt) aan door het tekenen van de speler binnen een if statement te plaatsen:\nfunction love.draw(dt) -- als het spel nog niet is afgelopen if spelIsAfgelopen == false then -- teken het plaatje op het scherm love.graphics.draw(speler.plaatje, speler.x, speler.y) end In Scratch zou het er zo uitzien:\nals \u0026lt;(spelIsAfgelopen) = (0)\u0026gt; dan verschijn end Vergeet niet om bovenaan het bestand de variabele toe te voegen:\nspelIsAfgelopen = false Als je nu het spel speelt, wordt het spelersvliegtuig niet meer getekend als je een vijand hebt geraakt.\nStap 7: schieten De stap schieten lijkt op een combinatie van stappen 4 en 5.\nEr moet een lijst worden toegevoegd voor de kogels:\n-- variabelen om eigenschappen van de speler in op te slaan speler = { x = spelerX, y = spelerY, plaatje = nil } -- lijst om vijanden in op te slaan vijanden = {} -- lijst om kogels in op te slaan kogels = {} Het plaatje van de kogel moet worden geladen:\n-- laad het plaatje van de vijand vijandPlaatje = love.graphics.newImage(\u0026#39;plaatjes/vijandsVliegtuig.png\u0026#39;) -- laad het plaatje van de kogel kogelPlaatje = love.graphics.newImage(\u0026#39;plaatjes/kogel.png\u0026#39;) En het plaatje moet worden getekend, dat doe je in de love.draw(dt) functie:\n-- teken de kogels in de lijst tekenKogels(kogels) In tegenstelling tot de vijanden, worden nieuwe kogels alleen aangemaakt als de speler de spatiebalk indrukt. In de love.update(dt) functie voeg je het volgende toe:\nif spelIsAfgelopen == false then -- als de spatiebalk wordt ingedrukt if love.keyboard.isDown(\u0026#39;space\u0026#39;) then -- schiet dan maakNieuweKogel(kogels, speler) end maakNieuweVijand(vijanden) Als je de code tot nu toe uitprobeert, krijg je wel kogels te zien, maar die bewegen niet. Dit ziet eruit als het plaatje hieronder.\nAan de love.update(dt) functie moet extra code worden toegevoegd om de kogels te laten bewegen. Elke kogel in de lijst laten we telkens vier stappen omhoog gaan. Als een kogel uit beeld verdwijnt, halen we de kogel ook uit de lijst:\nif spelIsAfgelopen == false then -- als de spatiebalk wordt ingedrukt if love.keyboard.isDown(\u0026#39;space\u0026#39;) then -- schiet dan maakNieuweKogel(kogels, speler) end -- voor elke kogel in de lijst for index, kogel in ipairs(kogels) do -- beweeg de kogel naar boven kogel.y = kogel.y - (2 * stapGrootte) -- als de kogel de bovenrand heeft bereikt if kogel.y \u0026lt; -20 then -- verwijder het uit de lijst table.remove(kogels, index) end end maakNieuweVijand(vijanden) Dat ziet er beter uit!\nStap 8: raken en scoren De vijanden vliegen, je kunt je vliegtuig besturen en je kan schieten. Maar je schoten raken nog niets en de vijanden vliegen door. Daar gaan we in deze stap wat aan doen.\nFunctie kogelHeeftVijandGeraakt() laat ons weten of een kogel een vijand geraakt heeft. Ook verwijdert deze functie de geraakte vijand en de kogel:\n-- als de kogel een vijand geraakt heeft if kogelHeeftVijandGeraakt() then -- heb je een punt gescoord score = score + 1 end Voeg bovenstaande code toe aan love.update(dt). Om de score in op te slaan, moet je ook nog een variabele aanmaken boven aan het bestand:\nscore = 0 In Scratch ziet het er zo uit:\nmaak [score v] (0) als \u0026lt;raak ik [Kogel v]?\u0026gt; dan verander [score v] met (1) end We willen natuurlijk de score kunnen zien. Voeg daarvoor in love.draw(dt) het volgende toe:\n-- zet de tekstkleur op wit love.graphics.setColor(255, 255, 255) -- en druk de score af love.graphics.print(\u0026#34;SCORE: \u0026#34; .. tostring(score), 400, 10) Stap 9: opnieuw starten Mocht je een vijand aanraken, dan is het spel afgelopen, maar dan wil je natuurlijk wel opnieuw kunnen beginnen. Daarvoor gaan we code toevoegen aan love.update(dt):\n-- als de o van opnieuw wordt ingedrukt if love.keyboard.isDown(\u0026#39;o\u0026#39;) then -- wordt het spel opnieuw gestart kogels = {} vijanden = {} score = 0 spelIsAfgelopen = false end Als je op de toets o drukt begint je spel opnieuw. Het spel is nu klaar!\nVoorbereide functies Bij het maken van het spelletje heb je gebruik gemaakt van een aantal voorbereide functies. Als je je nu afvraagt hoe die functies zijn gemaakt, dan kun je eens kijken in het bestand functies.lua.\nVoorbeeld code Mocht je nu ook nog een voorbeeld van de volledige code willen bekijken, dan kan je eens kijken in voorbeeld.lua.\nConclusie Het spelletje is af en je hebt geleerd hoe je een 2D shooter kunt maken met L√∂ve.\nVervolg Als je meer wilt maken met L√∂ve, dan zijn er meerdere instructies (in het Engels: tutorials) op het internet te vinden. Helaas zijn die wel vrijwel allemaal Engelstalig.\nEen overzicht vind je op site van L√∂ve zelf: https://love2d.org/wiki/Category:Tutorials.\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"August 26, 2020","permalink":"/instructies/love2d-shooter/","title":"L√∂ve2D - Shooter"},{"categories":null,"contents":"Deze keer gaan we tekenen met Python Turtle.\nTurtle introductie Commando\u0026rsquo;s Python Interpreter Start Thonny.\nType onderin (je hoeft de \u0026raquo;\u0026gt; niet te typen):\n\u0026gt;\u0026gt;\u0026gt; from turtle import * Hiermee geef je Python de opdracht om de turtle te gebruiken.\nTekenen Je turtle kan voor je tekenen door hem opdrachten te geven. Type het volgende:\n\u0026gt;\u0026gt;\u0026gt; forward(100) Met dit commando gaat je turtle 100 stapjes vooruit. Als dat nog niet gebeurd was, moet nu een scherm zijn geopend, waarin je de de turtle en een lijn kan zien.\nDe turtle kan ook achteruit:\n\u0026gt;\u0026gt;\u0026gt; backward(100) Dikkere lijnen Je kan je lijnen dikker maken met width(). Probeer deze commando\u0026rsquo;s maar eens uit:\n\u0026gt;\u0026gt;\u0026gt; width(5) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; width(2) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; width(1) \u0026gt;\u0026gt;\u0026gt; forward(100) Tip: met de pijltjestoetsen (omhoog en omlaag) op je toetsenbord kun je eerdere commando\u0026rsquo;s terug halen. Met enter kun je die dan opnieuw uitvoeren.\nDraaien Je kan je turtle laten draaien:\n\u0026gt;\u0026gt;\u0026gt; right(90) Hiermee draait de turtle 90 graden naar rechts. Als je niet weet wat 90 graden betekent, kun je verschillende getallen uitproberen. Je kan ook naar links draaien. Probeer deze commando\u0026rsquo;s maar eens uit:\n\u0026gt;\u0026gt;\u0026gt; left(45) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; right(180) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; left(360) \u0026gt;\u0026gt;\u0026gt; forward(100) Kleur Je turtle en de lijnen zijn nu nog zwart. Je kan de kleur van de turtle en de achtergrond kleur makkelijk veranderen. Probeer deze commando\u0026rsquo;s eens uit en kijk bij elk commando wat er verandert op je scherm:\n\u0026gt;\u0026gt;\u0026gt; color('green') \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; bgcolor('yellow') \u0026gt;\u0026gt;\u0026gt; color('red') \u0026gt;\u0026gt;\u0026gt; forward(100) Experimenteer vooral ook met andere kleuren! Onderin deze pagina zie je een overzichtje van allerlei verschillende kleuren.\nOpnieuw beginnen Je kan de tekening die de turtle heeft gemaakt verwijderen:\n\u0026gt;\u0026gt;\u0026gt; clear() Je kan ook helemaal opnieuw beginnen:\n\u0026gt;\u0026gt;\u0026gt; reset() \u0026gt;\u0026gt;\u0026gt; bgcolor('white') Opdrachten Probeer de onderstaande plaatjes eens na te tekenen met je turtle. Gebruik na elke opdracht het reset() commando om aan de volgende te beginnen. De achtergrondkleur staat telkens ingesteld op \u0026lsquo;black\u0026rsquo;.\nOpdracht 1-A kleur: \u0026lsquo;green\u0026rsquo;\nOpdracht 1-B kleuren: \u0026rsquo;lightblue\u0026rsquo; en \u0026lsquo;yellow\u0026rsquo;\nOpdracht 1-C kleuren: \u0026lsquo;darkkhaki\u0026rsquo; en \u0026lsquo;red\u0026rsquo;.\nKleuren overzicht Hier zijn verschillende kleuren die je kan gebruiken voor color() of bgcolor().\nPython introductie Variabelen en loops Variabelen Probeer deze code eens uit en kijk goed wat er gebeurt:\n\u0026gt;\u0026gt;\u0026gt; getal = 45 \u0026gt;\u0026gt;\u0026gt; forward(getal) \u0026gt;\u0026gt;\u0026gt; right(getal) \u0026gt;\u0026gt;\u0026gt; forward(getal) \u0026gt;\u0026gt;\u0026gt; getal = 90 \u0026gt;\u0026gt;\u0026gt; right(getal) \u0026gt;\u0026gt;\u0026gt; forward(getal) Het woord \u0026ldquo;getal\u0026rdquo; is hier een variabele. Een variabele heeft een naam die je zelf kiest en een waarde. Die waarde begint hier als 45 en wordt later ingesteld als 90.\nJe kan Python ook rekensommetjes laten maken en de uitkomst in een variabele stoppen. Om te weten wat voor waarde een variabele heeft, type je de naam van de variabele in en druk je op enter. Probeer maar eens uit:\n\u0026gt;\u0026gt;\u0026gt; getal1 = 1 + 1 \u0026gt;\u0026gt;\u0026gt; getal1 2 \u0026gt;\u0026gt;\u0026gt; getal2 = 9 - getal1 \u0026gt;\u0026gt;\u0026gt; getal2 7 \u0026gt;\u0026gt;\u0026gt; getal3 = getal2 * 2 \u0026gt;\u0026gt;\u0026gt; getal3 14 \u0026gt;\u0026gt;\u0026gt; getal4 = 28 / getal3 \u0026gt;\u0026gt;\u0026gt; getal4 2.0 Zoals je ziet: \u0026lsquo;*\u0026rsquo; betekent vermenigvuldigen, en \u0026lsquo;/\u0026rsquo; is delen door.\nHerhaling Je kan bepaalde commando\u0026rsquo;s ook meerdere keren laten uitvoeren, dat noemen we een loop:\n\u0026gt;\u0026gt;\u0026gt; for teller in range(4): ... forward(100) ... right(90) Let op: Nadat je dit getypt hebt moet je nog een keer op enter drukken, zodat Python weet dat je klaar bent met je loop.\nIn dit voorbeeld is \u0026ldquo;teller\u0026rdquo; een variabele die optelt en range() geeft aan tot welk getal geteld moet worden. Teller begint bij 0 en telt tot 4. Als je nu de waarde van teller vraagt, zie je dat het tellen is opgehouden voordat 4 werd bereikt:\n\u0026gt;\u0026gt;\u0026gt; teller 3 Je kan teller dus ook gebruiken in je turtle opdrachten! Kun jij voorspellen wat er gebeurt als je onderstaande commando\u0026rsquo;s intypt?\n\u0026gt;\u0026gt;\u0026gt; for teller in range(1,5): ... forward(50 * teller) ... right(90) Met range(1,5) begint het tellen bij 1 en eindigt op 4 (voordat de 5 wordt bereikt).\nFiguren tekenen Veelhoek Met een klein rekensommetje kun je ook een veelhoek tekenen! Om een veelhoek te tekenen moet je weten wat voor hoek je turtle moet maken. Gelukkig kan Python dat voor je berekenen: om de turtle helemaal rond te laten gaan moet deze 360 graden gedraaid zijn.\n\u0026gt;\u0026gt;\u0026gt; aantal_punten = 5 \u0026gt;\u0026gt;\u0026gt; hoek = 360 / aantal_punten \u0026gt;\u0026gt;\u0026gt; for teller in range(aantal_punten): ... forward(100) ... right(hoek) Wat gebeurt er nu als je de variabele aantal_punten een hoger getal geeft?\nSter De hoek die je nodig hebt voor een ster is moeilijker te berekenen. Sommige sterren zijn niet eens in 1 lijn te tekenen, bijvoorbeeld de 6-puntige ster. De 5-puntige ster is makkelijker:\n\u0026gt;\u0026gt;\u0026gt; hoek = 144 \u0026gt;\u0026gt;\u0026gt; for teller in range(5): ... forward(100) ... right(hoek) Opdrachten Probeer de onderstaande figuren te tekenen.\nOpdracht 2-A Tip: De hoek is 150 graden.\nOpdracht 2-B Uitdaging: probeer zo min mogelijk commando\u0026rsquo;s te gebruiken om de opdracht uit te voeren. Lukt het in 5 regels? Vraag een mentor om tips!\nOpdracht 2-C Tip: Gebruik een zo klein mogelijke waarde in je forward() zodat de cirkel niet te groot wordt!\nTurtle voor gevorderden Meer turtle commando\u0026rsquo;s Veelhoeken functie Tot nu toe tekenen we veelhoeken door herhaaldelijk vooruit te lopen en een stukje te draaien. Omdat veelhoeken vaak van pas komen, is hier echter ook een aparte functie voor:\n\u0026gt;\u0026gt;\u0026gt; circle(50, 360, 4) In dit geval tekenen we een veelhoek met een afstand van 50 tussen de omtrek en het middelpunt; dit noemen we de radius. Met 360 geven we aan dat we de volledige vorm willen tekenen. Voor een halve veelhoek gebruiken we hier bijvoorbeeld 180. Het laatste getal, 4, geeft aan dat we vier keer willen draaien en vooruit lopen. Hiermee maken we dus een ruit!\nAls je wil kan je de volgende code proberen. Deze tekent tien veelhoeken naast elkaar: van een eenhoek (monogoon) tot een tienhoek (decagoon).\n\u0026gt;\u0026gt;\u0026gt; for i in range(10): \u0026gt;\u0026gt;\u0026gt; radius = 50 \u0026gt;\u0026gt;\u0026gt; aantal_punten = i + 1 \u0026gt;\u0026gt;\u0026gt; locatie_x = -500 + i * 100 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(locatie_x, -radius) \u0026gt;\u0026gt;\u0026gt; pendown() \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; circle(radius, 360, aantal_punten) Vormen en stempels Je turtle lijkt tot nu toe niet echt op een schildpad, maar dat kun je veranderen:\n\u0026gt;\u0026gt;\u0026gt; shape('turtle') \u0026gt;\u0026gt;\u0026gt; color('darkgreen') Met shape() kun je dus de vorm veranderen. Andere vormen zijn ‚Äúarrow‚Äù, ‚Äúcircle‚Äù, ‚Äúsquare‚Äù, ‚Äútriangle‚Äù en ‚Äúclassic‚Äù.\nJe turtle kan ook stempelen, net als in Scratch. Probeer deze commando\u0026rsquo;s eens uit en kijk na elke stap wat er gebeurt:\n\u0026gt;\u0026gt;\u0026gt; shape('circle') \u0026gt;\u0026gt;\u0026gt; color('red') \u0026gt;\u0026gt;\u0026gt; stempel1 = stamp() \u0026gt;\u0026gt;\u0026gt; right(90) \u0026gt;\u0026gt;\u0026gt; forward(50) \u0026gt;\u0026gt;\u0026gt; shape('square') \u0026gt;\u0026gt;\u0026gt; color('yellow') \u0026gt;\u0026gt;\u0026gt; stempel2 = stamp()‚àè \u0026gt;\u0026gt;\u0026gt; forward(50) \u0026gt;\u0026gt;\u0026gt; shape('triangle') \u0026gt;\u0026gt;\u0026gt; color('blue') \u0026gt;\u0026gt;\u0026gt; stempel3 = stamp() \u0026gt;\u0026gt;\u0026gt; forward(50) \u0026gt;\u0026gt;\u0026gt; shape('classic') \u0026gt;\u0026gt;\u0026gt; clearstamp(stempel2) Elke keer dat we stempelen, met stamp(), maken we ook een variabele aan. Die variabelen kunnen we gebruiken om stempels die we gedrukt hebben te verwijderen, met clearstamp(). Daarom is het handig om ze een naam te geven zoals stempel1, stempel2, etc. Dan weet je later nog precies welke stempel dat is geweest.\nTurtle posities Tot nu toe hebben we de turtle verplaatst door vooruit/achteruit te gaan en te draaien, maar je kan ook de turtle opdracht geven om naar een bepaalde plek te gaan:\n\u0026gt;\u0026gt;\u0026gt; setpos(50,50) \u0026gt;\u0026gt;\u0026gt; setpos(-25,75) \u0026gt;\u0026gt;\u0026gt; setpos(0,0) Om erachter te komen wat elk getal betekent, kun je het beste 1 van de 2 veranderen en dan zien wat er gebeurt. Het eerste getal noemen we de X-as, het tweede getal noemen we de Y-as.\nSoms wil je de turtle verplaatsen zonder dat er een lijn wordt getekend. Je turtle kan zijn pen optillen en neerzetten met penup() en pendown(). Om bijvoorbeeld een vork te tekenen, schrijf je dit:\n\u0026gt;\u0026gt;\u0026gt; left(90) \u0026gt;\u0026gt;\u0026gt; backward(100) \u0026gt;\u0026gt;\u0026gt; forward(125) \u0026gt;\u0026gt;\u0026gt; setpos(0,0) \u0026gt;\u0026gt;\u0026gt; left(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; right(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(0,0) \u0026gt;\u0026gt;\u0026gt; pendown() \u0026gt;\u0026gt;\u0026gt; right(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; left(90) \u0026gt;\u0026gt;\u0026gt; forward(25) \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(0,0) Je kan aan je turtle vragen wat zijn X positie is en wat zijn Y positie is. Je kan die positie ook opslaan in variabelen, zodat je ze later kan gebruiken:\n\u0026gt;\u0026gt;\u0026gt; left(30) \u0026gt;\u0026gt;\u0026gt; forward(100) \u0026gt;\u0026gt;\u0026gt; xcor() 86.60254037844388 \u0026gt;\u0026gt;\u0026gt; ycor() 49.99999999999999 \u0026gt;\u0026gt;\u0026gt; x = xcor() \u0026gt;\u0026gt;\u0026gt; setpos(x, 0) \u0026gt;\u0026gt;\u0026gt; setpos(0, 0) Turtle draaien Zoals je de turtle naar een bepaalde plek kan laten gaan, kan je deze ook naar een bepaalde hoek laten draaien:\n\u0026gt;\u0026gt;\u0026gt; setheading(0) # rechts \u0026gt;\u0026gt;\u0026gt; setheading(90) # boven \u0026gt;\u0026gt;\u0026gt; setheading(180) # links \u0026gt;\u0026gt;\u0026gt; setheading(270) # onder \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; setheading(135) # ??? De turtle draait dus naar een bepaalde hoek, zonder dat het uitmaakt waar hij daarvoor naartoe kijkt.\nInkleuren Je turtle tekent mooie lijnen, maar je vormen kunnen ook ingekleurd worden:\n\u0026gt;\u0026gt;\u0026gt; bgcolor('black') \u0026gt;\u0026gt;\u0026gt; color('green') \u0026gt;\u0026gt;\u0026gt; fillcolor('darkgreen') \u0026gt;\u0026gt;\u0026gt; width(3) \u0026gt;\u0026gt;\u0026gt; begin_fill() \u0026gt;\u0026gt;\u0026gt; for x in range(4): ... forward(100) ... right(90) ... \u0026gt;\u0026gt;\u0026gt; end_fill() Let op dat het invullen pas gebeurt bij end_fill(). Je kan de invulkleur kiezen met fillcolor(). Als je geen invulkleur kiest, wordt de kleur van je pen gebruikt.\nDeze techniek wordt echt indrukwekkend als je het gebruikt bij meer ingewikkelde tekeningen. Met deze code teken je bijvoorbeeld een mooie geel-zwarte ster:\n\u0026gt;\u0026gt;\u0026gt; color('yellow') \u0026gt;\u0026gt;\u0026gt; bgcolor('black') \u0026gt;\u0026gt;\u0026gt; begin_fill() \u0026gt;\u0026gt;\u0026gt; for x in range(18): ... forward(200) ... left(100) ... \u0026gt;\u0026gt;\u0026gt; end_fill() Tekst en turtle verbergen De laatste twee technieken die we hier behandelen spreken bijna voor zich. Probeer de onderstaande code maar eens om een deurmat te tekenen. Welke commando\u0026rsquo;s ken je nog niet? Snap je waar ze voor bedoeld zijn?\n\u0026gt;\u0026gt;\u0026gt; write('Welkom!') \u0026gt;\u0026gt;\u0026gt; penup() \u0026gt;\u0026gt;\u0026gt; setpos(-20,20) \u0026gt;\u0026gt;\u0026gt; pendown() \u0026gt;\u0026gt;\u0026gt; for x in range(2): ... forward(70) ... right(90) ... forward(40) ... right(90) ... \u0026gt;\u0026gt;\u0026gt; hideturtle() Tip: hideturtle() is ook een handig commando bij het stempelen. Om de turtle weer te tonen gebruik je showturtle().\nOpdrachten Probeer de onderstaande tekeningen na te maken, of bedenk je eigen tekeningen.\nOpdracht 3-A Schildpadden in een zandbak\nOpdracht 3-B Een analoge klok.\nChallenge: als je de wijzers een bepaalde stand in wil laten nemen, kan je hiervoor de volgende functies gebruiken:\ndef uren_naar_hoek(uren): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;uren\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (uren / 12.0) * 360 + 90 def minuten_naar_hoek(minuten): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;minuten\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (minuten / 60.0) * 360 + 90 De hoek kan je vervolgens aan setheading() geven.\nOpdracht 3-C Een ruiten drie speelkaart. Maar: er klopt iets niet helemaal!\nDe kaart bevat twee vormen die meerdere keren herhaald worden: de ruit en het getal drie. Als je bekend bent met functies, kan het handig zijn om deze hier te gebruiken. Daarnaast kan je natuurlijk ook een ruiten een kaart maken, als je de circle() functie nog lastig vindt.\nAntwoorden Mocht je er niet uitkomen, dan kun je hier klikken voor antwoorden. Let op: de volgende lijn ontbreekt aan de bovenkant van deze voorbeelduitwerkingen: from turtle import * Deel 1 Opdracht 1-A bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;green\u0026#39;) width(5) forward(100) right(90) forward(100) right(90) forward(100) right(90) forward(100) right(90) Opdracht 1-B bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;yellow\u0026#39;) width(3) left(90) forward(50) right(90) forward(200) right(90) forward(100) right(90) forward(200) right(90) forward(50) color(\u0026#39;lightblue\u0026#39;) width(1) right(45) forward(100) right(90) forward(100) right(90) forward(100) right(90) forward(100) Opdracht 1-C bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;darkkhaki\u0026#39;) width(5) forward(200) right(90) forward(100) right(90) forward(200) right(90) forward(100) color(\u0026#39;red\u0026#39;) width(2) right(45) forward(100) right(90) forward(100) color(\u0026#39;darkkhaki\u0026#39;) right(45) forward(100) Deel 2 Opdracht 2-A Tip: 12 x 150 = 1800, en 1800 / 360 = 5. Omdat 1800 deelbaar is door 360, komen de hoeken precies goed uit voor een ster. bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;lightblue\u0026#39;) width(3) for i in range(12): forward(100) right(150) Opdracht 2-B bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;lightblue\u0026#39;) width(3) for i in range(4): for j in range(3): forward(100) right(120) right(90) Opdracht 2-C Tip: In plaats van 360 en 1 kan je ook andere getallen kiezen. Zorg dat deze keer elkaar 360 zijn. bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;lightblue\u0026#39;) width(3) for i in range(360): forward(2) right(1) Deel 3 Opdracht 3-A In deze voorbeelduitwerking staan 2 stempels. Je kan er zelf nog een paar toevoegen als je wil! bgcolor(\u0026#39;black\u0026#39;) color(\u0026#39;yellow\u0026#39;) width(5) fillcolor(\u0026#39;lightyellow\u0026#39;) begin_fill() setpos(0,200) setpos(200,200) setpos(200,0) setpos(0,0) end_fill() penup() setpos(50,50) shape(\u0026#39;turtle\u0026#39;) color(\u0026#39;green\u0026#39;) stempel1 = stamp() setpos(84,129) right(120) shape(\u0026#39;turtle\u0026#39;) color(\u0026#39;blue\u0026#39;) stempel2 = stamp() Opdracht 3-B def uren_naar_hoek(uren): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;uren\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (uren / 12.0) * 360 + 90 def minuten_naar_hoek(minuten): \u0026#34;\u0026#34;\u0026#34;Geeft de hoek voor de wijzer die \u0026#34;minuten\u0026#34; aan moet geven. \u0026#34;\u0026#34;\u0026#34; return - (minuten / 60.0) * 360 + 90 # De radius van de circel voor de klok. radius = 100 # Voer hier de beoogde tijd in. Je kan de hoeken natuurlijk ook op gevoel kiezen! minuten = 45 # 45 / 60 uren = 12 # 12 / 12 # Maak de omgeving in orde. speed(\u0026#39;fastest\u0026#39;) bgcolor(\u0026#39;white\u0026#39;) color(\u0026#39;black\u0026#39;) penup() # Start met het tekenen van een circel en een twaalfhoek. width(5) setpos(0, -radius) pendown() circle(radius, 360, 360) circle(radius, 360, 12) penup() # Vervolgens tekenen we de kleine wijzer, op basis van \u0026#34;uren\u0026#34;. setpos(0, 0) setheading(minuten_naar_hoek(minuten)) pendown() forward(.8 * radius) stempel0 = stamp() penup() # De grote wijzer tekenen we op een soortgelijke manier. setpos(0, 0) setheading(uren_naar_hoek(uren)) pendown() forward(.5 * radius) stempel1 = stamp() penup() # Challenges: # - voeg een secondewijzer toe; # - voeg (enkele) getallen toe; # - voeg streepjes voor uren aan de buitenrand toe. done() Opdracht 3-C speed(\u0026#39;fastest\u0026#39;) def teken_ruit(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34;Teken een ruit met radius: radius. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y-radius) setheading(0) pendown() begin_fill() circle(radius, 360, 4) end_fill() penup() def teken_drie(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een drie met hoogte: 2 * diameter, breedte: diameter. Van belang: circle draait linksom. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y) setheading(0) pendown() circle(radius, 270) penup() setpos(midden_x-radius, midden_y-radius) setheading(270) pendown() circle(radius, 270) penup() # De hoogte en breedte van de kaart. hoogte = 400 breedte = 250 # De radius van de ruiten op de kaart. ruit_radius_groot = 40 ruit_radius_klein = 10 # De radius van de circels van de drie op de kaart. drie_radius = 10 # Teken de omtrek van de kaart. penup() setpos(-.5 * breedte, .5 * hoogte) pendown() for i in range(2): forward(breedte) right(90) forward(hoogte) right(90) # Vanaf hier kleuren we alles rood. color(\u0026#39;red\u0026#39;) fillcolor(\u0026#39;red\u0026#39;) # De ruit in het midden: teken_ruit(0, 0, ruit_radius_groot) # De ruit aan de bovenkant, op een afstand van 20 van de ruit in het midden: teken_ruit(0, 2 * ruit_radius_groot + 20, ruit_radius_groot) # De ruit aan de onderkant, op een afstand van 20 van de ruit in het midden: teken_ruit(0, -2 * ruit_radius_groot - 20, ruit_radius_groot) # Het getal drie in de hoek linksboven. # De afstanden tot de omtrek kan je eventueel nog op \u0026#39;drie_radius\u0026#39; afstemmen. width(5) teken_drie(-.5 * breedte + 15, .5 * hoogte - 25, drie_radius) teken_drie( .5 * breedte - 15, -.5 * hoogte + 25, drie_radius) # Extra: de kleine ruiten onder- en boven de getallen: teken_ruit(-.5 * breedte + 15, .5 * hoogte - 65, ruit_radius_klein) teken_ruit( .5 * breedte - 15, -.5 * hoogte + 65, ruit_radius_klein) setpos(0, 0) done() Extra: getallen 0, 1, 2, 3, 4 tekenen. speed(\u0026#39;fastest\u0026#39;) def teken_nul(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een nul met hoogte: 2 * diameter, breedte: diameter. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x + radius, midden_y + radius) setheading(90) pendown() circle(radius, 180) forward(2 * radius) circle(radius, 180) forward(2 * radius) penup() def teken_een(midden_x, midden_y, lengte): \u0026#34;\u0026#34;\u0026#34; Teken een (simpele) een met hoogte: lengte, breedte: width. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y + .5 * lengte) setheading(270) pendown() forward(lengte) penup() def teken_twee(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een tween met hoogte: 2 * diameter, breedte: diameter. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x + radius, midden_y + radius) setheading(90) pendown() circle(radius, 180) penup() setpos(midden_x + radius, midden_y + radius) pendown() setpos(midden_x - radius, midden_y - 2 * radius) setheading(0) forward(2 * radius) penup() def teken_drie(midden_x, midden_y, radius): \u0026#34;\u0026#34;\u0026#34; Teken een drie met hoogte: 2 * diameter, breedte: diameter. Van belang: circle draait linksom. \u0026#34;\u0026#34;\u0026#34; penup() setpos(midden_x, midden_y) setheading(0) pendown() circle(radius, 270) penup() setpos(midden_x-radius, midden_y-radius) setheading(270) pendown() circle(radius, 270) penup() def teken_vier(midden_x, midden_y, hoogte): \u0026#34;\u0026#34;\u0026#34; Teken een vier met hoogte: 2 * diameter, breedte: diameter \u0026#34;\u0026#34;\u0026#34; breedte = .5 * hoogte penup() setpos(midden_x + .25 * breedte, midden_y - .5 * hoogte) pendown() setpos(midden_x + .25 * breedte, midden_y + .5 * hoogte) setpos(midden_x - .5 * breedte, midden_y) setpos(midden_x + .5 * breedte, midden_y) penup() # Stel vast hoe groot de getallen moeten worden. radius = 50 getal_hoogte = 4 * radius getal_breedte = 2 * radius teken_nul(-200, 0, radius) teken_een(-100, 0, getal_hoogte) teken_twee(0, 0, radius) teken_drie(100, 0, radius) teken_vier(200, 0, getal_hoogte) done() Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"August 24, 2020","permalink":"/instructies/python-turtle/","title":"Python - Turtle"},{"categories":null,"contents":"We gaan met Scratch het klassieke spel Snake bouwen.\nBenodigdheden Ga naar https://scratch.mit.edu/ en klik op \u0026lsquo;Aan de slag\u0026rsquo;.\nAls je Scratch nog niet eerder hebt uitgeprobeerd, bekijk dan eerst de video onderaan die pagina. Klik daarna op het groene pijltje naast de video om stap-voor-stap te leren hoe Scratch werkt. Als je meer wil leren, klik dan bovenaan op \u0026lsquo;Lessen\u0026rsquo;, of ga hier verder met de handleiding. Inleiding In deze opdracht ga je het klassieke spelletje Snake, dus Slang, programmeren. Je bestuurt in dit spelletje een slang en je doel is door zo veel mogelijk te eten zo lang mogelijk te worden. Maar pas op, als je in je eigen staart bijt dan ben je af!\nDit zijn de stappen die je gaat programmeren:\nMaak de slang Zorg dat de slang kan bewegen Laat het eten van de slang verschijnen Maak de slang langer door het eten Laat het spel eindigen als de slang in de eigen staart bijt Als je dan nog zin (en tijd) hebt dan zijn er nog allerlei uitbreidingen mogelijk.\nDe opdracht is afgeleid van deze instructies (Github bron).\nMaak de slang Als je gekozen hebt het project helemaal vanaf het begin te doen, ontwerp dan je eigen slang of download deze plaatjes om de twee uiterlijken van de slang mee te maken:\nVolg deze stappen om een sprite van de slang te maken:\nKlik op het icoon voor een nieuwe sprite (rechtsonder, plaatje van de kat) en kies voor Upload sprite. Upload het hoofd van de slang. Ga naar het tabblad Uiterlijken (linksboven, rechts naast het Code tabblad). Klik op het icoon voor een nieuw uiterlijk (linksonder, plaatje van de kat) en kies voor Upload uiterlijk. Upload het lijf van de slang. Klik nu op het hoofd van de slang. Zorg dat de slang kan bewegen Het is de bedoeling om de slang met de pijltjestoetsen te laten bewegen. Er zijn verschillende manieren om dit te doen, bijvoorbeeld zo:\nwanneer [pijltje omhoog v] is ingedrukt richt naar (0) graden neem (5) stappen Met richt naar 0 graden draai je het hoofd van de slang naar boven, met neem 5 stappen beweegt de slang 5 stappen in die richting. Maar\u0026hellip; als je de toets loslaat, dan houdt de slang op met bewegen.\nOpdracht Zorg dat de slang doorgaat met bewegen totdat je een andere kant op gaat.\nTip 1: hiervoor heb je het herhaal blok uit het menu Besturen nodig.\nTip 2: begin het programma met het wanneer op de vlag wordt geklikt blok uit het menu Gebeurtenissen.\nKlik om de voorbeeldcode te laten zien om de slang omhoog te laten bewegen wanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje omhoog v] ingedrukt?\u0026gt; dan richt naar (0) graden end neem (10) stappen wacht (0.1) sec. In de voorbeeldcode wordt het blok wacht 0.1 sec. gebruikt. Dit is niet nodig om de slang te laten bewegen, maar wordt verderop in het spel belangrijk. Door de wachttijd en/of het aantal stappen dat de slang zet te veranderen kun je de snelheid van de slang bepalen.\nExtra: via de volgende aanpassing reageert de slang beter! wanneer groene vlag wordt aangeklikt herhaal neem (10) stappen wacht (0.1) sec. end wanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje omhoog v] ingedrukt?\u0026gt; dan richt naar (0) graden end Met deze aanpassing check je elke update of er een pijltje is ingedrukt. Voorheen gebeurde dit niet altijd, omdat we tussendoor ook 0.1 seconde wachtten. Laat de appels verschijnen Nu is het tijd om de slang eten te geven. Dit voorbeeld gaat uit van appels, je kunt natuurlijk ook iets heel anders verzinnen. Om het lekker onvoorspelbaar te maken waar de appel verschijnt, is het blok ga naar willekeurige positie uit het menu Beweging heel geschikt.\nOpdracht Maak een nieuwe sprite voor de appel, en zorg dat er bij het begin van het spel een appel verschijnt.\nTip: zorg dat je de appel-sprite hebt gekozen, zodat de code die je maakt ook echt bepaalt wat de appel moet doen.\nKlik om de voorbeeldcode te laten zien wanneer groene vlag wordt aangeklikt ga naar (willekeurige positie) De volgende stap is om een \u0026ldquo;nieuwe\u0026rdquo; appel op een andere plek te laten verschijnen wanneer de slang er een heeft opgegeten. Hiervoor maak je niet echt een nieuwe appel, maar je laat de appel-sprite gewoon op een andere plek verschijnen.\nOpdracht Laat de appel op een andere plek verschijnen als de slang er een heeft opgegeten.\nTip: hiervoor kun je het blok raak ik \u0026hellip; uit het menu Waarnemen gebruiken.\nKlik om de voorbeeldcode te laten zien wanneer groene vlag wordt aangeklikt ga naar (willekeurige positie) herhaal als \u0026lt;raak ik (slang hoofd v)?\u0026gt; dan ga naar (willekeurige positie) end Maak de slang langer Van al die appels groeit de slang natuurlijk wel! Het is nu tijd om de slang langer te maken als je een appel eet. Hiervoor is het eerst nodig dat je bijhoudt hoeveel appels de slang al heeft gegeten, dat kun je ook meteen als je score in het spel gebruiken!\nOpdracht Hou het aantal gegeten appels bij.\nTip 1: hiervoor heb je een variabele nodig, deze maak je in het menu Variabelen.\nTip 2: zet aan het begin van het spel de waarde van de variabele op 0.\nKlik om de voorbeeldcode voor de slang te laten zien wanneer groene vlag wordt aangeklikt maak [score v] (0) enzovoort Klik om de voorbeeldcode voor de appel te laten zien wanneer groene vlag wordt aangeklikt ga naar (willekeurige positie) herhaal als \u0026lt;raak ik (slang hoofd v)?\u0026gt; dan ga naar (willekeurige positie) verander [score v] met (1) end Nu komt het moeilijkste stukje van het spel: het lijf van de slang! Hiervoor ga je werken met klonen van de slang, deze functies vind je in het menu Besturen. Dit werkt zo:\nhet lijf van de slang maak je door op de plek van het hoofd een kloon te maken. het lijf van de slang is het tweede uiterlijk van de slang sprite, om de kop in een lijf te laten veranderen heb je het verander uiterlijk naar blok in het menu Uiterlijken nodig. als je nog geen of weinig appels hebt gegeten, dan wil je zo\u0026rsquo;n kloon meteen - of in ieder geval heel snel - weer laten verdwijnen. hoe meer appels je hebt gegeten dus hoe hoger je score, hoe langer je wilt wachten met het laten verdwijnen van de kloon. Opdracht Kloon de kop van de slang (bij iedere stap), en laat de kloons na een tijdje weer verdwijnen. Tip: je kunt uitrekenen hoe lang je moet wachten door je score te vermenigvuldigen met hoe lang 1 stap van de slang duurt.\nKlik om de voorbeeldcode voor de slang te laten zien wanneer groene vlag wordt aangeklikt herhaal als \u0026lt;toets [pijltje omhoog v] ingedrukt?\u0026gt; dan richt naar (0) graden end neem (10) stappen wacht (0.1) sec. maak een kloon van (mijzelf v) Klik om de voorbeeldcode van kloons van de slang te laten zien wanneer ik als kloon start verander uiterlijk naar (slang_lijf v) wacht ((score) * (0.1)) sec. verwijder deze kloon Verliezen als je in jezelf hapt Je hebt nu een slang die steeds langer wordt als ie meer appels eet. Wat nog mist is dat het spel is afgelopen als je slang in zichzelf bijt. Dit gebeurt wanneer een deel van het lijf een ander deel van het lijf raakt.\nOpdracht Zorg ervoor dat het spel stopt als de slang in zichzelf bijt.\nTip: hiervoor kun je weer het raak ik blok gebruiken.\nKlik om de voorbeeldcode te laten zien wanneer ik als kloon start als \u0026lt;raak ik kleur [#9afeb6]?\u0026gt; dan stop [alle v] Uitbreidingen Je kunt het spel natuurlijk nog veel mooier, spannender en moeilijker maken. Hier heb je alvast een lijstje met idee√´n als je nog verder wil programmeren aan Snake:\nlaat de appels na een tijdje weer verdwijnen maak een start- of eindscherm voor het spel laat de slang sneller gaan als je meer appels hebt gegeten laat het spel ook afgelopen zijn als je de rand raakt kies een mooie achtergrond voor je spel laat ook voorwerpen verschijnen die je juist moet ontwijken programmeer het spel voor twee spelers Licentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"August 22, 2020","permalink":"/instructies/scratch-snake/","title":"Scratch - Snake"},{"categories":null,"contents":"Wie zijn we? Pieter | Mentor Na meer dan tien jaar onderzoek naar de hersenen gedaan te hebben met MRI, werkt Pieter tegenwoordig als data scientist en ontwikkelt bijvoorbeeld chatbots en manieren om interessante informatie uit teksten (zoals nieuwsberichten) te halen.\nIn zijn vrije tijd vindt Pieter het leuk ‚Äì ook samen met zijn dochters en soms op school ‚Äì bezig te zijn met allerlei soorten electronica zoals robots, micro:bit en Arduino.\nBas | Mentor Bas is een all-round softwareontwikkelaar bij Signify (voormalig Philips Lighting) in Eindhoven. Van origine een elektrotechnicus, maar al 20 jaar bezig met software in werk en hobby. Hij heeft software gemaakt voor lampen elektronica, Linux mini computers, websites, systeem testen en diverse scriptjes. Gebruikte programmeertalen zijn o.a. ANSI-C, Java, Python, SQL, HTML, JavaScript en PHP.\nHij leert zelf nog altijd graag en vind het ook leuk om zijn enthousiasme en kunde over te brengen aan kinderen. Zijn twee kinderen zijn ook ge√Ønteresseerd en zul je zo af en toe ook zien tijdens een Dojo.\nDaan | Mentor Jaap | Mentor Tjeerd | Mentor Rik | Mentor Auke | Mentor Maud-Marit | Mentor Claudia | Mentor Sijmen | Mentor Ook lid worden van het team? CoderDojo Nijmegen is altijd op zoek naar vrijwilligers. Kijk ook op pagina meehelpen.\n","date":"February 9, 2020","permalink":"/team/","title":"Team"},{"categories":null,"contents":"Wat is Stichting CoderDojo Nijmegen? De stichting CoderDojo Nijmegen wil kinderen op jonge leeftijd in staat stellen hun interesse voor IT te ontdekken en te ontplooien. De gemiddelde ouder en/of leerkracht heeft onvoldoende kennis en middelen om kinderen te laten verdiepen in IT, anders dan als consument. Tegelijkertijd is de IT een vakgebied dat zich razendsnel ontwikkelt. Het is daarom zinvol om je hierin zo vroeg mogelijk te verdiepen.\nDe stichting CoderDojo Nijmegen plaatst jonge kinderen in de rol van producent van IT (games, websites, etc.). Op deze manier kunnen kinderen experimenteren met hun digitale omgeving en worden ze bewust van de werking ervan. Naast bewustwording maakt de stichting CoderDojo Nijmegen het voor kinderen mogelijk om op jonge leeftijd een eventuele passie te ontdekken in een vertrouwde omgeving. Door de kinderen zelf de controle te geven over het leerproces, wordt hun nieuwsgierigheid geprikkeld en leren ze van en met elkaar.\nDoor het steunen van en samenwerken met gelijkgestemde organisaties zet de stichting CoderDojo Nijmegen zich in voor bewustwording en meer, beter en toegankelijker IT-onderwijs.\nWat doet CoderDojo Nijmegen? CoderDojo brengt kinderen in aanraking met IT. We laten jonge mensen zien hoe ze zelf een game of website kunnen bouwen. Zo kunnen kinderen op jonge leeftijd ontdekken of ze programmeren leuk vinden; ook als hun ouders geen IT-achtergrond hebben en er op de basisschool weinig aandacht voor is. Bij CoderDojo kunnen kinderen (ninja‚Äôs) in een vriendelijke omgeving experimenteren en ontdekken.\nCoderDojo Nijmegen organiseert maandelijks gratis IT workshops (Dojo‚Äôs) voor kinderen tussen 7 en 17 jaar. Tijdens die workshops bouwen de kinderen games, apps, websites en meer. De stichting is opgericht om naast de organisatie van workshops ook andere activiteiten te kunnen ontplooien. Zo maakt CoderDojo Nijmegen lesmateriaal dat ook bij andere CoderDojo‚Äôs kan worden gebruikt. Ook schaft CoderDojo Nijmegen materiaal (robots, computers, electronica) aan voor gebruik tijdens Dojo‚Äôs. Daarnaast kan de stichting andere Dojo‚Äôs ondersteunen met kennis en materiaal, zodat meer kinderen in aanraking kunnen komen met IT.\nBovenstaande is iets wat elk van de, ongeveer 1000, CoderDojo‚Äôs in de wereld probeert te doen. Daarnaast worden er internationale evenementen georganiseerd: bij EUDojo laten kinderen aan europarlementari√´rs zien hoe (belangrijk het is dat) zij leren programmeren.\nHet bestuur Esther van Popta voorzitter Leo Willems penningmeester Bas Hopman secretaris Daan Willems algemeen bestuurslid Rianne Kooi algemeen bestuurslid Contactgegevens Stichting CoderDojo Nijmegen\nNijhoffstraat 5\n6524 AT Nijmegen\nRSIN: 857425948\nBank: NL38 RABO 0317 6808 70\nEmail: ùóåùóçùóÇùñºùóÅùóçùóÇùóáùóÄ@ùñºùóàùñΩùñæùóãùñΩùóàùóÉùóà-ùóáùóÇùóÉùóÜùñæùóÄùñæùóá.ùóáùóÖ\nDownloads Beleidsplan\nJaarverslag 2021\nStatuten\nHuishoudelijk Reglement\nProtocol Veiligheid\n","date":"February 9, 2020","permalink":"/stichting/","title":"Stichting CoderDojo Nijmegen"},{"categories":null,"contents":"Via de website coderdojo-nijmegen.nl worden privacygevoelige gegevens oftewel persoonsgegevens verwerkt.St. Coderdojo Nijmegen acht een zorgvuldige omgang met persoonsgegevens van groot belang. Persoonlijke gegevens worden door ons dan ook zorgvuldig verwerkt en beveiligd.\nBij onze verwerking houden wij ons aan de eisen die de Algemene Verordening Gegevensbescherming (AVG) stelt. Dat betekent onder andere dat wij:\nduidelijk vermelden met welke doeleinden wij uw persoonsgegevens verwerken. Dat doen wij via deze privacyverklaring; met derden een verwerkersovereenkomst aangaan waarin afspraken gemaakt worden over de persoonsgegevens die wij een hen doorgeven. Voor beide geldt dat:\nde verzameling van persoonsgegevens zich beperkt zich tot alleen de persoonsgegevens die nodig zijn voor legitieme doeleinden; wij u eerst vragen om uitdrukkelijke toestemming om uw persoonsgegevens te verwerken in gevallen waarin uw toestemming is vereist; wij passende beveiligingsmaatregelen nemen om uw persoonsgegevens te beschermen en dat ook eisen van partijen die in onze opdracht persoonsgegevens verwerken; wij uw recht respecteren om uw persoonsgegevens op uw aanvraag ter inzage te bieden, te corrigeren of te verwijderen. St. Coderdojo Nijmegen is de verantwoordelijke voor de gegevensverwerking. In deze privacyverklaring leggen wij uit welke persoonsgegevens wij verzamelen en gebruiken en met welk doel. Wij raden u aan deze zorgvuldig te lezen.\nGebruik van persoonsgegevens Door het gebruiken van onze dienst laat u bepaalde gegevens bij ons achter. Dat kunnen persoonsgegevens zijn. Wij bewaren en gebruiken uitsluitend de persoonsgegevens die rechtstreeks door u worden opgegeven, in het kader van de door u gevraagde dienst, of waarvan bij opgave duidelijk is dat ze aan ons worden verstrekt om te verwerken. Wij gebruiken uw volgende gegevens voor de in deze privacyverklaring genoemde doelen:\nEmail adressen Cookies voor locatiebepaling (via Matomo) voor bezoek-statistiek (per land). Foto‚Äôs: als er foto‚Äôs worden gemaakt tijdens Coderdojo bijeenkomsten dan wordt ter plekke vooraf om toestemming gevraagd via een webpagina. Verstrekking aan derden Wanneer u bij ons een reservering doet, maken wij voor de afhandeling daarvan gebruik van Eventbrite (www.eventbrite.com). Zij registreren persoonsgegevens ten behoeve van het maken van de reservering ( email-adres en financi√´le gegeven in het geval van donaties).\nBeveiliging Wij nemen beveiligingsmaatregelen om misbruik van en ongeautoriseerde toegang tot persoonsgegevens te beperken. Wij houden statistieken bij op onze website, maar dit gebeurt te allen tijde geanonimiseerd.\nWebsites van derden Deze privacyverklaring is niet van toepassing op websites van derden die door middel van links met deze website zijn verbonden. Wij kunnen niet garanderen dat deze derden op een betrouwbare of veilige manier met uw persoonsgegevens omgaan. Wij raden u aan de privacyverklaring van deze websites te lezen voor van deze websites gebruik te maken.\nWijzigingen in deze privacyverklaring Wij behouden ons het recht voor om wijzigingen aan te brengen in deze privacyverklaring. Het verdient aanbeveling om deze privacyverklaring geregeld te raadplegen, zodat u van deze wijzigingen op de hoogte bent. Bij grote wijzigingen sturen we u een e-mail.\nInzage, wijzigen en verwijderen van uw gegevens Voor vragen over ons privacybeleid of vragen over inzage, wijzigingen in (of verwijdering van) uw persoonsgegevens kunt u altijd contact met ons opnemen via onderstaande gegevens:\nStichting CoderDojo Nijmegen\nNijhoffstraat 5 6524 AT Nijmegen\n","date":"February 8, 2020","permalink":"/privacy/","title":"Privacy beleid"},{"categories":null,"contents":"CoderDojo\u0026rsquo;s draaien op de inzet van vrijwilligers die graag hun kennis delen of hun tijd willen inzetten om kinderen verder te helpen. Wil jij ons ook graag helpen? Dat kan absoluut! Ook als je niet technisch onderlegd bent kun je veel voor ons doen - er komt van alles kijken bij de organisatie van een dojo. Heb je interesse? Stuur dan een mailtje naar ùóÇùóáùñøùóà@ùñºùóàùñΩùñæùóãùñΩùóàùóÉùóà-ùóáùóÇùóÉùóÜùñæùóÄùñæùóá.ùóáùóÖ.\nWat zoeken we in een mentor? Allereerst: je hoeft zeker geen programmeur of IT‚Äôer te zijn om mentor te zijn bij een dojo.\nJe moet het wel leuk vinden om nieuwe onderwerpen onder de knie te krijgen, en daar ook wat tijd in willen en kunnen investeren. We richten ons op kinderen vanaf 7 jaar, wat wil zeggen dat een groot deel van het materiaal dat we aanbieden niet erg ingewikkeld is. Het belangrijkste is dat je met enige regelmaat (maximaal 1 x per maand) een zaterdag beschikbaar bent om te helpen bij de CoderDojo workshops.\nVeel mentoren hebben zelf ook iets aan hun hulp bij CoderDojo, bijvoorbeeld in hun werk, studie of thuissituatie. Het is dus niet erg als je niet alleen iets komt \u0026lsquo;brengen\u0026rsquo;, maar ook ‚Äòhalen‚Äô bij CoderDojo. Integendeel: dit kan juist je plezier en motivatie vergroten. Mentoren hebben ook uiteenlopende interesses: de een bouwt het liefst websites, de ander digitale kunst, en weer een ander haalt vooral energie uit het begeleiden van de kinderen.\nAls mentor is het belangrijk dat je je prettig voelt in de omgang met mensen en met kinderen in het bijzonder. Geduld is daarbij essentieel (ook naar ouders). Bij de begeleiding is een van de lastigste dingen het inschatten wanneer je hulp moet bieden. De kunst is om niet te snel in te grijpen: de kinderen zijn aan het ontdekken en hoeven niet alles meteen te snappen. Soms zorgt dat ervoor dat je tijdens een Dojo weinig te doen hebt, dan hebben we ons ‚Äòwerk‚Äô eigenlijk goed gedaan. Een enkele keer is het nodig om iemand aan te spreken op hun gedrag. Dat kan een deelnemer zijn of een ouder; ook binnen de mentorgroep is er - in goede sfeer - ruimte voor kritische opmerkingen.\nVeel van het materiaal dat we gebruiken is (oorspronkelijk) in het Engels, en onze deelnemers spreken niet altijd vloeiend Nederlands. Het is daarom handig (maar niet noodzakelijk) als je redelijk Engels spreekt en leest. Helemaal handig is het als je het daarnaast leuk vindt om lesmateriaal te vertalen of zelfs te maken.\nBij CoderDojo vinden we deelnemers en mentoren met verschillende achtergronden leuk en verwachten daarom dat je je als mentor prettig voelt in een diverse groep mensen.\nTot slot: bij CoderDojo Nijmegen proberen we een zo veilig mogelijke omgeving te bieden aan onze bezoekers. Een onderdeel daarvan is dat we voor al onze mentoren een Verklaring Omtrend Gedrag aanvragen.\nHeb je interesse? Stuur dan een mailtje naar ùóÇùóáùñøùóà@ùñºùóàùñΩùñæùóãùñΩùóàùóÉùóà-ùóáùóÇùóÉùóÜùñæùóÄùñæùóá.ùóáùóÖ.\nZie ook onze instructiepagina voor voorbeelden van onderwerpen die we behandelen. Op de teampagina kun je iets lezen over de huidige mentoren.\n","date":"February 6, 2020","permalink":"/meehelpen/","title":"Wil je vrijwilliger worden?"},{"categories":null,"contents":"We gaan met 2D game framework L√∂ve2D het klassieke spel Snake bouwen.\n0. Voorbereiding Download en installeer L√ñVE: https://love2d.org; voor meer informatie, zie /instructies/love2d-shooter/#installatie-l√∂ve. Download en installeer Visual Studio Code: https://code.visualstudio.com/download 1. Introductie Vandaag gaan we aan de slag met het spel Snake. Begin met het downloaden van het materiaal en pak daarna de bestanden uit. Open daarna Visual Studio Code en sleep het mapje met de uitgepakte bestanden in het scherm van Visual Studio Code. Als het goed is zie je nu aan de linkerkant een lijstje met alle bestanden. Met deze bestanden gaan we straks aan de slag. Maar laten we eerst kijken naar de spelregels.\nSpelregels Het doel van het spel Snake is om zoveel mogelijk fruit te eten (dit is je score). Hoe meer je eet, hoe langer de slang wordt en ook beweegt de slang sneller. Als de slang tegen zichzelf botst of buiten het scherm gaat is het game over.\nDus om Snake te bouwen moet het spel het volgende doen:\nBeweeg de slang met de pijltjestoetsen; Plaats op een willekeurige plek fruit; De slang moet het fruit kunnen eten; Als er fruit gegeten is moet de slang sneller bewegen; Als er fruit gegeten is moet de slang langer worden; Als er fruit gegeten is krijg je een punt; Als de slang tegen zichzelf botst, is het game over; Ook als de slang buiten het scherm gaat is het game over; Nu we de spelregels duidelijk hebben en weten wat het spel moet gaan doen, is het tijd om Snake te gaan bouwen!\n2. Aan de slag! We beginnen door het main.lua bestand te openen. Klik hierop in de lijst die je aan de linkerkant ziet. Als je het juiste bestand hebt geopend zie je de volgende code:\nextra = require \u0026#34;extrafuncties\u0026#34; function love.load() end function love.draw() end function love.update(dt) end function love.keypressed(key) end De zogenaamde functions (in het Nederlands functie(-s)) die je hier ziet worden uitgevoerd zodra zij nodig zijn. Zo is er een functie die love.load() heet, waarbinnen we de code zetten om bijvoorbeeld onze plaatjes te laden.\n3. Slangenkop Dus als we bijvoorbeeld de kop van de slang willen laden, typen we de volgende regel tussen function love.load() en de eerstvolgende end.\nslangKopPlaatje = love.graphics.newImage(\u0026quot;plaatjes/slangkop.png\u0026quot;)\nAls je het goed getypd hebt, ziet je code er zo uit:\nextra = require \u0026#34;extrafuncties\u0026#34; function love.load() slangKopPlaatje = love.graphics.newImage(\u0026#34;plaatjes/slangkop.png\u0026#34;) end function love.draw() end function love.update(dt) end function love.keypressed(key) end Als je goed kijkt, zie je in het voorbeeld hierboven dat de regel iets verder staat dan alle andere tekst. Dit noemen we inspringen. Als programmeur gebruik je dit om je code beter leesbaar te maken. Je kunt dit zelf doen door je tekstcursor aan het begin van de regel te plaatsen en dan op de toets Tab te drukken.\nSla het programma nu op (Ctrl/Cmd + S). Als je op Windows werkt doe je nu het volgende:\nopen een opdrachtprompt door \u0026ldquo;cmd\u0026rdquo; in te typen in het startmenu. voer het volgende commando uit: \u0026ldquo;c:\\Program Files\\LOVE\\love.exe\u0026rdquo; \u0026ldquo;c:\u0026lt;de_map_waar_jouw_programma_staat\u0026gt;\\love\\snake\u0026rdquo; Als je op een Mac werkt:\nStart L√ñVE sleep de map met je Lua-programma op het L√ñVE-scherm. Deze stap doe je vanaf nu elke keer als je iets hebt veranderd aan je programma en je wilt kijken wat er is veranderd.\nAls je een blauw scherm met een \u0026ldquo;Error\u0026rdquo; krijgt dan klopt er iets niet aan je code, controleer die nog een keer.\nWe hebben nu de slangenkop geladen, maar we zien hem nog niet. Hiervoor moeten we naar de love.draw() functie.\nOnder de regel function love.draw() typen we de volgende regel:\nlove.graphics.draw(slangKopPlaatje, 100, 50)\nAls we nu weer opslaan (Ctrl + S) en opnieuw laden zie je (als je de code goed hebt overgetypd) de kop van de slang!\n4. De rest van de slang De slang moet steeds langer worden, dus laten we daarom een stukje aan de slang toevoegen. Ook hier hebben we een plaatje voor nodig. Voeg de volgende regel toe aan de love.load() functie, onder de regel voor het slangKopPlaatje.\nslangLichaamPlaatje = love.graphics.newImage(\u0026quot;plaatjes/slanglichaam.png\u0026quot;)\nOok hier moeten het plaatje na het laden tekenen op het scherm. Dit doen we door de volgende regel toe te voegen aan de love.draw() functie, onder de regel voor het tekenen van het slangKopPlaatje.\nlove.graphics.draw(slangLichaamPlaatje, 50, 50)\nAls je nu het bestand opslaat en opnieuw laden zie je als het goed is nu twee plaatjes van de slang.\nAchtergrond Laten we het spel ook een achtergrondje geven. Dit gaat precies op dezelfde manier als het toevoegen van het slangKopPlaatje.\nIn de love.load() functie voeg je de volgende regel toe, boven het slangKopPlaatje:\nachtergrondPlaatje = love.graphics.newImage(\u0026quot;plaatjes/achtergrond.png\u0026quot;)\nDaarna voeg je deze regel toe aan de love.draw() functie, ook boven het slangKopPlaatje:\nlove.graphics.draw(achtergrondPlaatje)\n5. Bediening en beweging Om de slang te kunnen bewegen is het goed om te weten wanneer de slang moet bewegen. Bijvoorbeeld wanneer de pijltjestoetsen worden ingedrukt. De code voor de bediening zetten we in de love.keypressed(key) functie. Deze functie wordt uitgevoerd zodra je een knop indrukt. Laten we beginnen met te controleren of er een pijltjestoets is ingedrukt. Voeg de volgende twee regels toe aan de love.keypressed(key) functie.\nif key == \u0026#34;left\u0026#34; or key == \u0026#34;right\u0026#34; or key == \u0026#34;up\u0026#34; or key == \u0026#34;down\u0026#34; then end De eerste regel zegt eigenlijk het volgende Als toets links is, of toets rechts is, of toets boven is, of toets beneden is, dan.... Zie je de vergelijkenis?\nNet als bij functies, wordt op de tweede regel ook het woord end gebruikt. Dit wordt gebruikt om aan te geven dat alleen binnen if ... en end iets zal worden uitgevoerd. Hiertussen gaan we de volgende code zetten, altijd op een nieuwe regel.\nPosities, richting en keerpunten Nu we weten wanneer een pijltjestoets is ingedrukt, willen we de slang een andere richting op laten gaan. Dit doen we door een aantal waarden bij te houden. We houden de positie en de richting bij. Dit doen we in een object. Dit object geven we dan de naam nieuwKeerPunt.\nVoeg de volgende regels toe onder de if en boven de eerstvolgende end.\nnieuwKeerPunt = { positieX = 0, positieY = 0, richtingX = 0, richtingY = 0 } In nieuwKeerPunt houden we nu vier waarden bij - de positieX, positieY, richtingX en richtingY.\nDe positieX kan elke positie zijn op de x-as. Dat is dus van de linkerkant naar rechterkant van het scherm. De positieX 0 is helemaal aan de rechterkant. De rechterkant van het scherm is 800 (de breedte van het scherm). De positieY is de positie van boven naar beneden. Hier is 0 de bovenkant van het scherm en 600 de onderkant van het scherm.\nDe richtingX en de richtingY kan 0, -1 of 1 zijn. Als de richtingX -1 is, gaat de slang naar links. Als de richtingX 1 is gaat de slang naar rechts. En als de richtingX 0 is, gaat de slang niet naar rechts of naar links. De richtingY is precies hetzelfde maar dan voor de richting boven en beneden.\nNu staan alle waarden op 0. Maar dit is tijdelijk. We gaan nu kijken welke pijltjestoets is ingedrukt om de richting te veranderen.\nVoeg de volgende code toe onder de code waar we het nieuwKeerPunt hebben toegvoegd en boven de end van de if die we hiervoor hebben toegevoegd.\nif key == \u0026#34;left\u0026#34; then nieuwKeerPunt.richtingX = -1 nieuwKeerPunt.richtingY = 0 elseif key == \u0026#34;right\u0026#34; then nieuwKeerPunt.richtingX = 1 nieuwKeerPunt.richtingY = 0 elseif key == \u0026#34;up\u0026#34; then nieuwKeerPunt.richtingY = -1 nieuwKeerPunt.richtingX = 0 elseif key == \u0026#34;down\u0026#34; then nieuwKeerPunt.richtingY = 1 nieuwKeerPunt.richtingX = 0 end Deze code verandert nu de richting van het nieuwKeerPunt.\nNu moeten we nog de positie van het nieuwKeerPunt aanpassen. Hiervoor gebruiken we de positie van de kop van de slang. Hiervoor hebben we de volgende twee regels code nodig. Voeg deze toe onder de code die je net hebt toegevoegd. Dus tussen de end die hoort bij de laatste elseif en de eerstvolgende end.\nnieuwKeerPunt.positieX = slang[#slang].positieX nieuwKeerPunt.positieY = slang[#slang].positieY if not extra.bestaatKeerPunt(keerPunten, nieuwKeerPunt) then table.insert(keerPunten, nieuwKeerPunt) end Deze code verandert de positie van nieuwKeerPunt naar de positie van het laatste stukje van de slang. Daarna wordt er gecontroleerd of het nieuwKeerPunt al bestaat in het keerPunten object en hieraan toegevoegd als dat niet zo is. Nu bestaat het woord slang nog niet in de code, dus dat zal foutmeldingen opleveren.\nHiervoor moeten we terug naar de love.load() functie. We kunnen dit woord (slang) niet in de love.keypressed(key) functie zetten omdat deze functie elke keer als er op een toets gedrukt wordt, wordt uitgevoerd. Dit zou betekenen dat het woord slang op elke toets vernieuwd wordt. Maar dat willen we niet. We willen hier alle stukjes van de slang gaan bijhouden. Dus, scroll naar boven, naar de love.load() functie.\nVoeg de volgende regel toe aan de love.load() functie - op een nieuwe regel onder love.load().\nslang = {}\nDeze regel maakt een leeg object met de naam slang.\nIn de love.keypressed(key) functie hebben we het nieuwKeerPunt de positie van het laatste stukje van de slang gegeven. Alleen de positie van de slang bestaat nog niet. Om deze toe te voegen. Moeten we een aantal stukjes toevoegen aan het slang object. Sla een regel over en voeg de volgende regels toe onder de vorige code.\nfor i = 1, 2 do slangStukje = { positieX = 5+1*i, positieY = 5, richtingX = 1, richtingY = 0 } table.insert(slang, slangStukje) end kop = slang[#slang] Deze code voegt stukjes van de slang toe aan het slang object. Bovenaan zie je for i = 1, 2 do staan. Net als bij de if wordt ook for een end. Als je code tussen for en end zet, wordt deze code 2 keer uitgevoerd. Dus in dit geval worden er 2 stukjes van de slang toegevoegd aan het slang object. De laatste functie table.insert(slang, slangStukje) voegt het stukje toe aan het slang object. En de laatste regel geeft aan waar de kop van de slang zit (het laatste stukje).\nEerder maakten we een nieuwKeerPunt aan (in de love.keypressed(key) functie). Ook nieuwKeerPunt wordt toegevoegd aan een object. Het verschil tussen het slang object is, dat het nieuwKeerPunt wordt toegevoegd elke keer als je een pijltjestoets indrukt. Maar ook hier missen we het object waaraan het toegevoegd moet worden, het keerPunten object.\nDaarom voegen we de volgende regel toe onder wat we zonet hebben toegevoegd:\nkeerPunten = {}\nTekenen op de positie van een slangstukje Nu houden we de positie bij van twee slangstukjes, maar we gebruiken deze posities nog niet om hier een plaatje te tekenen. Voor het tekenen van plaatjes moeten we weer terug naar beneden scrollen, naar de love.draw() functie.\nOm de positie te gebruiken om een stukje te tekenen moeten we de twee regels die we in de love.draw() functie hebben gezet vervangen door de volgende code (zorg er voor dat deze code onder love.draw() en boven end staat):\nfor k, slangStukje in pairs(slang) do if k == #slang then love.graphics.draw(slangKopPlaatje, slangStukje.positieX*slangKopPlaatje:getWidth(), slangStukje.positieY*slangKopPlaatje:getHeight()) else love.graphics.draw(slangLichaamPlaatje, slangStukje.positieX*slangLichaamPlaatje:getWidth(), slangStukje.positieY*slangLichaamPlaatje:getHeight()) end end Als je de code juist hebt toegevoegd, het bestand hebt opgeslagen (Ctrl + S) en opnieuw hebt geladen, zou je nu de slang ongeveer in het midden van het scherm moeten zien.\nBewegen Nu is het tijd om de slang daadwerkelijk te laten bewegen. Hiervoor moeten we naar de functie love.update(dt). Deze functie zorgt er voor alles wordt berekend. Dus ook de beweging moet berekend worden. Voeg de volgende regels toe aan de love.update(dt) functie:\nif not gameOver and tellerSlang \u0026gt; tijdSlang then beweegSlang() extra.controleerKeerPunten(keerPunten, slang) tellerSlang = 0 end tellerSlang = tellerSlang + dt Aan de love.load() moet je de volgende regels toevoegen. Doe dit onderaan in de love.load() functie, boven de end.\ntijdSlang = 1 tellerSlang = 0 gameOver = false In de love.update(dt) functie mist alleen nog de beschrijving van de functie beweegSlang(). Deze moeten we zelf schrijven. Dit doen we helemaal onderaan. Op een nieuwe regel voeg je de volgende regels toe:\nfunction beweegSlang() for k, slangStukje in pairs(slang) do for k, keerPunt in pairs(keerPunten) do if slangStukje.positieX == keerPunt.positieX and slangStukje.positieY == keerPunt.positieY then slangStukje.richtingX = keerPunt.richtingX slangStukje.richtingY = keerPunt.richtingY end end slangStukje.positieX = slangStukje.positieX + slangStukje.richtingX slangStukje.positieY = slangStukje.positieY + slangStukje.richtingY end end Als je deze code opslaat en het programma opnieuw laadt zal de slang nu langzaam over het scherm bewegen!\n6. Fruit Fruit plaatsen Nu de slang kan bewegen, kunnen we hem fruit laten eten. Laten we hiervoor teruggaan naar de love.load() functie en een fruit object aanmaken. Dit doen we door de volgende regels toe te voegen, waar je wilt, in de love.load() functie:\nfruit = {} tellerFruit = 0 tijdFruit = 3 appelPlaatje = love.graphics.newImage(\u0026#34;plaatjes/appel.png\u0026#34;) Nu we alle waarden en het plaatje hebben geladen moeten we ergens het fruit object vullen met fruit. Dit doen we in de love.update(dt) functie.\nif not gameOver and tellerFruit \u0026gt; tijdFruit then plaatsFruit() tellerFruit = 0 end tellerFruit = tellerFruit + dt Nu hoeven we alleen nog de missende, plaatsFruit() functie maken. Net als bij de beweegSlang() functie, plaatsen we de plaatsFruit() functie helemaal onderaan. Voeg deze code toe:\nfunction plaatsFruit() nieuwFruit = { positieX = math.random(0, math.floor(love.graphics.getWidth()/appelPlaatje:getWidth())), positieY = math.random(0, math.floor(love.graphics.getHeight()/appelPlaatje:getHeight())) } table.insert(fruit, nieuwFruit) end Deze functie voegt op een willekeurige plaats een stuk fruit toe. We zien alleen het fruit nog niet op het scherm verschijnen. Hiervoor moeten we terug naar de love.draw() functie. De volgorde van je code in de love.draw() functie bepaald wat er eerst getekend moet worden. Dus als we de appels onder de slang willen tekenen, moeten we de volgende code, boven de code van de slang plaatsen (binnen de love.draw() functie):\nfor k, stukFruit in pairs(fruit) do love.graphics.draw(appelPlaatje, stukFruit.positieX*appelPlaatje:getWidth(), stukFruit.positieY*appelPlaatje:getHeight()) end Als nu opslaan en het programma opnieuw laden, zien we nu appels verschijnen op het scherm. Omdat tijdFruit 3 is, wordt er elke 3 seconden een appel toegevoegd.\nFruit eten Als we nu met de slang over een stukje fruit bewegen, gebeurd er niets. Maar we willen dus het fruit opeten. Hiervoor moeten we weer zelf een functie schrijven, de functie eetFruit(). Voeg deze code toe, helemaal onderaan:\nfunction eetFruit() for k, stukFruit in pairs(fruit) do if stukFruit.positieX == kop.positieX and stukFruit.positieY == kop.positieY then table.remove(fruit, k) score = score + 1 tijdSlang = tijdSlang * 0.9 maakSlangLanger() end end end Voeg daarna de volgende regel toe, na extra.controleerKeerPunten(keerPunten, slang), in de love.update(dt) functie:\neetFruit()\nAls de eetFruit() functie wordt uitgevoerd, gebeuren er een aantal dingen:\nHet fruit wordt verwijderd - table.remove(fruit, k) Je krijgt een score - score = score + 1 De slang gaat sneller bewegen - tijdSlang = tijdSlang * 0.9 En de slang wordt langer - maakSlangLanger() De laatste functie ontbreekt nog, de maakSlangLanger() functie. Voeg deze toe, ook helemaal onderaan:\nfunction maakSlangLanger() staartStukje = slang[1] nieuwSlangStukje = { positieX = staartStukje.positieX-staartStukje.richtingX, positieY = staartStukje.positieY-staartStukje.richtingY, richtingX = staartStukje.richtingX, richtingY = staartStukje.richtingY } table.insert(slang, 1, nieuwSlangStukje) end Deze code voegt een stukje van de slang toe, waar de staart is. Dit stukje wordt dan toegevoegd aan het slang object, waar zich ook alle andere stukjes bevinden.\n7. Score Als we nu onze code zouden uitvoeren, zouden we een foutmelding krijgen omdat het score object nog niet bestaat. Deze moeten we nog toevoegen aan de love.load() functie. Dus voeg de volgende regel toe aan je love.load() functie, op een nieuwe regel:\nscore = 0\nEn om de score op het scherm te tonen, voegen we de volgende regel toe aan de love.draw() functie:\nlove.graphics.print(score .. \u0026quot; punten\u0026quot;)\nAls we nu de code opslaan en opnieuw laden, zal de slang steeds langer worden en sneller gaan zodra je meer appels eet.\n8. Game Over Het spel mist nu alleen nog twee spelregels. Je moet game over gaan als de slang tegen zichzelf botst of buiten het scherm gaat.\nOm dit te controleren maken we nog √©√©n functie. Voeg deze code toe, helemaal onderaan:\nfunction controleerGameOver() if kop.positieX \u0026lt; 0 or kop.positieX \u0026gt; math.floor(love.graphics.getWidth()/slangKopPlaatje:getWidth()) or kop.positieY \u0026lt; 0 or kop.positieY \u0026gt; math.floor(love.graphics.getHeight()/slangKopPlaatje:getHeight()) then gameOver = true end for k, slangStukje in pairs(slang) do if slangStukje ~= kop and kop.positieX == slangStukje.positieX and kop.positieY == slangStukje.positieY then gameOver = true end end end Voeg daarna de volgende regel toe na eetFruit() in de love.update(dt) functie:\ncontroleerGameOver()\nEn tot slot voegen we de volgende regels toe aan het einde van de love.draw() functie om een bericht te tonen dat je game over bent:\nif gameOver then love.graphics.print(\u0026#34;Game Over!\u0026#34;, love.graphics.getWidth()/2, love.graphics.getHeight()/2) end Goed gedaan! En dat is het, je hebt het spel Snake gebouwd! Hoe lang hou jij het vol en wat is de hoogste score die je kunt krijgen?\nHeb je iets niet goed begrepen, vraag het dan aan √©√©n van de mentoren, we helpen je natuurlijk graag!\nJe kunt ook altijd een kijkje nemen bij de andere kinderen, misschien kan jij hun helpen!\nLicentie Deze instructies worden, net als alle andere instructies van CoderDojo Nijmegen, aangeboden onder een Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Licentie. ","date":"February 6, 2020","permalink":"/instructies/love2d-snake/","title":"L√∂ve2D - Snake"},{"categories":null,"contents":"Welkom bij CoderDojo Nijmegen WIFI netwerk CoderDojoWifi2.4GHz of CoderDojoWifi5GHz wachtwoord coderdojo server https://server.coderdojo-nijmegen.nl instructies lijst met instructies installatiebestanden pagina met installatiebestanden ","date":"January 1, 0001","permalink":"/index-mcs/","title":""},{"categories":null,"contents":"\nWat gaan we doen? Het is vakantie, ook voor de computers. We gaan weer unplugged met in ieder geval het levend programmeren, RoboRally en de Turing Tumble, een computer die op knikkers werkt!\nVoorbereiding Vergeet niet je goede humeur mee te nemen, de laptop mag deze maand thuis blijven.\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Het enige wat je nodig hebt om mee te kunnen doen is een laptop met werkende wifi waarop je software mag installeren. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"January 1, 0001","permalink":"/dojos/67-unplugged/","title":"#67 Unplugged"},{"categories":null,"contents":"\nWat gaan we doen? Deze maand mogen de robots hun kunsten weer vertonen. We gaan in ieder geval aan de slag met de micro:Maqueen, een veelzijdig robotje met een micro:bit als hersenen. Hopelijk is ook de mBot weer van de partij. Beide robots zijn te programmeren met een Scratch-achtige taal en met \u0026ldquo;echte\u0026rdquo; code - voor elk wat wils dus.\nVoorbereiding Neem een laptop mee, en installeer om snel aan de slag te kunnen de micro:bit offline app en het mBlock programma op.\nCorona We zijn natuurlijk blij dat we weer bij elkaar kunnen komen, wel zijn er de nodige richtlijnen om rekening mee te houden. Onze collega\u0026rsquo;s in Alphen a/d Rijn hebben een duidelijk overzicht gemaakt, kijk hier vooral even naar!\nAlgemene info Kinderen vanaf 7 jaar kunnen gratis meedoen aan CoderDojo. Het enige wat je nodig hebt om mee te kunnen doen is een laptop met werkende wifi waarop je software mag installeren. Ben je 12 jaar of jonger? Dan vragen we je om √©√©n van je ouders mee te nemen om je te begeleiden tijdens de dojo. Verder kan het verstandig zijn om wat te eten mee te nemen, van programmeren krijg je namelijk hongerrrr!\nOm zeker te weten dat we over voldoende spullen beschikken, moet je van tevoren ook even reserveren. Je hebt slechts √©√©n ticket per kind nodig. Ouders hoeven geen ticket te reserveren. Denk er wel even aan om je ticket mee te nemen naar CoderDojo (mag digitaal).\nNo show? Ben je de dag zelf verhinderd, laat het dan op tijd weten! Zo kunnen we mensen op de wachtlijst uitnodigen of besluiten √©√©n van de mentoren een vrije zaterdag te gunnen. Bij herhaaldelijk niet opdagen zonder afmelding halen we je van de mailinglijst.\n","date":"January 1, 0001","permalink":"/dojos/68-robots/","title":"#68 Robots"},{"categories":null,"contents":"","date":"January 1, 0001","permalink":"/instructiesdoorzoeken/","title":"Instructies doorzoeken"},{"categories":null,"contents":"","date":"January 1, 0001","permalink":"/zoeken/","title":"Zoeken"}]